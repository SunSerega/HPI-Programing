<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0066)http://khpi-iip.mipk.kharkiv.edu/library/local/pgmlab2/lr_cpp5.htm -->
<HTML><HEAD><TITLE>Основы программирования. Лабораторные работы</TITLE>
<META content="text/html; charset=koi8-r" http-equiv=Content-Type>
<META content="Oleg G. Starusev" name=Author>
<META content="General Programming" name=Description>
<META content=lesly@mipk-kspu.kharkov.ua name=Owner>
<META content="программирование, C" name=Keywords><!--     -->
<!-- (C) Owner: Oleg G. Starusev -->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. --></HEAD>

<BODY background="../../iip_1.jpg">

<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=lab4.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=lab6.html>Вперед</a></td></tr>
</table>
</p>
<hr>


<H2 align=center>Лабораторная работа ╧5.<BR>Использование библиотеки ввода-вывода языка С++</H2>
<H3 align=center>1. Цель работы</H3>

			    
<P>Целью лабораторной работы является получение практических навыков при использовании флагов и манипуляторов из библиотеки ввода.вывода языка С++.</P>

<H3 align="center">  Краткое теоретическое введение.<BR>Потоки языка С++ </H3>

<P>	Система ввода.вывода С++ , так же как и в языке С, оперирует потоками (streams). В начале выполнения программы автоматически открывается 4 предоставленных потока: cin, cout, cerr и clog. Поток cin связан со стандартным вводом, поток cout - со стандартным выводом. Поток cerr небуферизированный , т.е. вызывает немедленный вывод. Поток clog буферизирован, и вывод происходит только после того, как наполнится буфер. Оба эти потока используются для вывода сообщений об ошибках.</P>
<P>	По умолчанию поток cin связан с клавиатурой , cout - с дисплеем, но они не могут быть перенаправлены на другие устройства или на файловую систему.</P>
<P>	В заголовочном файле IOSTREAM.H определены классы, относящиеся потокам.Эти классы образуют иерархическую систему.</P>
<P> 	Класс нижнего уровня называют streambuf. Он обеспечивает основные операции по неформатированному выводу. Следующий класс называется ios. Он обеспечивает поддержку форматированного ввода/вывода и используется для построения трёх следующих классов: istream, ostream и iostream. istream позволяет создать поток ввода, ostream - поток вывода. Класс iostream может создавать поток, как для ввода, так и для вывода.</P>
			
<H4>		Перегрузка операций ввода/вывода. Инсерторы и экстракторы </H4>
<P> 	Операция  <<  вставки данных в поток (inserting) , будем называть экстрактором(extractor)</P>
<P>	В качестве примера создания функции инсертора рассмотрим класс vector:</P>
<BR>
<PRE>
			class vector{
			public:
			  int x, y, z;
			  vector (int a,int b,int c){x=a; y=b; z=c;}
			}; </PRE><BR>
<P>Перегрузка операции << для этого класса осуществляется</P><BR>
<PRE>			ostream &operator <<(ostream &stream, vector obj)
			{
			  stream << obj.x << ", ";
			  stream << obj.y << ", ";
			  stream << obj.z << "\n";
			  return stream;
			};</PRE>
<P>Ну и блок main для демонстрации работы класса</P><BR>
<PRE>			#include &lt;iostream.h&gt;
			class vector{
			public:
			  int x, y, z;
			  vector (int a,int b,int c){x=a; y=b; z=c;}
			};
			ostream &operator <<(ostream &stream, vector obj)
			{
			  stream << obj.x << ", ";
			  stream << obj.y << ", ";
			  stream << obj.z << "\n";
			  return stream;
			};
			main(void)
			{
			  vector a(1,2,3),b(3,4,5);
			  cout << a << "\n" << b << "\n";
			  return 0;
			}</PRE>
<P>	Общая форма функции инсектора следущая:</P>
<PRE>		ostream &operator <<(ostream &stream,class_type obj)
		 {
		   //тело программы
		  return stream;
		 }</PRE>
<P>	Выше мы использовали вариант stream<<obj.x<<", "; а не  cout<<obj.x<<", "; так как первый вариант жёстко связан с потоком cout , а первый вариант может быть применим к любому потоку.</P>
<P>	Перегрузка операции >> для класса vector осуществляется</P>
<PRE>			istream &operator >> (istream &stream,vector &obj)
			{
			  cout << "Enter x,y,z:";
			  stream >> obj.x >> obj.y >> obj.z;
			  return stream;
			}</PRE>
<P>	Пример общей работы</P>

<PRE>			#include &lt;iostream.h&gt;
			class vector{
			public:
			  int x, y, z;
			  vector (int a,int b,int c){x=a; y=b; z=c;}
			friend ostream& operator << (ostream &stream,vector obj);
			friend istream& operator >> (istream &stream, vector &obj);
			};
			ostream &operator <<(ostream &stream, vector obj)
			{
			  stream << obj.x << ", ";
			  stream << obj.y << ", ";
			  stream << obj.z << "\n";
			  return stream;
			};
			istream &operator >> (istream &stream,vector &obj)
			{
			  cout << "Enter x,y,z:";
			  stream >> obj.x >> obj.y >> obj.z;
			  return stream;
			}
			main(void)
			{
			  vector a(1,2,3);
			  cout << a;
			  cin >> a;
			  cout << a;
			  return 0;
			}</PRE>

<H4>				Форматированный ввод/вывод</H4>
<P>	Для того чтобы организовать форматированый ввод и вывод , анологичный тому , что предостаыляют пользователю функции printf()  и  scanf() в языке C++ используются два способа.</P>
<P>	Первый состоит в применении функций членов - класса ios.</P>
<P>	При втором способе употребляется специальный вид функций, называемых манипуляторами.</P>
<H4>				Флаги (Использование функций-членов класса ios)</H4>
<P>	Состояние правил форматного вывода в поток определяется состоянием флагов форматированого потока. В заголовочном файле iostream.h определено следущее перечисление , задающее флаги форматирования:</P>
<PRE>
enum    {
        skipws    = 0x0001, // отбрасывание пробелов
        left      = 0x0002, // выравнивание по левому краю
        right     = 0x0004, // выравнивание по правому краю
        internal  = 0x0008, // заполнение пустых позиций
        dec   = 0x0010,     // выдача в десятеричном формате
        oct   = 0x0020,     // выдача в восьмеричном формате
        hex   = 0x0040,     // выдача в шестнадцетиричном формате
        showbase  = 0x0080, // выдача основания системы счичления
        showpoint = 0x0100, // выдача позиции точки
        uppercase = 0x0200, // выдача в формате xx.xxxx Exx
        showpos   = 0x0400, // выдача знака у положительного числа
        scientific= 0x0800, // выдача в форме с фиксированной точкой
        fixed     = 0x1000, // выдача в форме с плавающей точкой
        unitbuf   = 0x2000, // улучшенная выдача
        stdio     = 0x4000  // щсвобождение потока
};</PRE>

<P>	* Формат соответствует целому тиа long. Изменить состояние флагов можно функцией
		<PRE>long setf(long flags)</PRE>.</P>
<P>	* Чтобы установить флаг showbase в режим включено (on), используем оператор
		<PRE>stream.set(ios::showbase);</PRE><BR>
	здесь stream - тот конкретный поток , на который мы воздействуем.</P>
<P>	* Для установки флагов можно использовать побитовые операциии:
		<PRE>cout.setf(ios::left | ios::hex);</PRE></P>
<P>* Функция  <PRE>unsetf(long flagsl)</PRE> возвращает флаг в состояние выключено(off).</P>
<P>* Функция <PRE>long flags(void)</PRE> возвращает текущее состояние флагов</P>
<P>* Функция <PRE>int width(int len)</PRE> Возвращает текущую ширину поля выдачи и устанавливает её ширину len.</P>
<P>* Функция <PRE>char fill(char ch)</PRE> возвращает текущий символзаполнения устанавливает новый символ ch заполнения.</P>
<P>* Функция <PRE>int precision(int num)</PRE> возвращает текущее значение десятичных знаков после точки и устанавливает новое значение.</P>
<P>	Использование этого способа иллюстрирует следующий пример:</P>
<PRE>
#include &lt;iostream.h&gt;
#include &lt;iomanip.h&gt;
main(void)
{
  long fl;
  fl= cout.flags();
  cout << "Исходное состояние флагов: "<< fl<<"\n";
  
  cout.setf(ios::showpos);
  cout.setf(ios::scientific);
  cout << 123 << " " << 1.2345678 <<"\n";

  cout.setf(ios::hex | ios::showbase);
  cout.unsetf(ios::showpos);
  cout.width(20);
  cout.precision(10);
  cout << 123 << " " << 123.456 << " " << 1.2345678 << "\n";
  cout << "Новое состояние флагов: " << cout.flags() << "\n";
  cout.flags(fl);
  cout << "После востановления исходного состояния флагов: \n";
  cout << 123 << " " << 123.456 << 1.2345678 << "\n";
  return 0;
}
</PRE>
<H4>				Использование манипуляторов	</H4>
<P>	Для управления форматом выдачи из потока можно использовать специальные функции, называемые манипуляторами. Стандартными манипуляторами, доступ к которым можно получить , подключив файл iomanip.h , являются:</P>
<PRE>
Манипулятор		Действие манипулятора
_________________________________________________________________
dec			Десятичный формат
endl			Вывод символа '\n' и освобождение буфера
ends			Вывод NULL
flush			Освободить поток
hex			Шестнадцатеричный формат числа
resetioflags(long f)	Отключить флаги , определённые f
setbase(int base)	Установить основание системы счисления
setfill(char ch)	Установить символ заполнения
setiosflags(long f)	Установить режим on флагам , указанным f
setprecision(int p)	Установить число цифр после десятичной точки
setw(int w)		Установить ширину поля выдачи
ws			Режим пропуска символов пробела
_________________________________________________________________

</PRE>
<P>Использовать стандартных манипуляторов можно продемонстрировать следующим примером:</P>
<PRE>#include &lt;iostream.h&gt;
 #include &lt;iomanip.h&gt;
main(void)
{
  cout << setprecision(2) << 100.5375 << endl;
  cout << setw(20) << "MANIPULATORS \n";
  return 0;
}</PRE>
			
<H4>				Создание манипуляторов</H4>
<P>	Можно создать свою собственную функцию - манипулятор. Покажем, как сделать функцию манипулятор без параметров. Форма объявления функции - манипулятора функции следущая:</P>
<PRE>	ostream &manip_name(ostream &stream)
	{
	  //Коды программы
	  return stream;
	}</PRE>
<P>	Это манипулятор вывода. Для создания функции - манипулятора ввода надо заметить поток ostream на istream. Пример создания манипулятора с именем left10:</P>
<PRE>
#include &lt;iostream.h&gt;
#include &lt;iomanip.h&gt;

ostream& left10(ostream &stream)
{
  stream.setf(ios::left);
  stream << setw(10);
  return stream;
}
main (void)
{
  cout << 12 << left10 <<15 << 17 <<"\n";
  return 0;
}

</PRE>
<H2 align="center">				Задания к выполнению</H2>
<ol>
 <li>Считайте файл чисел с плавающей точкой, составьте из пар считанных чисел комплексные числа и выведите комплексные числа и сохранить их в новом файле. 
 <li>Перегрузите операцию << для класса , который будет прость ввести любую строку, а затем должен опять вывести её на экран но без больших букв и цифр
 <li>Постройте несколько функций для запроса и чтения различного вида информации. Простейший пример - функция y_or_n() (Которая просит ввести Yes\No). Идеи: почтовый адрес, дата, личные данные и т.д. Постарайтесь сделать их защищенными от неправильного ввода. 
 <li>Напишите программу, которая печатает (1) все буквы в нижнем регистре, (2) все буквы, (3) все буквы и цифры, (4) все символы, которые могут встречаться в идентификаторах C++ на вашей системе, (5) все символы пунктуации
 <li>Реализуйте стандартную библиотеку ввода/вывода C () с помощью стандартной библиотеки ввода/вывода C++ () (достаточно printf и scanf). 
 <li>Реализуйте стандартную библиотеку ввода/вывода C++ () с помощью стандартной библиотеки ввода/вывода C () (достаточно cout и cin). 
 <li>Реализуйте класс, для которого [] перегружено для реализации случайного чтения символов из файла. 
 <li>Как Задание 7, только сделайте, чтобы [] работало и для чтения, и для записи. Подсказка: сделайте, чтобы [] возвращало объект "дескрипторного типа", для которого присваивание означало бы присвоить файлу через дескриптор, а неявное преобразование в char означало бы чтение из файла через дескриптор. 
 <li>Как Задание 8, только разрешите [] индексировать записи некоторого вида, а не символы. 
 <li>Создайте свой манипуляторы которые будут выполнять 1)вывод всех символов большими а чискл в OCT формате 2)вывод всех символов маленькими и замено пробелов на #  3)вывод всех чисел в HEX формате и не выводить пробелов
 <li>Разработайте и реализуйте операцию ввода по сопоставлению с образцом. Должна быть возможность попробовать сопоставить со вводом несколько образцов для нахождения наиболее близкого к образцу. Можно было бы вывести класс ввода по образцу из istream.(примеры образцов десятичное число , имя пользователя , пароль из цифр и символов)
 <li>Придумайте (и реализуйте) вид образцов, которые намного лучше чем в 11. 
 <li>Постройте несколько функций для запроса и чтения различного вида информации. Простейший пример - функция y_or_n() (Которая просит ввести Yes\No). Идеи: Почтовый адрес, дата, личные данные. Постарайтесь сделать их защищенными от дурака. 
 <li>Напишите программу которая будет просить ввести строку символов , после этого он печатает её на экране 1) все буквы в нижнем регистре , 2) все буквы в большом регистре , 3) все числа в строке выводить в HEX формате , 4) вывод с заменой всех пробелов на символ #
 <li>Реализуйте стандартные функции printf(c помощью cout) и cin(с помощью scanf) так, чтобы они могли использоваться одновременно. 
 <li>Реализуйте стандартные функции scanf(c помощью cin) и cout(с помощью printf) так, чтобы они могли использоваться одновременно. 
 <li>Написать программу конвертор чисел из одной системы исчесления в другую.(HEX,BIN,OCT)
 <li>Написать программу которая создаёт массив размером [256] элементов  и заполняет его случайным образом числами от 1 до 1000 . После этого вывести все числа на экран в несколько форматированых столбцов , при этом в первом столбце выводить числа в DEC формате , во втором в HEX формате , в третьем в OCT формате , четвёртый опять в DEC и т.д. до конца.
 <li>Создать класс который при инициализации (в конструкторе) получает имя файла с текстовой строкой , а при уничтожении (в деструкторе) сохраняет строку в другом файле , убрав при этом все пробелы, обрезав у всех дробных чисел количество знаков после запятой до двух и заменив все маленькие буквы на большие.
 <li>Считайте файл с комплексными числами , составьте из каждого числа пару простых чиел и сохраните их в новом файле. 
 <li>Определите тип name_and_address (имя_и_адрес). Определите для него << и >>.  Скопируйте поток объектов name_and_address. 
 <li>Перегрузите операцию << для класса , который будет просить ввести любую строку, а затем должен опять вывести её на экран но без маленьких букв
 <li>Перегрузите операцию >> для класса , прегруженная функция должна передать строку из случайных символов ,а класс должен вывести всю строку  форматировано на экран и без пробелов
 <li>Перегрузите операцию >> для класса , прегруженная функция должна предать строку из случайных символов ,а класс должен вывести всё строку большими буквами ,а все числа в строке вывести в HEX формате
</ol>
<P>
		Пример выполнения задания (╧24)</P>
<PRE>
#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iomanip.h&gt;
class array{
public:
  array();
  char a[100];
  void operator>>(ostream &stream);
};
class probasta{
   array ar;
 public:
  void operator>>(ostream &stream);
  void operator<<(array tst);
};
void main(void)
{
  array ar_test;
  cout << "\nСтрока в оригинале:\n\n";
  ar_test >> cout;
  cout << "\n\nОбработаная строка:\n\n";
  probasta test;
  test << ar_test;
  test >> cout;
}
void array::array()
{
  randomize();
  for(int i=0;i<100;i++){
   a[i]=random(59);
   if(a[i]<24)a[i]=32;
   else a[i]+=64;
   
   }
  randomize();
}
void array::operator>>(ostream &stream)
{
  for(int i=0;i<100;i++)
    stream << a[i];
}

void probasta::operator>>(ostream &stream)
{
  for(int i=0;i<100;i++)
  {
    if((i==30)||(i==60)||(i==90)) stream << "\n";
    if(ar.a[i]!=32) stream << ar.a[i];
  }
}
void probasta::operator<<(array tst)
{
  ar=tst;
}

</PRE>
<hr>
<p>
<table cellpadding=10>
<tr><td><a href=lab4.html>Назад</a></td><td><a href=index.html>Оглавление</a></td><td><a href=lab6.html>Вперед</a></td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
</p>
</body>
</html>
