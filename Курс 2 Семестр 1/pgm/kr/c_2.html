<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Керниган и Ритчи </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://kulichki.rambler.ru/moshkow/  -->
<!-- Owner: Alexander S. Derevjanko (web-design only)-->
<!-- ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_1.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_3.html>Вперед</a></td></tr>
</table>
</p>
<hr>

<h2>2. Типы, операции и выражения.</h2>
 
<p>Переменные и константы являются основными объектами, с которыми оперирует программа. Описания перечисляют переменные, которые будут использоваться, указывают их тип и, во можно, их начальные значения. Операции определяют, что с ними будет сделано. выражения объединяют переменные и константы для получения новых значений. Все это - темы настоящей главы.</p>
 
<a name=21>
<h3>2.1. Имена переменных.</h3>
 
<p>Хотя мы этого сразу прямо не сказали, существуют некоторые ограничения на имена переменных и символических констант. Имена составляются из букв и цифр; первый символ должен быть буквой. Подчеркивание "_" тоже считается буквой; это полезно для удобочитаемости длинных имен переменных. Прописные и строчные буквы различаются; традиционная практика в C - использовать строчные буквы для имен переменных, а прописные - для символических констант.

<p>Играют роль только первые восемь символов внутреннего имени, хотя использовать можно и больше. Для внешних имен, таких как имена функций и внешних переменных, это число может оказаться меньше восьми, так как внешние имена используются различными ассемблерами и загрузчиками. Детали приводятся в приложении А. Кроме того, такие ключевые слова как <samp>if</samp>, <samp>else</samp>, <samp>int</samp>, <samp>float</samp> и т.д., зарезервированы: вы не можете использовать их в качестве имен переменных. (Они пишутся строчными буквами).

<p>Конечно, разумно выбирать имена переменных таким образом, чтобы они означали нечто, относящееся к назначению переменных, и чтобы было менее вероятно спутать их при написании.

<a name=22> 
<h3>     2.2. Типы и размеры данных.</h3>
 
<p>В языке C имеется только несколько основных типов данных:
<ul>
<li> <samp>char</samp> один байт, в котором может находиться один символ из внутреннего набора символов.
<li> <samp>int</samp> целое, обычно соответствующее естественному размеру целых в используемой машине.
<li> <samp>float</samp> с плавающей точкой одинарной точности.
<li> <samp>double</samp> с плавающей точкой двойной точности.
</ul>
<p>Кроме того имеется ряд квалификаторов, которые можно использовать с типом <samp>int: short</samp> (короткое), <samp>long</samp> (длинное) и <samp>unsigned </samp>(без знака). Квалификаторы <samp>short</samp> и <samp>long</samp> указывают на различные размеры целых. Числа без знака подчиняются законам арифметики по модулю 2<sup>n</sup>, где <samp>n</samp> - число битов в <samp>int</samp>; числа без знаков всегда положительны. Описания с квалификаторами имеют вид:
<pre> 
    short int x;
    long int y;
    unsigned int z;
</pre>     
<p>Cлово <samp>int</samp> в таких ситуациях может быть опущено, что обычно и делается.
<p>Количество битов, отводимых под эти объекты зависит от имеющейся машины; в таблице ниже приведены некоторые характерные значения.
 
<p>Таблица 1
<table border=1>
<tr><td>-</td><td><b>DEC PDP-11</b></td><td><b>HONEYWELL 6000</b></td><td><b>IBM 370</b></td><td><b>INTERDATA 8/32</b></td></tr>
<tr><td>char</td><td>ASCII 8-bit</td><td>ASCII 9-bit</td><td>EBCDIC 8-bit</td><td>ASCII 8-bit</td></tr>
<tr><td>int</td><td>16</td><td>36</td><td>32</td><td>32</td></tr>
<tr><td>short</td><td>16</td><td>36</td><td>16</td><td>16</td></tr>
<tr><td>long</td><td>32</td><td>36</td><td>32</td><td>32</td></tr>
<tr><td>float</td><td>32</td><td>36</td><td>32</td><td>32</td></tr>
<tr><td>double</td><td>64</td><td>72</td><td>64</td><td>64</td></tr>
</table> </p>
<p>Цель состоит в том, чтобы <samp>short</samp> и <samp>long</samp> давали возможность в зависимости от практических нужд использовать различные длины целых; тип <samp>int</samp> отражает наиболее "естественный" размер конкретной машины. Как вы видите, каждый компилятор свободно интерпретирует <samp>short</samp> и <samp>long</samp> в соответствии со своими аппаратными средствами. Все, на что вы можете твердо полагаться, это то, что <samp>short</samp> не длиннее, чем <samp>long</samp>.
 
<a name=23>
<h3>      2.3. Константы.</h3>
 
<p>Константы типа <samp>int</samp> и <samp>float</samp> мы уже рассмотрели. Отметим еще только, что как обычная
<pre> 
    123.456е-7,
</pre> 
так и "научная" запись
<pre> 
    0.12е3
</pre> 
для <samp>float</samp> является законной.
<p>Каждая константа с плавающей точкой считается имеющей тип <samp>double</samp>, так что обозначение <samp>E</samp> служит как для <samp>float</samp>, так и для <samp>double</samp>.
<p>     Длинные константы записываются в виде <samp>123L</samp>. Обычная целая константа, которая слишком длинна для типа <samp>int</samp>, рассматривается как <samp>long</samp>.
     
<p>Существует система обозначений для восьмеричных и шестнадцатеричных констант: лидирующий 0(нуль) в константе типа <samp>int</samp> указывает на восьмеричную константу, а стоящие впереди <samp>0x</samp> соответствуют шестнадцатеричной константе. Например, десятичное число 31 можно записать как 037 в восьмеричной форме и как 0x1F в шестнадцатеричной. Шестнадцатеричные и восьмеричные константы могут также заканчиваться буквой <samp>L</samp>, что делает их относящимися к типу <samp>long</samp>.
 
<a name=231>
<h4>      2.3.1. Символьная константа.</h4>
 
<p>Символьная константа - это один символ, заключенный в одинарные кавычки, как, например, 'х'. Значением символьной константы является численное значение этого символа во внутреннем машинном наборе символов. Например, в наборе символов ASCII символьный нуль, или '0', имеет значение 48, а в коде EBCDIC - 240, и оба эти значения совершенно отличны от числа 0. Написание '0' вместо численного значения, такого как 48 или 240, делает программу не зависящей от конкретного численного представления этого символа в данной машине. Символьные константы точно так же участвуют в численных операциях, как и любые другие числа, хотя наиболее часто они используются в сравнении с другими символами. Правила преобразования будут изложены позднее.

<p>Некоторые неграфические символы могут быть представлены как символьные константы с помощью условных последовательностей, как, например, <samp>\n</samp> (новая строка), <samp>\t</samp> (табуляция), <samp>\0</samp> (нулевой символ), <samp>\\</samp> (обратная косая черта), <samp>\'</samp> (одинарная кавычка) и т.д. Хотя они выглядят как два символа, на самом деле являются одним. Кроме того, можно сгенерировать произвольную последовательность двоичных знаков размером в байт, если написать
 <pre>
    '\DDD'
 </pre>
где <samp>DDD</samp> - от одной до трех восьмеричных цифр, как в
<pre> 
    #define  FORMFEED  '\014'  /* form feed */
</pre> 
<p>Символьная константа <samp>'\0'</samp>, изображающая символ со значением 0, часто записывается вместо целой константы 0 , чтобы подчеркнуть символьную природу некоторого выражения.
 
<a name=232>
<h4>    2.3.2. Константное выражение</h4>
 
<p>Константное выражение - это выражение, состоящее из одних констант. Такие выражения обрабатываются во время компиляции, а не при прогоне программы, и соответственно могут быть использованы в любом месте, где можно использовать константу, как, например в
<pre>     
   #define MAXLINE 1000
   char line[MAXLINE+1];
</pre> 
 или
<pre> 
  seconds = 60 * 60 * hours;
</pre> 

<a name=233>
<h4>     2.3.3. Строчная константа</h4>
 
<p>Строчная константа - это последовательность, состоящая из нуля или более символов, заключенных в двойные кавычки, как, например,
<pre> 
   "i am a string"
</pre>
 или
<pre>
   ""    /* NULL string */     
</pre> 
<p>Кавычки не являются частью строки, а служат только для ее ограничения. те же самые условные последовательности, которые использовались в символьных константах, применяются и в строках; символ двойной кавычки изображается как <samp>\"</samp>.

<p>С технической точки зрения строка представляет собой массив, элементами которого являются отдельные символы. Чтобы программам было удобно определять конец строки, компилятор автоматически помещает в конец каждой строки нуль-символ <samp>'\0'</samp>. Такое представление означает, что не накладывается конкретного ограничения на то, какую длину может иметь строка, и чтобы определить эту длину, программы должны просматривать строку полностью. При этом для физического хранения строки требуется на одну ячейку памяти больше, чем число заключенных в кавычки символов. Следующая функция <samp>strlen(s)</samp> вычисляет длину символьной строки s не считая конечный символ <samp>'\0'</samp>.
<pre> 
  strlen(s)       /* return length of s */
  char  s[];
  {
     int i;
 
     i = 0;
     while (s[i] != '\0')
             ++i;
     return(i);
  }
</pre> 
<p>Будьте внимательны и не путайте символьную константу со строкой, содержащей один символ: <samp>'x'</samp> - это не то же самое, что <samp>"x"</samp>. Первое - это отдельный символ, использованный с целью получения численного значения, соответствующего букве х в машинном наборе символов. Второе - символьная строка, состоящая из одного символа (буква <samp>x</samp>) и <samp>'\0'</samp>.
   

<a name=24>
<h3>   2.4. Описания</h3>
 
<p>Все переменные должны быть описаны до их использования, хотя некоторые описания делаются неявно, по контексту. Описание состоит из спецификатора типа и следующего за ним списка переменных, имеющих этот тип, как, например:
<pre> 
 int lower, upper, step;
 char c, line[1000];
</pre> 
<p>Переменные можно распределять по описаниям любым образом; приведенные выше списки можно с тем же успехом записать в виде
<pre> 
 int lower;
 int upper;
 int step;
 char c;
 char line[1000];
</pre> 
<p>Такая форма занимает больше места, но она удобна для добавления комментария к каждому описанию и для последующих модификаций.

<p>Переменным могут быть присвоены начальные значения внутри их описания, хотя здесь имеются некоторые ограничения. Если за именем переменной следуют знак равенства и константа, то эта константа служит в качестве инициализатора, как, например, в
<pre> 
 char backslash = '\\';
 int i = 0;
 float eps = 1.0E-5;
</pre> 
<p>Если рассматриваемая переменная является внешней или статической, то инициализация проводится только один раз, согласно концепции до начала выполнения программы. Инициализируемым явно автоматическим переменным начальные значения присваиваются при каждом обращении к функции, в которой они описаны. Автоматические переменные, не инициализируемые явно, имеют неопределенные значения, (т.е. мусор). Внешние и статические переменные по умолчанию инициализируются нулем, но, тем не менее, их явная инициализация является признаком хорошего стиля.

<p>Мы продолжим обсуждение вопросов инициализации, когда будем описывать новые типы данных.
     
<a name=25>
<h3>      2.5. Арифметические операции.</h3>
 
<p>Бинарными арифметическими операциями являются +, -, *, / и операция деления по модулю %. Имеется унарная операция -, но не существует унарной операции +.

<p>При делении целых дробная часть отбрасывается. Выражение
<pre> 
   x % y
</pre> 
дает остаток от деления <samp>x</samp> на <samp>y</samp> и, следовательно, равно нулю, когда х делится на y точно. Например, год является високосным, если он делится на 4, но не делится на 100, исключая то, что делящиеся на 400 годы тоже являются високосными. Поэтому
<pre> 
 if(year % 4 == 0 && year % 100 != 0 || year % 400 == 0)
     год високосный
 else
     год невисокосный
</pre> 
 
<p>Операцию % нельзя использовать с типами <samp>float</samp> или <samp>double</samp>.
<p>Операции + и - имеют одинаковое старшинство, которое младше одинакового уровня старшинства операций *, / и %, которые в свою очередь младше унарного минуса. Арифметические операции группируются слева направо. (Сведения о старшинстве и ассоциативности всех операций собраны в таблице в конце этой главы). Порядок выполнения ассоциативных и коммутативных операций типа + и - не фиксируется; компилятор может перегруппировывать даже заключенные в круглые скобки выражения, связанные такими операциями. таким образом, <samp>а+(b+c)</samp> может быть вычислено как <samp>(a+b)+c</samp>. Это редко приводит к какому-либо расхождению, но если необходимо обеспечить строго определенный порядок, то нужно использовать явные промежуточные переменные.

<p>Действия, предпринимаемые при переполнении и антипереполнении (т.е. При получении слишком маленького по абсолютной величине числа), зависят от используемой машины.
 
<a name=26>
<h3>      2.6. Операции отношения и логические операции</h3>
 
<p>Операциями отношения являются
<pre> 
  =>   >       =<   <
</pre> 
все они имеют одинаковое старшинство. Непосредственно за ними по уровню старшинства следуют операции равенства и неравенства:
<pre> 
  ==   !=
</pre> 
которые тоже имеют одинаковое старшинство. операции отношения младше арифметических операций, так что выражения типа <samp>i&lt;lim-1</samp> понимаются как <samp>i&lt;(lim-1)</samp>, как и предполагается.

<p>Логические связки && и || более интересны. Выражения, связанные операциями && и ||, вычисляются слева направо, причем их рассмотрение прекращается сразу же как только становится ясно, будет ли результат истиной или ложью. Учет этих свойств очень существенен для написания правильно работающих программ. Рассмотрим, например, оператор цикла в считывающей строку функции <samp>getline</samp>, которую мы написали в главе 1.
<pre>     
 for(i=0;i&lt;lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)
  s[i]=c;
</pre> 
<p>Ясно, что перед считыванием нового символа необходимо проверить, имеется ли еще место в массиве <samp>s</samp>, так что условие <samp>i&lt;lim-1</samp> должно проверяться первым. И если это условие не выполняется, мы не должны считывать следующий символ.

<p>Так же неудачным было бы сравнение <samp>'c'</samp> с <samp>EOF</samp> до обращения к функции <samp>getchar</samp>: прежде чем проверять символ, его нужно считать.

<p>Старшинство операции && выше, чем у ||, и обе они младше операций отношения и равенства. Поэтому такие выражения, как
<pre> 
   i&lt;lim-1 && (c = getchar()) != '\n' && c != EOF
</pre> 
не нуждаются в дополнительных круглых скобках. Но так как операция != старше операции присваивания, то для достижения правильного результата в выражении
<pre> 
  (c = getchar()) != '\n'
</pre>
скобки необходимы.
 
<p>Унарная операция отрицания ! Преобразует ненулевой или истинный операнд в 0, а нулевой или ложный операнд в 1.
<p>Обычное использование операции ! Заключается в записи
<pre> 
   if( ! inword )
</pre> 
<p>Вместо
<pre> 
   if( inword == 0 )
</pre> 
<p>Tрудно сказать, какая форма лучше. Конструкции типа <samp>!inword</samp> читаются довольно удобно ("если не в слове"). Но в более сложных случаях они могут оказаться трудными для понимания.

<p><b><i>     Упражнение 2-1.</i></b></p>
<p>Напишите оператор цикла, эквивалентный приведенному выше оператору <samp>for</samp>, не используя операции &&.
     
<a name=27>
<h3>     2.7. Преобразование типов</h3>
          
<p>Если в выражениях встречаются операнды различных типов, то они преобразуются к общему типу в соответствии с небольшим набором правил. В общем, автоматически производятся только преобразования, имеющие смысл, такие как, например, преобразование целого в плавающее в выражениях типа <samp>f+i</samp>. Выражения же, лишенные смысла, такие как использование переменной типа <samp>float</samp> в качестве индекса, запрещены.
<p>Во-первых, типы <samp>char</samp> и <samp>int</samp> могут свободно смешиваться в арифметических выражениях: каждая переменная типа <samp>char</samp> автоматически преобразуется в <samp>int</samp>. Это обеспечивает значительную гибкость при проведении определенных преобразований символов. Примером может служить функция <samp>atoi</samp>, которая ставит в соответствие строке цифр ее численный эквивалент.
<pre>                       
  atoi(s)         /* convert s to integer */
  char s[];
  {
     int i, n;
 
     n = 0;
     for ( i = 0; s[i]>='0' && s[i]<='9'; ++i)
             n = 10 * n + s[i] - '0';
     return(n);
  }
</pre> 
<p>Kак уже обсуждалось в главе 1, выражение
<pre> 
  s[i] - '0'
</pre> 
имеет численное значение находящегося в <samp>s[i]</samp> символа, потому что значение символов '0', '1' и т.д. образуют возрастающую последовательность расположенных подряд целых положительных чисел.
<p>     Другой пример преобразования <samp>char</samp> в <samp>int</samp> дает функция <samp>lower</samp>, преобразующая данную прописную букву в строчную. Если выступающий в качестве аргумента символ не является прописной буквой, то <samp>lower</samp> возвращает его неизменным. Приводимая ниже программа справедлива только для набора символов ASCII.
<pre> 
 lower(c) /* convert c to lower case; ASCII only */
 int c;
 {
    if ( c >= 'a' && c <= 'z' )
            return( c + '@' - 'a');
    else   /* @ Записано вместо 'a' строчного*/
            return(c);
 }
</pre>
<p> Эта функция правильно работает при коде ASCII, потому что численные значения, соответствующие в этом коде прописным и строчным буквам, отличаются на постоянную величину, а каждый алфавит является сплошным - между <samp>а</samp> и <samp>z</samp> нет ничего, кроме букв. Это последнее замечание для набора символов EBCDIC систем IBM 360/370 оказывается несправедливым, в силу чего эта программа на таких системах работает неправильно - она преобразует не только буквы.
<p>     При преобразовании символьных переменных в целые возникает один тонкий момент. Дело в том, что сам язык не указывает, должны ли переменным типа <samp>char</samp> соответствовать численные значения со знаком или без знака. Может ли при преобразовании <samp>char</samp> в <samp>int</samp> получиться отрицательное целое? К сожалению, ответ на этот вопрос меняется от машины к машине, отражая расхождения в их архитектуре. На некоторых машинах (PDP-11, например) переменная типа <samp>char</samp>, крайний левый бит которой содержит 1, преобразуется в отрицательное целое ("знаковое расширение"). На других машинах такое преобразование сопровождается добавлением нулей с левого края, в результате чего всегда получается положительное число.
     
<p>     Определение языка C гарантирует, что любой символ из стандартного набора символов машины никогда не даст отрицательного числа, так что эти символы можно свободно использовать в выражениях как положительные величины. Но произвольные комбинации двоичных знаков, хранящиеся как символьные переменные на некоторых машинах, могут дать отрицательные значения, а на других положительные.
<p>     Наиболее типичным примером возникновения такой ситуации является сучай, когда значение 1 используется в качестве <samp>EOF</samp>. Рассмотрим программу
<pre> 
  char c;
  c = getchar();
  if ( c == EOF )
     ...
</pre>     
<p>     На машине, которая не осуществляет знакового расширения, переменная <samp>с</samp> всегда положительна, поскольку она описана как <samp>char</samp>, а так как <samp>EOF</samp> отрицательно, то условие никогда не выполняется. Чтобы избежать такой ситуации, мы всегда предусмотрительно использовали <samp>int</samp> вместо <samp>char</samp> для любой переменной, получающей значение от <samp>getchar</samp>.
<p>     Основная же причина использования <samp>int</samp> вместо <samp>char</samp> не связана с каким-либо вопросом о возможном знаковом расширении. Просто функция <samp>getchar</samp> должна передавать все возможные символы (чтобы ее можно было использовать для произвольного ввода) и, кроме того, отличающееся значение <samp>EOF</samp>. Следовательно значение <samp>EOF</samp> не может быть представлено как <samp>char</samp>, а должно храниться как <samp>int</samp>.
<p>     Другой полезной формой автоматического преобразования типов является то, что выражения отношения, подобные <samp>i>j</samp>, и логические выражения, связанные операциями && и ||, по определению имеют значение 1, если они истинны, и 0, если они ложны. Таким образом, присваивание
<pre> 
  isdigit = c >= '0' && c <= '9';
</pre> 
полагает <samp>isdigit</samp> равным 1, если <samp>с</samp> - цифра, и равным 0 в противном случае. (В проверочной части операторов <samp>if, while, for</samp> и т.д. "истинно" просто означает "не нуль").
<p>      Неявные арифметические преобразования работают в основном, как и ожидается. В общих чертах, если операция типа + или *, которая связывает два операнда (бинарная операция), имеет операнды разных типов, то перед выполнением операции "низший" тип преобразуется к "высшему" и получается результат "высшего" типа. Более точно, к каждой арифметической операции применяется следующая последовательность правил преобразования.
<p><ul>
<li>Типы <samp>char</samp> и <samp>short</samp> преобразуются в <samp>int</samp>, а <samp>float</samp> в <samp>double</samp>.
<li>Затем, если один из операндов имеет тип <samp>double</samp>, то другой преобразуется в <samp>double</samp>, и результат имеет тип <samp>double</samp>.
<li>В противном случае, если один из операндов имеет тип <samp>long</samp>, то другой преобразуется в <samp>long</samp>, и результат имеет тип <samp>long</samp>.
<li>В противном случае, если один из операндов имеет тип <samp>unsigned</samp>, то другой преобразуется в <samp>unsigned</samp> и результат имеет тип <samp>unsigned</samp>.
<li>В противном случае операнды должны быть типа <samp>int</samp>, и результат имеет тип <samp>int</samp>.
</ul>
<p> Подчеркнем, что все переменные типа <samp>float</samp> в выражениях преобразуются в <samp>double</samp>; в C вся плавающая арифметика выполняется с двойной точностью.
<p>     Преобразования возникают и при присваиваниях; значение правой части преобразуется к типу левой, который и является типом результата. Символьные переменные преобразуются в целые либо со знаковым расширением, либо без него, как описано выше. Обратное преобразование <samp>int</samp> в <samp>char</samp> ведет себя хорошо - лишние биты высокого порядка просто отбрасываются. Таким образом
<pre> 
 int i;
 char c;
 
 i = c;
 c = i;
</pre> 
значение <samp>с</samp> не изменяется. Это верно независимо от того, вовлекается ли знаковое расширение или нет.
<p>     Если <samp>х</samp> типа <samp>float</samp>, а <samp>i</samp> типа <samp>int</samp>, то как
<pre> 
  х = i;
</pre>
 так и
<pre>
  i = х;
</pre> 
приводят к преобразованиям; при этом <samp>float</samp> преобразуется в <samp>int</samp> отбрасыванием дробной части. Тип <samp>double</samp> преобразуется во <samp>float</samp> округлением. Длинные целые преобразуются в более короткие целые и в переменные типа <samp>char</samp> посредством отбрасывания лишних битов высокого порядка.
<p>     Так как аргумент функции является выражением, то при передаче функциям аргументов также происходит преобразование типов: в частности, <samp>char</samp> и <samp>short</samp> становятся <samp>int</samp>, а <samp>float</samp> становится <samp>double</samp>. Именно поэтому мы описывали аргументы функций как <samp>int</samp> и <samp>double</samp> даже тогда, когда обращались к ним с переменными типа <samp>char</samp> и <samp>float</samp>.
<p>     Наконец, в любом выражении может быть осуществлено ("принуждено") явное преобразование типа с помощью конструкции, называемой перевод (<samp>cast</samp>). В этой конструкции, имеющей вид
<pre> 
  (имя типа) выражение
</pre>           
     
<p>     Выражение преобразуется к указанному типу по правилам преобразования, изложенным выше. Фактически точный смысл операции перевода можно описать следующим образом: выражение как бы присваивается некоторой переменной указанного типа, которая затем используется вместо всей конструкции. Например, библиотечная процедура <samp>sqrt</samp> ожидает аргумента типа <samp>double</samp> и выдаст бессмысленный ответ, если к ней по небрежности обратятся с чем-нибудь иным. Таким образом, если <samp>n</samp> - целое, то выражение
<pre> 
  sqrt((double) n)
</pre> 
до передачи аргумента функции <samp>sqrt</samp> преобразует <samp>n</samp> к типу <samp>double</samp>. (Отметим, что операция перевод преобразует значение n в надлежащий тип; фактическое содержание переменной n при этом не изменяется). Операция перевода имрация перевода имеет тот же уровень старшинства, что и другие унарные операции, как указывается в таблице в конце этой главы.

<p><b><i>    Упражнение 2-2.</i></b></p>
<p>     Составьте программу для функции <samp>htoi(s)</samp>, которая преобразует строку шестнадцатеричных цифр в эквивалентное ей целое значение. При этом допустимыми цифрами являются цифры от 1 до 9 и буквы от A до F.
 
<a name=28>
<h3>     2.8. Операции увеличения и уменьшения</h3>
 
<p>     В языке C предусмотрены две необычные операции для увеличения и уменьшения значений переменных. Операция увеличения ++ добавляет 1 к своему операнду, а операция уменьшения -- вычитает 1. Мы часто использовали операцию ++ для
 увеличения переменных, как, например, в
<pre> 
  if(c == '\n')
     ++i;
</pre> 
<p>     Необычный аспект заключается в том, что ++ и -- можно использовать либо как префиксные операции (перед переменной, как в <samp>++n</samp>), либо как постфиксные (после переменной: <samp>n++</samp>). Эффект в обоих случаях состоит в увеличении <samp>n</samp>. Но выражение <samp>++n</samp> увеличивает переменную <samp>n</samp> до использования ее значения, в то время как <samp>n++</samp> увеличивает переменную <samp>n</samp> после того, как ее значение было использовано. Это означает, что в контексте, где используется значение переменной, а не только эффект увеличения, использование <samp>++n</samp> и <samp>n++</samp> приводит к разным результатам. Если <samp>n = 5</samp>, то
<pre> 
  х = n++;
</pre> 
устанавливает <samp>х</samp> равным 5, а
<pre> 
  х = ++n;
</pre>     
 
полагает <samp>х</samp> равным 6. В обоих случаях <samp>n</samp> становится равным 6. Операции увеличения и уменьшения можно применять только к переменным; выражения типа <samp>х=(i+j)++</samp> являются незаконными.
<p>     В случаях, где нужен только эффект увеличения, а само значение не используется, как, например, в
<pre> 
 if ( c == '\n' )
    nl++;
</pre> 
выбор префиксной или постфиксной операции является делом вкуса. но встречаются ситуации, где нужно использовать именно ту или другую операцию. Рассмотрим, например, функцию <samp>squeeze(s,c)</samp>, которая удаляет символ <samp>с</samp> из строки <samp>s</samp>, каждый раз, как он встречается.
<pre> 
 squeeze(s,c)    /* delete all c from s */
 char s[];
 int c;
 {
    int i, j;
 
    for ( i = j = 0; s[i] != '\0'; i++)
            if ( s[i] != c )
     s[j++] = s[i];
    s[j] = '\0';
 }
</pre> 
<p> Каждый раз, как встечается символ, отличный от <samp>с</samp>, он копируется в текущую позицию <samp>j</samp>, и только после этого <samp>j</samp> увеличивается на 1, чтобы быть готовым для поступления следующего символа. Это в точности эквивалентно записи
<pre> 
    if ( s[i] != c ) {
            s[j] = s[i];
            j++;
    }
</pre> 
<p>     Другой пример подобной конструкции дает функция <samp>getline</samp>, которую мы запрограммировали в главе 1, где можно заменить
<pre> 
 if ( c == '\n' )  {
    s[i] = c;
    ++i;
 }
</pre> 
более компактной записью
<pre> 
 if ( c == '\n' )
    s[i++] = c;
           
</pre>     
<p>     В качестве третьего примера рассмотрим функцию <samp>strcat(s,t)</samp>, которая приписывает строку <samp>t</samp> в конец строки <samp>s</samp>, образуя конкатенацию строк <samp>s</samp> и <samp>t</samp>. При этом предполагается, что в <samp>s</samp> достаточно места для хранения полученной комбинации.
<pre> 
  strcat(s,t)     /* concatenate t to end of s */
  char s[], t[];  /* s must be big enough */
  {
     int i, j;
 
     i = j = 0;
     while (s[i] != '\0') / *find end of s */
             i++;
    while((s[i++] = t[j++]) != '\0') /*copy t*/
             ;
  }
</pre> 
<p> Tак как из <samp>t</samp> в s копируется каждый символ, то для подготовки к следующему прохождению цикла постфиксная операция ++ применяется к обеим переменным <samp>i</samp> и <samp>j</samp>.
 
<p><b><i>     Упражнение 2-3.</i></b></p>
<p>     Напишите другой вариант функции <samp>squeeze(s1,s2)</samp>, который удаляет из строки <samp>s1</samp> каждый символ, совпадающий с каким-либо символом строки <samp>s2</samp>.

<p><b><i>     Упражнение 2-4.</i></b></p>
<p>     Напишите программу для функции <samp>any(s1,s2)</samp>, которая находит место первого появления в строке <samp>s1</samp> какого-либо символа из строки <samp>s2</samp> и, если строка <samp>s1</samp> не содержит символов строки <samp>s2</samp>, возвращает значение -1.
 
<a name=29>
<h3>     2.9. Побитовые логические операции</h3>
     
<p>     В языке предусмотрен ряд операций для работы с битами; эти операции нельзя применять к переменным типа <samp>float</samp> или <samp>double</samp>.
<pre> 
  &     побитовое <samp>AND</samp>
  |     побитовое включающее <samp>OR</samp>
  ^     побитовое исключающее <samp>OR</samp>
  <<    сдвиг влево
  >>    сдвиг вправо
  ~     дополнение (унарная операция)
</pre>  
<p> Побитовая операция <samp>AND</samp> часто используется для маскирования некоторого множества битов; например, оператор
<pre> 
    c = n & 0177
</pre>           
передает в с семь младших битов <samp>n</samp>, полагая остальные равными нулю. Операция | побитового <samp>OR</samp> используется для включения битов:
<pre> 
    c = x | mask
</pre> 
устанавливает на единицу те биты в <samp>х</samp> , которые равны единице в <samp>mask</samp>.
<p>     Следует быть внимательным и отличать побитовые операции & и | от логических связок && и ||, которые подразумевают вычисление значения истинности слева направо. Например, если <samp>х=1</samp>, а <samp>y=2</samp>, то значение <samp>х&y</samp> равно нулю, в то время как значение <samp>x&&y</samp> равно единице.
<p>     Операции сдвига << и >> осуществляют соответственно сдвиг влево и вправо своего левого операнда на число битовых позиций, задаваемых правым операндом. Таким образом, <samp>х<<2</samp> сдвигает х влево на две позиции, заполняя освобождающиеся биты нулями, что эквивалентно умножению на 4. Сдвиг вправо величины без знака заполняет освобождающиеся биты на некоторых машинах, таких как PDP-11, заполняются содержанием знакового бита ("арифметический сдвиг"), а на других - нулем ("логический сдвиг").
<p>     Унарная операция ~ дает дополнение к целому; это означает , что каждый бит со значением 1 получает значение 0 и наоборот. Эта операция обычно оказывается полезной в выражениях типа
<pre> 
    x & ~077
</pre> 
где последние шесть битов <samp>х</samp> маскируются нулем. Подчеркнем, что выражение <samp>x&~077</samp> не зависит от длины слова и поэтому предпочтительнее, чем, например, <samp>x&0177700</samp>, где предполагается, что <samp>х</samp> занимает 16 битов. Такая переносимая форма не требует никаких дополнительных затрат, поскольку ~077 является константным выражением и, следовательно, обрабатывается во время компиляции.
<p>     Чтобы проиллюстрировать использование некоторых операций с битами, рассмотрим функцию <samp>getbits(x,p,n)</samp>, которая возвращает (сдвинутыми к правому краю) начинающиеся с позиции <samp>р</samp> поле переменной <samp>х</samp> длиной <samp>n</samp> битов. мы предполагаем , что крайний правый бит имеет номер 0, и что <samp>n</samp> и <samp>р</samp> - разумно заданные положительные числа. Например, <samp>getbits(х,4,3)</samp> возвращает сдвинутыми к правому краю биты, занимающие позиции 4,3 и 2.
<pre> 
  getbits(x,p,n)  /* get n bits from position p */
  unsigned x, p, n;
   {
     return((x >> (p+1-n)) & |^(~0 << n));
   }
</pre>     
 
<p> Операция <samp>x >> (p+1-n)</samp> сдвигает желаемое поле в правый конец слова. Описание аргумента <samp>x</samp> как <samp>unsigned</samp> гарантирует, что при сдвиге вправо освобождающиеся биты будут заполняться нулями, а не содержимым знакового бита, независимо от того, на какой машине пропускается программа. Все биты константного выражения ~0 равны 1; сдвиг его на <samp>n</samp> позиций влево с помощью операции <samp>~0&lt;&lt;n</samp> создает маску с нулями в <samp>n</samp> крайних правых битах и единицами в остальных; дополнение ~ создает маску с единицами в n крайних правых битах.

<p><b><i>     Упражнение 2-5.</i></b></p>
<p>     Переделайте <samp>getbits</samp> таким образом, чтобы биты отсчитывались слева направо.

<p><b><i>     Упражнение 2-6.</i></b></p>
<p>     Напишите программу для функции <samp>wordlength()</samp>, вычисляющей длину слова используемой машины, т.е. число битов в переменной типа <samp>int</samp>. Функция должна быть переносимой, т.е. Одна и та же исходная программа должна правильно работать на любой машине.

<p><b><i>     Упражнение 2-7.</i></b></p>
<p>     Напишите программу для функции <samp>rightrot(n,b)</samp>, сдвигающей циклически целое <samp>n</samp> вправо на <samp>b</samp> битовых позиций.

<p><b><i>     Упражнение 2-8.</i></b></p>
<p>     Напишите программу для функции <samp>invert(x,p,n)</samp>, которая инвертирует (т.е. заменяет 1 на 0 и наоборот) <samp>n</samp> битов <samp>x</samp>, начинающихся с позиции <samp>p</samp>, оставляя другие биты неизмененными.
 
<a name=210>
<h3>      2.10. Операции и выражения присваивания.</h3>
 
<p>     Такие выражения, как
<pre> 
 i = i + 2
</pre>  
в которых левая часть повторяется в правой части могут быть записаны в сжатой форме
<pre> 
 i += 2
</pre> 
используя операцию присваивания вида +=.
<p>     Большинству бинарных операций (операций подобных +, которые имеют левый и правый операнд) соответствует операция присваивания вида <samp>оп=</samp>, где <samp>оп</samp> - одна из операций
<pre> 
 +  - *  /  %  <<  >>  &  ~  |
</pre> 
<p>Если <samp>е1</samp> и <samp>е2</samp> - выражения, то
<pre>     
 е1 оп= е2
</pre>     
эквивалентно
<pre> 
 е1 = (е1) оп (е2)
</pre> 
за исключением того, что выражение <samp>е1</samp> вычисляется только один раз. Обратите внимание на круглые скобки вокруг <samp>е2</samp>:
<pre> 
 x *= y + 1
</pre> 
 то
<pre> 
 x = x * (y + 1)
</pre> 
 не
<pre> 
 x = x * y + 1
</pre> 
<p>     В качестве примера приведем функцию <samp>bitcount</samp>, которая подсчитывает число равных 1 битов у целого аргумента.
 
<pre> 
 bitcount(n)   /* count 1 bits in n */
 unsigned n;
 (
 int b;
 for (b = 0; n != 0; n >>= 1)
    if (n & 01)
            b++;
 return(b);
)
</pre> 
<p>     Не говоря уже о краткости, такие операторы приваивания имеют то преимущество, что они лучше соответствуют образу человеческого мышления. Мы говорим: "прибавить 2 к <samp>i</samp>" или "увеличить <samp>i</samp> на 2", но не "взять <samp>i</samp>, прибавить 2 и поместить результат опять в <samp>i</samp>". Итак, <samp>i += 2</samp>. Кроме того, в громоздких выражениях, подобных
<pre> 
  yyval[yypv[p3+p4] + yypv[p1+p2]] += 2
</pre> 
такая операция присваивания облегчает понимание программы, так как читатель не должен скрупулезно проверять, являются ли два длинных выражения действительно одинаковыми, или задумываться, почему они не совпадают. Такая операция присваивания может даже помочь компилятору получить более эффективную программу.
<p>     Мы уже использовали тот факт, что операция присваивания имеет некоторое значение и может входить в выражения; самый типичный пример
<pre>              
  while ((c = getchar()) != EOF)
</pre> 
присваивания, использующие другие операции присваивания (+=, -= и т.д.) также могут входить в выражения, хотя это случается реже.
<p>      Типом выражения присваивания является тип его левого операнда.

<p><b><i>     Упражнение 2-9.</i></b></p>
<p>      В двоичной системе счисления операция <samp>x&(x-1)</samp> обнуляет самый правый равный 1 бит переменной <samp>x</samp> (почему?)/ Используйте это замечание для написания более быстрой версии функции <samp>bitcount</samp>.
 
<a name=211>      
<h3>2.11. Условные выражения.</h3>
 
      Операторы
<pre> 
  if (a > b)
     z = a;
  else
     z = b;
</pre> 
конечно вычисляют в <samp>z</samp> максимум из <samp>a</samp> и <samp>b</samp>. Условное выражение, записанное с помощью тернарной операции "?:", предоставляет другую возможность для записи этой и аналогичных конструкций. В выражении
<pre> 
 е1 ? e2 : е3
</pre> 
сначала вычисляется выражение <samp>е1</samp>. Если оно отлично от нуля (истинно), то вычисляется выражение <samp>е2</samp>, которое и становится значением условного выражения. В противном случае вычисляется <samp>е3</samp>, и оно становится значением условного выражения. Каждый раз вычисляется только одно из выражения <samp>е2</samp> и <samp>е3</samp>. Таким образом, чтобы положить <samp>z</samp> равным максимуму из <samp>a</samp> и <samp>b</samp>, можно написать
<pre> 
 z = (a > b) ? a : b;   /* z = MAX(a,b) */
</pre> 
<p>     Следует подчеркнуть, что условное выражение действительно является выражением и может использоваться точно так же, как любое другое выражение. Если <samp>е2</samp> и <samp>е3</samp> имеют разные типы, то тип результата определяется по правилам преобразования, рассмотренным ранее в этой главе. например, если <samp>f</samp> имеет тип <samp>float</samp>, а <samp>n</samp> - тип <samp>int</samp>, то выражение
<pre> 
 (n > 0) ? f : n
</pre> 
имеет тип <samp>double</samp> независимо от того, положительно ли <samp>n</samp> или нет.
     
<p>     Так как уровень старшинства операции ?: очень низок, прямо над присваиванием, то первое выражение в условном выражении можно не заключать в круглые скобки. Однако, мы все же рекомендуем это делать, так как скобки делают условную часть выражения более заметной.
<p>     Использование условных выражений часто приводит к коротким программам. Например, следующий ниже оператор цикла печатает <samp>n</samp> элементов массива, по 10 в строке, разделяя каждый столбец одним пробелом и заканчивая каждую строку (включая последнюю) одним символом перевода строки.
<pre> 
   for (i = 0; i < n; i++)
     printf("%6d%c",a[i],(i%10==9 || i==n-1) ? '\n' : ' ')
</pre> 
<p> Символ перевода строки записывается после каждого десятого элемента и после <samp>n-</samp>го элемента. За всеми остальными элементами следует один пробел. Хотя, возможно, это выглядит мудреным, было бы поучительным попытаться записать это, не используя условного выражения.

<p><b><i>     Упражнение 2-10.</i></b></p>
<p> Перепишите программу для функции <samp>lower</samp>, которая переводит прописные буквы в строчные, используя вместо конструкции <samp>if-else</samp> условное выражение.
 
<a name=212>
<h3>      2.12. Старшинство и порядок вычисления.</h3>
 
<p> В приводимой ниже таблице сведены правила старшинства и ассоциативности всех операций, включая и те, которые мы еще не обсуждали. Операции, расположенные в одной строке, имеют один и тот же уровень старшинства; строки расположены в порядке убывания старшинства. Так, например, операции *, / и % имеют одинаковый уровень старшинства, который выше, чем уровень операций + и -.</p>
<p><table border=1 align=center>
<tr><td><b>OPERATOR</b></td><td><b>ASSOCIATIVITY</b></td></tr>
<tr><td>() [] -&gt; . </td><td>        left to right</td></tr>
<tr><td>!  ~ ++  --  -  (TYPE)  * &amp;  sizeof</td><td> right to left</td></tr>
<tr><td>*  /  %        </td><td>left to right</td></tr>
<tr><td>+  -         </td><td>left to right</td></tr>
<tr><td>&lt;&lt; &gt;&gt;     </td><td>    left to right</td></tr>
<tr><td>&lt; &lt;= &gt;  &gt;=        </td><td>left to right</td></tr>
<tr><td>==  !=         </td><td>left to right</td></tr>
<tr><td>&amp;         </td><td>left to right</td></tr>
<tr><td>^         </td><td>left to right</td></tr>
<tr><td>|    </td><td>     left to right</td></tr>
<tr><td>&amp;&amp;    </td><td>     left to right</td></tr>
<tr><td>||         </td><td>left to right</td></tr>
<tr><td>?:         </td><td>right to left</td></tr>
<tr><td>=  += -=  etc.      </td><td> right to left</td></tr>
<tr><td>,       </td><td>left to right</td></tr>
</table>
 
<p>  Операции -&gt; и . Используются для доступа к элементам структур; они будут описаны в главе 6 вместе с sizeof (размер объекта). В главе 5 обсуждаются операции * (косвенная адресация) и &amp; (адрес). Отметим, что уровень старшинства побитовых логических операций &amp;, ^ и | ниже уровня операций == и !=. Это приводит к тому, что осуществляющие побитовую проверку выражения, подобные
<pre> 
 if ((x &amp; mask) == 0) ...
</pre> 
для получения правильных результатов должны заключаться в круглые скобки.
<p>     Как уже отмечалось ранее, выражения, в которые входит одна из ассоциативных и коммутативных операций (*, +, &amp;, ^, |), могут перегруппировываться, даже если они заключены в круглые скобки. В большинстве случаев это не приводит к каким бы то ни было расхождениям; в ситуациях, где такие расхождения все же возможны, для обеспечения нужного порядка вычислений можно использовать явные промежуточные переменные.
<p>     В языке C, как и в большинстве языков, не фиксируется порядок вычисления операндов в операторе. Например в операторе вида
<pre> 
 x = f() + g();
</pre> 
сначала может быть вычислено <samp>f</samp>, а потом <samp>g</samp>, и наоборот; поэтому, если либо <samp>f</samp>, либо <samp>g</samp> изменяют внешнюю переменную, от которой зависит другой операнд, то значение <samp>x</samp> может зависеть от порядка вычислений. Для обеспечения нужной последовательности промежуточные результаты можно опять запоминать во временных переменных.
<p>     Подобным же образом не фиксируется порядок вычисления аргументов функции, так что оператор
<pre> 
 printf("%d %d\n",++n,power(2,n));
</pre>     
может давать (и действительно дает) на разных машинах разные результаты в зависимости от того, увеличивается ли <samp>n</samp> до или после обращения к функции <samp>power</samp>. Правильным решением, конечно, является запись
<pre> 
 ++n;
 printf("%d %d\n",n,power(2,n));
</pre> 
<p>     Обращения к функциям, вложенные операции присваивания, операции увеличения и уменьшения приводят к так называемым "побочным эффектам" - некоторые переменные изменяются как побочный результат вычисления выражений. В любом выражении, в котором возникают побочные эффекты, могут существовать очень тонкие зависимости от порядка, в котором определяются входящие в него переменные. примером типичной неудачной ситуации является оператор
<pre> 
 a[i] = i++;
</pre> 
<p> Возникает вопрос, старое или новое значение <samp>i</samp> служит в качестве индекса. Компилятор может поступать разными способами и в зависимости от своей интерпретации выдавать разные результаты. Тот случай, когда происходят побочные эффекты (присваивание фактическим переменным), - оставляется на усмотрение компилятора, так как наилучший порядок сильно зависит от архитектуры машины.
<p>      Из этих рассуждений вытекает такая мораль: написание программ, зависящих от порядка вычислений, является плохим методом программирования на любом языке. Конечно, необходимо знать, чего следует избегать, но если вы не в курсе, как некоторые вещи реализованы на разных машинах, это неведение может предохранить вас от неприятностей. (Отладочная программа <samp>lint</samp> укажет большинство мест, зависящих от порядка вычислений.)
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_1.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_3.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>