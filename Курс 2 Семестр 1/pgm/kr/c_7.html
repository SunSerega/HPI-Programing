<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Керниган и Ритчи </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://kulichki.rambler.ru/moshkow/  -->
<!-- Owner: Alexander S. Derevjanko (web-design only)-->
<!-- ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_6.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_8.html>Вперед</a></td></tr>
</table>
</p>
<hr>

<h2>     7. Ввод и вывод</h2>
<p>     Средства ввода/вывода не являются составной частью языка C, так что мы не выделяли их в нашем предыдущем изложении. Однако реальные программы взаимодействуют со своей окружаю щей средой гораздо более сложным образом, чем мы видели до сих пор. В этой главе будет описана "стандартная библиотека ввода/вывода", то есть набор функций, разработанных для обеспечения стандартной системы ввода/вывода для C-программ. Эти функции предназначены для удобства программного интерфейса, и все же отражают только те операции, которые могут быть обеспечены на большинстве современных операционных систем. Процедуры достаточно эффективны для того, чтобы пользователи редко чувствовали необходимость обойти их "ради эффективности", как бы ни была важна конкретная задача. И, наконец, эти процедуры задуманы быть "переносимыми" в том смысле, что они должны существовать в совместимом виде на любой системе, где имеется язык C, и что программы, которые ограничивают свои взаимодействия с системой возможностями, предоставляемыми стандартной библиотекой, можно будет переносить с одной системы на другую по существу без изменений.
<p>     Мы здесь не будем пытаться описать всю библиотеку ввода/вывода; мы более заинтересованы в том, чтобы продемонстрировать сущность написания C-программ, которые взаимодействуют со своей операционной средой.
 
<a name=71>
<h3>     7.1. Обращение к стандартной библиотеке</h3>
<p>     Каждый исходный файл, который обращается к функции из стандартной библиотеки, должен вблизи начала содержать строку
<pre> 
    #include &lt;stdio.h&gt;
</pre> 
в файле stdio.h определяются некоторые макросы и переменные, используемые библиотекой ввода/вывода. Использование угловых скобок вместо обычных двойных кавычек - указание компилятору искать этот файл в справочнике, содержащем заголовки стандартной информации (на системе UNIX обычно lusrlinclude).
<p>     Кроме того, при загрузке программы может оказаться необходимым указать библиотеку явно; на системе PDP-11 UNIX, например, команда компиляции программы имела бы вид:
<pre> 
   cc   исходные файлы и т.д. -ls
</pre> 
где -ls указывает на загрузку из стандартной библиотеки.
 
<a name=72>
<h3>     7.2. Стандартный ввод и вывод - функции getchar и putchar</h3>
 
<p>     Самый простой механизм ввода заключается в чтении по одному символу за раз из "стандартного ввода", обычно с терминала пользователя, с помощью функции getchar. Функция getchar() при каждом к ней обращении возвращает следующий вводимый символ. В большинстве сред, которые поддерживают язык C, терминал может быть заменен некоторым файлом с помощью обозначения &lt; : если некоторая программа prog использует функцию getchar то командная строка
<pre> 
   prog&lt;infile
</pre> 
приведет к тому, что prog будет читать из файла infile, а не с терминала. Переключение ввода делается таким образом, что сама программа prog не замечает изменения; в частности строка"&lt;infile" не включается в командную строку аргументов в argv. Переключение ввода оказывается незаметным и в том случае, когда вывод поступает из другой программы посредством поточного (pipe) механизма; командная строка
<pre> 
   otherprog | prog
</pre> 
прогоняет две программы, otherprog и prog, и организует так, что стандартным вводом для prog служит стандартный вывод otherprog.
<p>     Функция getchar возвращает значение EOF, когда она попадает на конец файла, какой бы ввод она при этом не считывала. Стандартная библиотека полагает символическую константу EOF равной -1 (посредством #define в файле stdio.h), но проверки следует писать в терминах EOF, а не -1, чтобы избежать зависимости от конкретного значения.
<p>     Вывод можно осуществлять с помощью функции putchar(c), помещающей символ 'с' в "стандартный ввод", который по умолчанию является терминалом. Вывод можно направить в некоторый файл с помощью обозначения &gt; : если prog использует putchar, то командная строка
<pre> 
   prog&gt;outfile
</pre> 
приведет к записи стандартного вывода в файл outfile, а не на терминал. На системе UNIX можно также использовать поточный механизм. Строка
<pre> 
   prog | anotherprog
</pre> 
помещает стандартный вывод prog в стандартный ввод anotherprog. И опять prog не будет осведомлена об изменении
 направления.

<p>     Вывод, осуществляемый функцией printf, также поступает в стандартный вывод, и обращения к putchar и printf могут перемежаться.

<p>     Поразительное количество программ читает только из одного входного потока и пишет только в один выходной поток; для таких программ ввод и вывод с помощью функций getchar, putchar и printf может оказаться вполне адекватным и для начала определенно достаточным. Это особенно справедливо тогда, когда имеется возможность указания файлов для ввода и вывода и поточный механизм для связи вывода одной программы с вводом другой. Рассмотрим, например, программу lower, которая преобразует прописные буквы из своего ввода в строчные:
<pre> 
 #include &lt;stdio.h&gt;
 
 main() /* convert input to lower case */
 {
  int c;
 
  whlie ((c = getchar()) != EOF)
     putchar(isupper(c) ? tolower(c) : c);
 }
</pre> 

<p> "Функции" isupper и tolower на самом деле являются макросами, определенными в stdio.h . Макрос isupper проверяет, является ли его аргумент буквой из верхнего регистра, и возвращает ненулевое значение, если это так, и нуль в противном случае. Макрос tolower преобразует букву из верхнего регистра в ту же букву нижнего регистра. Независимо от того, как эти функции реализованы на конкретной машине, их внешнее поведение совершенно одинаково, так что использующие их программы избавлены от знания символьного набора.

<p>     Если требуется преобразовать несколько файлов, то можно собрать эти файлы с помощью программы, подобной утилите cat системы UNIX,
<pre> 
   cat file1 file2 ... | lower&gt;output
</pre> 
и избежать тем самым вопроса о том, как обратиться к этим файлам из программы. (Программа cat приводится позже в этой главе).

<p>     Кроме того отметим, что в стандартной библиотеке ввода/вывода "функции" getchar и putchar на самом деле могут быть макросами. Это позволяет избежать накладных расходов на обращение к функции для обработки каждого символа. В главе 8 мы продемонстрируем, как это делается.
 
<a name=73>
<h3>      7.3. Форматный вывод - функция printf</h3>
 
<p>     Две функции: printf для вывода и scanf для ввода (следующий раздел) позволяют преобразовывать численные величины в символьное представление и обратно. Они также позволяют генерировать и интерпретировать форматные строки. Мы уже всюду в предыдущих главах неформально использовали функцию printf; здесь приводится более полное и точное описание. Функция
<pre> 
  printf(control, arg1, arg2, ...)
</pre>
преобразует, определяет формат и печатает свои аргументы в стандартный вывод под управлением строки control. Управляющая строка содержит два типа объектов: обычные символы, которые просто копируются в выходной поток, и спецификации
 преобразований, каждая из которых вызывает преобразование и печать очередного аргумента printf.

<p>     Каждая спецификация преобразования начинается с символа % и заканчивается символом преобразования. Между % и символом преобразования могут находиться:
<ul>
<li>знак минус, который указывает о выравнивании преобразованного аргумента по левому краю его поля.
<li>Строка цифр, задающая минимальную ширину поля. Преобразованное число будет напечатано в поле по крайней мере этой ширины, а если необходимо, то и в более широком. Если преобразованный аргумент имеет меньше символов, чем указанная ширина поля, то он будет дополнен слева (или справа, если было указано выравнивание по левому краю)заполняющими символами до этой ширины. Заполняющим символом обычно является пробел, а если ширина поля указывается с лидирующим нулем, то этим символом будет нуль (лидирующий нуль в данном случае не означает восьмеричной ширины поля).
<li>Точка, которая отделяет ширину поля от следующей строки цифр.
<li>Строка цифр (точность), которая указывает максимальное число символов строки, которые должны быть напечатаны, или число печатаемых справа от десятичной точки цифр для переменных типа float или double.
<li>Модификатор длины l, который указывает, что соответствующий элемент данных имеет тип long, а не int.
</ul>

<p>      Ниже приводятся символы преобразования и их смысл:
<ul>
<li> d - аргумент преобразуется к десятичному виду.
<li> o - Аргумент преобразуется в беззнаковую восьмеричную форму (без лидирующего нуля).
<li> x - Аргумент преобразуется в беззнаковую шестнадцатеричную форму (без лидирующих 0X).
<li> u - Аргумент преобразуется в беззнаковую десятичную форму.
<li> c - Аргумент рассматривается как отдельный символ.
<li> s - Аргумент является строкой: символы строки печатаются до тех пор, пока не будет достигнут нулевой символ или не будет напечатано количество символов, указанное в спецификации точности.
<li> e - Аргумент, рассматриваемый как переменная типа float или double, преобразуется в десятичную форму в виде [-]m.nnnnnne[+-]xx, где длина строки из n определяется указанной точностью. Точность по умолчанию равна 6.
<li> f - Аргумент, рассматриваемый как переменная типа float или double, преобразуется в десятичную форму в виде [-]mmm.nnnnn, где длина строки из n определяется указанной точностью. Точность по умолчанию равна 6. отметим, что эта точность не определяет количество печатаемых в формате f значащих цифр.
<li> g - Используется или формат %e или %f, какой короче; незначащие нули не печатаются.
</ul>

<p>Если идущий за % символ не является символом преобразования, то печатается сам этот символ; следовательно, символ % можно напечатать, указав %%.

<p>     Большинство из форматных преобразований очевидно и было проиллюстрировано в предыдущих главах. Единственным исключением является то, как точность взаимодействует со строками. Следующая таблица демонстрирует влияние задания различных спецификаций на печать "hello, world" (12 символов). Мы поместили двоеточия вокруг каждого поля для того, чтобы вы могли видеть его протяженность.
<pre> 
   :%10s:          :hello, world:
   :%10-s:         :hello, world:
   :%20s:          :    hello, world:
   :%-20s:         :hello, world      :
   :%20.10s:       :      hello, wor:
   :%-20.10s:      :hello, wor      :
   :%.10s:         :hello, wor:
</pre> 
<p>     Предостережение: printf использует свой первый аргумент для определения числа последующих аргументов и их типов. Если количество аргументов окажется недостаточным или они будут иметь несоответственные типы, то возникнет путаница и вы получите бессмысленные результаты.

<p><b><i>     Упражнение 7-1. </i></b></p>
<p>     Напишите программу, которая будет печатать разумным образом произвольный ввод. Как минимум она должна печатать неграфические символы в восьмеричном или шестнадцатеричном виде (в соответствии с принятыми у вас обычаями) и складывать длинные строки.
 
<a name=74>
<h3>     7.4. Форматный ввод - функция scanf</h3>
<p>     Осуществляющая ввод функция scanf является аналогом printf и позволяет проводить в обратном направлении многие из тех же самых преобразований. Функция
<pre> 
   scanf(control, arg1, arg2, ...)
</pre> 
читает символы из стандартного ввода, интерпретирует их в соответствии с форматом, указанном в аргументе control, и помещает результаты в остальные аргументы. Управляющий аргумент описывается ниже; другие аргументы, каждый из которых должен быть указателем, определяют, куда следует поместить соответствующим образом преобразованный ввод.
<p>     Управляющая строка обычно содержит спецификации преобразования, которые используются для непосредственной интерпретации входных последовательностей. Управляющая строка может содержать:
<ul>
<li>пробелы, табуляции или символы новой строки ("символы пустых промежутков"), которые игнорируются.
<li>Обычные символы (не %), которые предполагаются совпадающими со следующими отличными от символов пустых промежутков символами входного потока.
<li>Спецификации преобразования, состоящие из символа %, необязательного символа подавления присваивания *, необязательного числа, задающего максимальную ширину поля и символа преобразования.
</ul>
<p>     Спецификация преобразования управляет преобразованием следующего поля ввода. нормально результат помещается в переменную, которая указывается соответствующим аргументом. Если, однако , с помощью символа * указано подавление присваивания, то это поле ввода просто пропускается и никакого присваивания не производится. Поле ввода определяется как строка символов, которые отличны от символов простых промежутков; оно продолжается либо до следующего символа пустого промежутка, либо пока не будет исчерпана ширина поля, если она указана. Отсюда следует, что при поиске нужного ей ввода, функция scanf будет пересекать границы строк, поскольку символ новой строки входит в число пустых промежутков.
<p>     Символ преобразования определяет интерпретацию поля ввода; согласно требованиям основанной на вызове по значению семантики языка C соответствующий аргумент должен быть указателем. Допускаются следующие символы преобразования:
<ul>
<li> d - на вводе ожидается десятичное целое; соответствующий аргумент должен быть указателем на целое.
<li> o - На вводе ожидается восьмеричное целое (с лидирующим нулем или без него); соответствующий аргумент должен быть указателем на целое.
<li> x - На вводе ожидается шестнадцатеричное целое (с лидирующими 0x или без них); соответствующий аргумент должен быть указателем на целое.
<li> h - На вводе ожидается целое типа short; соответствующий аргумент должен быть указателем на целое типа short.
<li> c - Ожидается отдельный символ; соответствующий аргумент должен быть указателем на символы; следующий вводимый символ помещается в указанное место. Обычный пропуск символов пустых промежутков в этом случае подавляется; для чтения следующего символа, который не является символом пустого промежутка, пользуйтесь спецификацией преобразования %1s.
<li> s - Ожидается символьная строка; соответствующий аргумент должен быть указателем символов, который указывает на массив символов, который достаточно велик для принятия строки и добавляемого в конце символа \0.
<li> f - Ожидается число с плавающей точкой; соответствующий аргумент должен быть указателем на переменную типа float.
<li>e - символ преобразования e является синонимом для f. Формат ввода переменной типа float включает необязательный знак, строку цифр, возможно содержащую десятичную точку и необязательное поле экспоненты, состоящее из буквы e, за которой следует целое, возможно имеющее знак.
</ul>
<p>     Перед символами преобразования d, o и x может стоять l, которая означает , что в списке аргументов должен находиться указатель на переменную типа long, а не типа int. Аналогично, буква l может стоять перед символами преобразования e
 или f, говоря о том, что в списке аргументов должен находиться указатель на переменную типа double, а не типа float.

<p>     Например, обращение
<pre>
 int i;
 float x;
 char name[50];
 scanf("&d %f %s", &i, &x, name);
</pre> 
со строкой на вводе
<pre> 
 25  54.32E-1   THOMPSON
</pre> 
приводит к присваиванию i значения 25,x - значения 5.432 и name - строки "THOMPSON", надлежащим образом законченной символом \ 0. эти три поля ввода можно разделить столькими пробелами, табуляциями и символами новых строк, сколько вы пожелаете. Обращение
<pre> 
  int  i;
  float x;
  char name[50];
  scanf("%2d %f %*d %2S", &i, &x, name);
</pre> 
с вводом
<pre> 
  56789 0123 45A72
</pre> 
присвоит i значение 56, x - 789.0, пропустит 0123 и поместит в name строку "45". при следующем обращении к любой процедуре ввода рассмотрение начнется с буквы a. В этих двух примерах name является указателем и, следовательно, перед ним не нужно помещать знак &.

<p>     В качестве другого примера перепишем теперь элементарный калькулятор из главы 4, используя для преобразования ввода функцию scanf:
<pre> 
   #include  &lt;stdio.h&gt;
   main()    /* rudimentary desk calculator*/
   {
   double sum, v;
   sum =0;
   whlie (scanf("%lf", &v) !=EOF)
        printf("\t%.2f\n", sum += v);
   }
</pre> 
выполнение функции scanf заканчивается либо тогда, когда она исчерпывает свою управляющую строку, либо когда некоторый элемент ввода не совпадает с управляющей спецификацией. В качестве своего значения она возвращает число правильно совпадающих и присвоенных элементов ввода. Это число может быть использовано для определения количества найденных элементов ввода. при выходе на конец файла возвращается EOF; подчеркнем, что это значение отлично от 0, что следующий вводимый символ не удовлетворяет первой спецификации в управляющей строке. При следующем обращении к scanf поиск возобновляется непосредственно за последним введенным символом.

<p>     Заключительное предостережение: аргументы функции scanf должны быть указателями. Несомненно, наиболее распространенная ошибка состоит в написании
<pre> 
  scanf("%d", n);
</pre> 
вместо
<pre> 
  scanf("%d", &n);
</pre>
     
<a name=75>
<h3>     7.5. Форматное преобразование в памяти</h3>
 
<p>     От функции scanf и printf происходят функции sscanf и sprintf, которые осуществляют аналогичные преобразования, но оперируют со строкой, а не с файлом. Обращения к этим функциям имеют вид:
<pre> 
  sprintf(string, control, arg1, arg2, ...)
  sscanf(string, control, arg1, arg2, ...)
</pre> 

<p>Как и раньше , функция sprintf преобразует свои аргументы arg1, arg2 и т.д. В соответствии с форматом, указанным в control, но помещает результаты в string, а не в стандартный вывод. Kонечно, строка string должна быть достаточно велика, чтобы принять результат. Например, если name - это символьный массив, а n - целое, то
<pre> 
 sprintf(name, "TEMP%d", n);
</pre> 
создает в name строку вида TEMPnnn, где nnn - значение n.

<p>     Функция sscanf выполняет обратные преобразования - она просматривает строку string в соответствии с форматом в аргументе control и помещает результирующие значения в аргументы arg1, arg2 и т.д.эти аргументы должны быть указателями. В результате обращения
<pre> 
 sscanf(name, "TEMP%d", &n);
</pre> 
переменная n получает значение строки цифр, следующих за TEMP в name.

<p><b><i>     Упражнение 7-2. </i></b></p>
<p>     Перепишите настольный калькулятор из главы 4, используя для ввода и преобразования чисел scanf и/или sscanf.
     
<a name=76>
<h3>     7.6. Доступ к файлам</h3>

<p>     Все до сих пор написанные программы читали из стандартного ввода и писали в стандартный вывод, относительно которых мы предполагали, что они магическим образом предоставлены программе местной операционной системой.

<p>     Следующим шагом в вопросе ввода-вывода является написание программы, работающей с файлом, который не связан заранее с программой. одной из программ, которая явно демонстрирует потребность в таких операциях, является cat, которая объединяет набор из нескольких именованных файлов в стандартный вывод. Программа cat используется для вывода файлов на терминал и в качестве универсального сборщика ввода для программ, которые не имеют возможности обращаться к файлам по имени. Например, команда
<pre> 
 cat x.c.y.c
</pre> 
печатает содержимое файлов x.c и y.c в стандартный вывод.

<p>     Вопрос состоит в том, как организовать чтение из именованных файлов, т.е., как связать внешние имена, которыми мыслит пользователь, с фактически читающими данные операторами.
 
<p>     Эти правила просты. Прежде чем можно считывать из некоторого файла или записывать в него, этот файл должен быть открыт с помощью функции fopen из стандартной библиотеки. функция fopen берет внешнее имя (подобное x.c или y.c), проводит некоторые обслуживающие действия и переговоры с операционной системой (детали которых не должны нас касаться) и возвращает внутреннее имя, которое должно использоваться при последующих чтениях из файла или записях в него.

<p>     Это внутреннее имя, называемое "указателем файла", фактически является указателем структуры, которая содержит информацию о файле, такую как место размещения буфера, текущая позиция символа в буфере, происходит ли чтение из файла или запись в него и тому подобное. Пользователи не обязаны знать эти детали, потому что среди определений для стандартного ввода-вывода, получаемых из файла stdio.h, содержится определение структуры с именем file. Единственное необходимое для указателя файла описание демонстрируется примером:
<pre>     
         file *fopen(), *fp;
</pre> 
<p>     Здесь говорится, что fp является указателем на file и fopen возвращает указатель на file. Oбратите внимание, что file является именем типа, подобным int, а не ярлыку структуры; это реализовано как typedef. (Подробности того, как все это работает на системе UNIX, приведены в главе 8).

<p>     Фактическое обращение к функции fopen в программе имеет вид:
<pre>
        fp=fopen(name,mode);
</pre>
<p>   Первым аргументом функции fopen является "имя" файла, которое задается в виде символьной строки. Второй аргумент mode ("режим") также является символьной строкой, которая указывает, как этот файл будет использоваться. Допустимыми режимами являются: чтение ("r"), запись ("w") и добавление ("a").

<p>  Если вы откроете файл, который еще не сущетвует, для записи или добавления, то такой файл будет создан (если этовозможно). Открытие существующего файла на запись приводит к отбрасыванию его старого содержимого. Попытка чтения несуществующего файла является ощибкой. Ошибки могут быть обусловлены и другими причинами (например, попыткой чтения из файла, не имея на то разрешения). При наличии какой-либо ошибки функция возвращает нулевое значение указателя NULL (которое для удобства также определяется в файле stdio.h).

<p>   Другой необходимой вещью является способ чтения или записи, если файл уже открыт. Здесь имеется несколько возможностей, из которых getc и putc являются простейшими. Функция getc возвращает следующий символ из файла; ей необходим указатель файла, чтобы знать, из какого файла читать. Таким образом,
<pre> 
             c=getc(fp)
</pre> 
помещает в 'c' следующий символ из файла, указанного посредством fp, и EOF, если достигнут конец файла.

<p>     Функция putc, являющаяся обращением к функции getc,
<pre>     
            putc(c,fp)
</pre> 
помещает символ 'c' в файл fp и возвращает 'c'. Подобно функциям getchar и putchar, getc и putc могут быть макросами, а не функциями.

<p>     При запуске программы автоматически открываются три файла, которые снабжены определенными указателями файлов. Этими файлами являются стандартный ввод, стандартный вывод и стандартный вывод ошибок; соответствующие указатели файлов называются stdin, stdout и stderr. Обычно все эти указатели связаны с терминалом, но stdin и stdout могут быть перенаправлены на файлы или в поток (pipe), как описывалось в разделе 7.2.

<p>     Функции getchar и putchar могут быть определены в терминалах getc, putc, stdin и stdout следующим образом:
<pre>
 #define getchar() getc(stdin) #define putchar(c)  putc(c,
 stdout)
</pre>
<p> При работе с файлами для форматного ввода и вывода можно использовать функции fscanf и fprintf. Они идентичны функциям scanf и printf, за исключением того, что первым аргументом является указатель файла, определяющий тот файл, который будет читаться или куда будет вестись запись; управляющая строка будет вторым аргументом.

<p>     Покончив с предварительными замечаниями, мы теперь в состоянии написать программу cat для конкатенации файлов. Используемая здесь основная схема оказывается удобной во многих программах: если имеются аргументы в командной строке, то они обрабатываются последовательно. Если такие аргументы отсутствуют, то обрабатывается стандартный ввод. Это позволяет использовать программу как самостоятельно, так и как часть большей задачи.
<pre> 
   #include &lt;stdio.h&gt;
   main(argc, argv)   /*cat: concatenate files*/
   int argc;
   char *argv[];
   {
  file *fp, *fopen();
  if(argc==1) /*no args; copy standard input*/
  filecopy(stdin);
  else
  whlie (--argc &gt; 0)
       if ((fp=fopen(*++argv,"r"))==NULL) {
          printf("cat:can't open %\n",*argv);
          break;
       } else {
          filecopy(fp);
          fclose(fp);
       }
   }
    filecopy(fp)  /*copy file fp to standard output*/
    file *fp;
    {
   int c;
   whlie ((c=getc(fp)) !=EOF)
   putc(c, stdout);
    }
</pre> 
<p> Указатели файлов stdin и stdout заранее определены в библиотеке ввода-вывода как стандартный ввод и стандартный вывод; они могут быть использованы в любом месте, где можно использовать объект типа file*.они однако являются константами, а не переменными, так что не пытайтесь им что-либо присваивать.

<p>     Функция fclose является обратной по отношению к fopen; она разрывает связь между указателем файла и внешним именем, установленную функцией fopen, и высвобождает указатель файла для другого файла. Большинство операционных систем имеют некоторые ограничения на число одновременно открытых файлов, которыми может распоряжаться программа. Поэтому, то как мы поступили в cat, освободив не нужные нам более объекты, является хорошей идеей. Имеется и другая причина для применения функции fclose к выходному файлу - она вызывает выдачу информации из буфера, в котором putc собирает вывод. (При нормальном завершении работы программы функция fclose вызывается автоматически для каждого открытого файла).
 
<a name=77>
<h3>     7.7. Обработка ошибок - stderr и exit</h3>

<p>     Обработка ошибок в cat неидеальна. Неудобство заключается в том, что если один из файлов по некоторой причине оказывается недоступным, диагностическое сообщение об этом печатается в конце объединенного вывода. Это приемлемо, если вывод поступает на терминал, но не годится, если вывод поступает в некоторый файл или через поточный (pipeline) механизм в другую программу.

<p>     Чтобы лучше обрабатывать такую ситуацию, к программе точно таким же образом, как stdin и stdout, присоединяется второй выходной файл, называемый stderr. Если это вообще возможно, вывод, записанный в файле stderr, появляется на терминале пользователя, даже если стандартный вывод направляется в другое место.

<p>     Давайте переделаем программу cat таким образом, чтобы сообщения об ошибках писались в стандартный файл ошибок.
<pre> 
    #include  &lt;stdio.h&gt;
    main(argc,argv)  /*cat: concatenate files*/
    int argc;
    char *argv[];
    {
   file *fp, *fopen();
   if(argc==1)  /*no args; copy standard input*/
   filecopy(stdin);
   else
   whlie (--argc &gt; 0)
      if((fp=fopen(*++argv,"r#))==NULL) {
      printf(stderr,
        "cat: can't open,%s\n", argv);
      exit(1);
   } else {
      filecopy(fp);
   }
   exit(0);
    }
</pre> 
<p> Программа сообщает об ошибках двумя способами. Диагностическое сообщение, выдаваемое функцией fprintf, поступает в stderr и, таким образом, оказывается на терминале пользователя, а не исчезает в потоке (pipeline) или в выходном файле.

<p>     Программа также использует функцию exit из стандартной библиотеки, обращение к которой вызывает завершение выполнения программы. Аргумент функции exit доступен любой программе, обращающейся к данной функции, так что успешное или неудачное завершение данной программы может быть проверено другой программой, использующей эту в качестве подзадачи. По соглашению величина 0 в качетсве возвращаемого значения свидетельствует о том, что все в порядке, а различные ненулевые значения являются признаками нормальных ситуаций.

<p>     Функция exit вызывает функцию fclose для каждого открытого выходного файла, с тем чтобы вывести всю помещенную в буферы выходную информацию, а затем вызывает функцию _exit. Функция _exit приводит к немедленному завершению без очистки каких-либо буферов; конечно, при желании к этой функции можно обратиться непосредственно.

<a name=78>
<h3>      7.8. Ввод и вывод строк</h3>

<p>     Стандартная библиотека содержит функцию fgets, совершенно аналогичную функции getline, которую мы использовали на всем протяжении книги. В результате обращения
<pre> 
 fgets(line, maxline, fp)
</pre> 
следующая строка ввода (включая символ новой строки) считывается из файла fp в символьный массив line; самое большое maxline-1 символ будет прочитан. Результирующая строка заканчивается символом \0. Нормально функция fgets возвращает line; в конце файла она возвращает NULL. (Наша функция getline возвращает длину строки, а при выходе на конец файла - нуль).

<p>     Предназначенная для вывода функция fputs записывает строку (которая не обязана содержать символ новой строки) в файл:
<pre> 
  fputs(line, fp)
</pre> 
<p>     Чтобы показать, что в функциях типа fgets и fputs нет ничего таинственного, мы приводим их ниже, скопированными непосредственно из стандартной библиотеки ввода-вывода:
<pre> 
    #include  &lt;stdio.h&gt;
    char *fgets(s,n,iop) /*get at most n chars from iop*/
    char *s;
    int n;
    register file *iop;
    {
   register int c;
   register char *cs;
   cs = s;
   whlie(--n&gt;0&&(c=getc(iop)) !=EOF)
   if ((*cs++ = c)=='\n')
        break;
   *cs = '\0';
   return((c==EOF && cs==s) ? NULL : s);
    }
    fputs(s,iop) /*put string s on fils iop*/
    register char *s;
    register file *iop;
    {
   register int c;
   whlie (c = *s++)
   putc(c,iop);
    }      
</pre>
<p><b><i>     Упражнение 7-3. </i></b></p>

<p>     Напишите программу сравнения двух файлов, которая будет печатать первую строку и позицию символа, где они различаются.

<p><b><i>     Упражнение 7-4. </i></b></p>

<p>     Переделайте программу поиска заданной комбинации символов из главы 5 таким образом, чтобы в качестве ввода использовался набор именованных файлов или, если никакие файлы не указаны как аргументы, стандартный ввод. Следует ли печатать имя файла при нахождении подходящей строки?

<p><b><i>     Упражнение 7-5. </i></b></p>

<p>     Напишите программу печати набора файлов, которая начинает каждый новый файл с новой страницы и печатает для каждого файла заголовок и счетчик текущих страниц.
 
<a name=79>
<h3>     7.9. Несколько разнообразных функций</h3>

<p>     Стандартная библиотека предоставляет множество разнообразных функций, некоторые из которых оказываются особенно полезными. Мы уже упоминали функции для работы со строками: strlen, strcpy, strcat и strcmp. Вот некоторые другие.
 
<a name=791>
<h4>     7.9.1. Проверка вида символов и преобразования</h4>

<p>     Некоторые макросы выполняют проверку символов и преобразования: 
<ul> 
<li>  salpa(c) - не 0, если c алфавитный символ, 0 - если нет.
<li>  supper(c) - не 0, если c буква верхнего регистра, 0 - если нет.
<li>  slower(c) - не 0, если c буква нижнего регистра, 0 - если нет.
<li>  sdigit(c) - не 0, если c цифра, 0 - если нет.
<li>  sspacl(c) - не 0, если c пробел, табуляция или новая строка, 0 - если нет.
<li>  oupper(c) - преобразует c в букву верхнего регистра.
<li>  olower(c) - преобразует c в букву нижнего регистра.
</ul>
 
<a name=792>
<h4>    7.9.2. Функция ungetc</h4>

<p>     Стандартная библиотека содержит довольно ограниченную версию функции ungetch, написанной нами в главе 4; она называется ungetc. В результате обращения
<pre> 
  ungetc(c,fp)
</pre> 
символ 'c' возвращается в файл fp. Позволяется возвращать в каждый файл только один символ. Функция ungetc может быть использована в любой из функций ввода и с макросами типа scanf, getc или getchar.
 
<a name=793>
<h4>     7.9.3. Обращение к системе</h4>

<p>     Функция system(s) выполняет команду, содержащуюся в символьной строке s, и затем возобновляет выполнение текущей программы. Содержимое s сильно зависит от используемой операционной системы. В качестве тривиального примера, укажем, что на системе UNIX строка
<pre> 
   system("date");
</pre> 
приводит к выполнению программы date, которая печатает дату и время дня.
 
<a name=794>
<h4>     7.9.4. Управление памятью</h4>

<p>     Функция calloc весьма сходна с функцией alloc, использованной нами в предыдущих главах. В результате обращения
<pre> 
   calloc(n, sizeof(object))
</pre> 
возвращается либо указатель пространства, достаточного для размещения n объектов указанного размера, либо NULL, если запрос не может быть удовлетворен. Отводимая память инициализируется нулевыми значениями.

<p>     Указатель обладает нужным для рассматриваемых объектов выравниванием, но ему следует приписывать соответствующий тип, как в
<pre>
   char *calloc();
   int *ip;
   ip=(int*) calloc(n,sizeof(int));
</pre> 
<p>     Функция cfree(p) освобождает пространство, на которое указывает "p", причем указатель "p" первоначально должен быть получен в результате обращения к calloc. Здесь нет никаких ограничений на порядок освобождения пространства, но будет неприятнейшей ошибкой освободить что-нибудь, что не было получено обращением к calloc.

<p>     Реализация программы распределения памяти, подобной calloc, в которой размещенные блоки могут освобождаться в произвольном порядке, продемонстрирована в главе 8.
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_6.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_8.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>