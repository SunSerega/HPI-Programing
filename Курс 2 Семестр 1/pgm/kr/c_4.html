<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Керниган и Ритчи </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://kulichki.rambler.ru/moshkow/  -->
<!-- Owner: Alexander S. Derevjanko (web-design only)-->
<!-- ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_3.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_5.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2>     4. Функции и структура программ.</h2>
 
<p>     Функции разбивают большие вычислительные задачи на маленькие подзадачи и позволяют использовать в работе то, что уже сделано другими, а не начинать каждый раз с пустого места. Соответствующие функции часто могут скрывать в себе детали проводимых в разных частях программы операций, знать которые нет необходимости, проясняя тем самым всю программу, как целое, и облегчая мучения при внесении изменений.
<p>     Язык C разрабатывался со стремлением сделать функции эффективными и удобными для использования; C-программы обычно состоят из большого числа маленьких функций, а не из нескольких больших. Программа может размещаться в одном или нескольких исходных файлах любым удобным образом; исходные файлы могут компилироваться отдельно и загружаться вместе наряду со скомпилированными ранее функциями из библиотек. Мы здесь не будем вдаваться в детали этого процесса, поскольку они зависят от используемой системы.
<p>     Большинство программистов хорошо знакомы с "библиотечными" функциями для ввода и вывода (getchar, putchar) и для численных расчетов (sin, cos, sqrt). В этой главе мы сообщим больше о написании новых функций.
 
<a name=41>
<h3>      4.1. Основные сведения.</h3>
 
<p>     Для начала давайте разработаем и составим программу печати каждой строки ввода, которая содержит определенную комбинацию символов. (Это - специальный случай утилиты grep системы "UNIX"). Например, при поиске комбинации "the" в наборе строк
<pre>                                                      
     now is the time
     for all good
     men to come to the aid
     of their party
</pre>
в качестве выхода получим
<pre> 
     now is the time
     men to come to the aid
     of their party
 </pre>
 
основная схема выполнения задания четко разделяется на три части:
<pre>
    while (имеется еще строка)
    if (строка содержит нужную комбинацию)
          вывод этой строки
</pre> 
<p>     Конечно, возможно запрограммировать все действия в виде одной основной процедуры, но лучше использовать естественную структуру задачи и представить каждую часть в виде отдельной функции. С тремя маленькими кусками легче иметь дело, чем с одним большим, потому что отдельные не относящиеся к существу дела детали можно включить в функции и уменьшить возможность нежелательных взаимодействий. Кроме того, эти куски могут оказаться полезными сами по себе.
 
<p>     "Пока имеется еще строка" - это getline, функция, которую мы запрограммировали в главе 1, а "вывод этой строки" - это функция printf, которую уже кто-то подготовил для нас. Это значит, что нам осталось только написать процедуру для определения, содержит ли строка данную комбинацию символов или нет. Мы можем решить эту проблему, позаимствовав разработку из PL/1: функция index(s,t) возвращает позицию, или индекс, строки s, где начинается строка t, и -1, если s не содержит t . В качестве начальной позиции мы используем 0, а не 1, потому что в языке C массивы начинаются с позиции нуль. Когда нам в дальнейшем понадобится проверять на совпадение более сложные конструкции, нам придется заменить только функцию index; остальная часть программы останется той же самой.
<p>     После того, как мы потратили столько усилий на разработку, написание программы в деталях не представляет затруднений. ниже приводится целиком вся программа, так что вы можете видеть, как соединяются вместе отдельные части. Комбинация символов, по которой производится поиск, выступает пока в качестве символьной строки в аргументе функции index, что не является самым общим механизмом. Мы скоро вернемся к обсуждению вопроса об инициализации символьных массивов и в главе 5 покажем, как сделать комбинацию символов параметром, которому присваивается значение в ходе выполнения программы. Программа также содержит новый вариант функции getline; вам может оказаться полезным сравнить его с вариантом из главы 1.
<pre> 
 #define  MAXLINE  1000
 main()  /* find all lines matching a pattern */
 {
      char line[MAXLINE];
 
      while (getline(line, MAXLINE) &gt; 0)
    if (index(line, "the") &gt;= 0)
       printf("%s", line);
  }

 getline(s, lim) /* get line into s, return length */
  char s[];
  int lim;
  {
  int c, i;
 
  i = 0;
 while(--lim&gt;0 && (c=getchar()) != EOF && c != '\n')
  s[i++] = c;
  if (c == '\n')
  s[i++] = c;
  s[i] = '\0';
  return(i);
  }
 
  index(s,t) /* return index of t in s,-1 if NonE */
  char s[], t[];
  {
      int i, j, k;
 
    for (i = 0; s[i] != '\0'; i++) {
      for(j=i, k=0; t[k] !='\0' && s[j] == t[k]; j++; k++)
     ;
     if (t[k] == '\0')
       return(i);
      }
      return(-1);
  }
</pre>    
<p> Каждая функция имеет вид имя (список аргументов, если они имеются) описания аргументов, если они имеются
<pre> 
  {
      описания и операторы , если они имеются
  }
</pre> 
 
<p>       Как и указывается, некоторые части могут отсутствовать; минимальной функцией является
 
<pre> 
     dummy ()  { }
</pre> 
которая не совершает никаких действий.
 
<p>       (Такая ничего не делающая функция иногда оказывается удобной для сохранения места для дальнейшего развития программы). Если функция возвращает что-либо отличное от целого значения, то перед ее именем может стоять указатель типа; этот вопрос обсуждается в следующем разделе.
<p>       Программой является просто набор определений отдельных
 функций. Связь между функциями осуществляется через аргументы и возвращаемые функциями значения (в этом случае); ее можно также осуществлять через внешние переменные. Функции могут располагаться в исходном файле в любом порядке, а сама исходная программа может размещаться на нескольких файлах, но так, чтобы ни одна функция не расщеплялась.
<p>       Оператор return служит механизмом для возвращения значения из вызванной функции в функцию, которая к ней обратилась. За return может следовать любое выражение:
<pre>
    return (выражение)
</pre> 
<p>       Вызывающая функция может игнорировать возвращаемое значение, если она этого пожелает. Более того, после return может не быть вообще никакого выражения; в этом случае в вызывающую программу не передается никакого значения. Управление также возвращется в вызывающую программу без передачи какого-либо значения и в том случае, когда при выполнении мы "проваливаемся" на конец функции, достигая закрывающейся правой фигурной скобки. EСли функция возвращает значение из одного места и не возвращает никакого значения из другого места, это не является незаконным, но может быть признаком каких-то неприятностей. В любом случае "значением" функции, которая не возвращает значения, несомненно будет мусор. Отладочная программа lint проверяет такие ошибки.
<p>       Механика компиляции и загрузки C-программ, расположенных в нескольких исходных файлах, меняется от системы к системе. В системе "UNIX", например, эту работу выполняет команда 'cc', упомянутая в главе 1. Предположим, что три функции находятся в трех различных файлах с именами main.с, getline.c и index.с . Тогда команда
<pre>       
    cc main.c getline.c index.c
</pre> 
компилирует эти три файла, помещает полученный настраиваемый объектный код в файлы main.o, getline.o и index.o и загружает их всех в выполняемый файл, называемый a.out .
<p>     Если имеется какая-то ошибка, скажем в main.c, то этот файл можно перекомпилировать отдельно и загрузить вместе с предыдущими объектными файлами по команде
<pre> 
    cc main.c getlin.o index.o
</pre> 
<p>     Команда 'cc' использует соглашение о наименовании с ".с" и ".о" для того, чтобы отличить исходные файлы от объектных.

<p><b><i>     Упражнение  4-1.</i></b></p>
<p>     Составьте программу для функции rindex(s,t), которая возвращает позицию самого правого вхождения т в s и -1, если s не содержит t.
 
<a name=42>
<h3>      4.2. Функции, возвращающие нецелые значения.</h3>
 
<p>     До сих пор ни одна из наших программ не содержала како-
 го-либо описания типа функции. Дело в том, что по умолчанию
 функция неявно описывается своим появлением в выражении или
 операторе, как, например, в
<pre> 
  while (getline(line, MAXLINE) &gt; 0)
</pre> 
<p>     Если некоторое имя, которое не было описано ранее, появляется в выражении и за ним следует левая круглая скобка, то оно по контексту считается именем некоторой функции. Кроме того, по умолчанию предполагается, что эта функция возвращает значение типа int. Так как в выражениях char преобразуется в int, то нет необходимости описывать функции, возвращающие char. Эти предположения покрывают большинство случаев, включая все приведенные до сих пор примеры.
<p>     Но что происходит, если функция должна возвратить значение какого-то другого типа ? Многие численные функции, такие как sqrt, sin и cos возвращают double; другие специальные функции возвращают значения других типов. Чтобы показать, как поступать в этом случае, давайте напишем и используем функцию atof(s), которая преобразует строку s в эквивалентное ей плавающее число двойной точности. Функция atof является расширением атоI, варианты которой мы написали в главах 2 и 3; она обрабатывает необязательно знак и десятичную точку, а также целую и дробную часть, каждая из которых может как присутствовать, так и отсутствовать.(Эта процедура преобразования ввода не очень высокого качества; иначе она бы заняла больше места, чем нам хотелось бы).
<p>     Во-первых, сама atof должна описывать тип возвращаемого ею значения, поскольку он отличен от int. Так как в выражениях тип float преобразуется в double, то нет никакого смысла в том, чтобы atof возвращала float; мы можем с равным успехом воспользоваться дополнительной точностью, так что мы полагаем, что возвращаемое значение типа double. Имя типа должно стоять перед именем функции, как показывается ниже:
<pre> 
 double atof(s) /* convert string s to double */
 char s[];
 {
   double val, power;
   int  i, sign;

 for(i=0; s[i]==' ' || s[i]=='\n' || s[i]=='\t'; i++)
    ;       /* skip white space */
   sign = 1;
   if (s[i] == '+' || s[i] == '-')   /* sign */
      sign = (s[i++] == '+') ? 1 : -1;
   for (val = 0; s[i] &gt;= '0' && s[i] &lt;= '9'; i++)
      val = 10 * val + s[i] - '0';
   if (s[i] == '.')
      i++;
 for (power = 1; s[i] &gt;= '0' && s[i] &lt;= '9'; i++) {
      val = 10 * val + s[i] - '0';
      power *= 10;
    }
    return(sign * val / power);
 }
</pre>     
<p>     Вторым, но столь же важным, является то, что вызывающая функция должна объявить о том, что atof возвращает значение, отличное от int типа. Такое объявление демонстрируется на примере следующего примитивного настольного калькулятора (едва пригодного для подведения баланса в чековой книжке), который считывает по одному числу на строку, причем это число может иметь знак, и складывает все числа, печатая сумму после каждого ввода.
<pre> 
 #define   MAXLINE   100
 main()  /* rudimentary desk calkulator */
 {
      double sum, atof();
      char line[MAXLINE];
 
      sum = 0;
      while (getline(line, MAXLINE) &gt; 0)
    printf("\t%.2f\n",sum+=atof(line));
</pre> 
 
Описание
<pre> 
      double  sum, atof();
</pre> 
 
говорит, что sum является переменной типа double , и что atof является функцией, возвращающей значение типа double. Эта мнемоника означает, что значениями как sum, так и atof(...) являются плавающие числа двойной точности.
<p>     Если функция atof не будет описана явно в обоих местах, то в C предполагается, что она возвращает целое значение, и вы получите бессмысленный ответ. Если сама atof и обращение к ней в main имеют несовместимые типы и находятся в одном и том же файле, то это будет обнаружено компилятором. Но если atof была скомпилирована отдельно (что более вероятно), то это несоответствие не будет зафиксировано, так что atof будет возвращать значения типа double, с которым main будет обращаться, как с int , что приведет к бессмысленным результатам. (Программа lint вылавливает эту ошибку).
<p>     Имея atof, мы, в принципе, могли бы с ее помощью написать atoi (преобразование строки в int):
<pre> 
  atoi(s)   /* convert string s to integer */
  char s[];
  {
     double atof();
 
     return(atof(s));
  }
</pre> 
 
<p> Обратите внимание на структуру описаний и оператор return. Значение выражения в
<pre> 
     return (выражение)
</pre> 
всегда преобразуется к типу функции перед выполнением самого возвращения. Поэтому при появлении в операторе return значение функции атоF, имеющее тип double, автоматически преобразуется в int, поскольку функция atoi возвращает int. (Как обсуждалось в главе 2, преобразование значения с плавающей точкой к типу int осуществляется посредством отбрасывания дробной части).

<p><b><i>     Упражнение  4-2.</i></b></p>
<p>     Расширьте atof таким образом, чтобы она могла работать с
 числами вида
<pre> 
     123.45е-6
</pre> 
где за числом с плавающей точкой может следовать 'E' и показатель экспоненты, возможно со знаком.
 
<a name=43>
<h3>     4.3. Еще об аргументах функций.</h3>
 
<p>     В главе 1 мы уже обсуждали тот факт , что аргументы функций передаются по значению, т.е. вызванная функция получает свою временную копию каждого аргумента, а не его адрес. это означает, что вызванная функция не может воздействовать на исходный аргумент в вызывающей функции. Внутри функции каждый аргумент по существу является локальной переменной, которая инициализируется тем значением, с которым к этой функции обратились.
<p>     Если в качестве аргумента функции выступает имя массива, то передается адрес начала этого массива; сами элементы не копируются. Функция может изменять элементы массива, используя индексацию и адрес начала. Таким образом, массив передается по ссылке. В главе 5 мы обсудим, как использование указателей позволяет функциям воздействовать на отличные от массивов переменные в вызывающих функциях.
<p>     Между прочим, несуществует полностью удовлетворительного
 способа написания переносимой функции с переменным числом аргументов. Дело в том, что нет переносимого способа, с помощью которого вызванная функция могла бы определить, сколько аргументов было фактически передано ей в данном обращении. Таким образом, вы, например, не можете написать действительно переносимую функцию, которая будет вычислять максимум от произвольного числа аргументов, как делают встроенные функции MAX в фортране и PL/1.
<p>     Обычно со случаем переменного числа аргументов безопасно иметь дело, если вызванная функция не использует аргументов, которые ей на самом деле не были переданы, и если типы согласуются. Самая распространенная в языке C функция с переменным числом - printf . Она получает из первого аргумента информацию, позволяющую определить количество остальных аргументов и их типы. Функция printf работает совершенно неправильно, если вызывающая функция передает ей недостаточное количество аргументов, или если их типы не согласуются с типами, указанными в первом аргументе. Эта функция не является переносимой и должна модифицироваться при использовании в различных условиях.
<p>     Если же типы аргументов известны, то конец списка аргументов можно отметить, используя какое-то соглашение; например, считая, что некоторое специальное значение аргумента (часто нуль) является признаком конца аргументов.
 
<a name=44>
<h3>      4.4. Внешние переменные.</h3>
 
<p>     Программа на языке C состоит из набора внешних объектов, которые являются либо переменными, либо функциями. Термин "внешний" используется главным образом в противопоставление термину "внутренний", которым описываются аргументы и автоматические переменные, определенные внурти функций. Внешние переменные определены вне какой-либо функции и, таким образом, потенциально доступны для многих функций. Сами функции всегда являются внешними, потому что правила языка C не разрешают определять одни функции внутри других. По умолчанию внешние переменные являются также и "глобальными", так что все ссылки на такую переменную, использующие одно и то же имя (даже из функций, скомпилированных независимо), будут ссылками на одно и то же. В этом смысле внешние переменные аналогичны переменным COMMON в Фортране и EXTERNAL в PL/1. Позднее мы покажем, как определить внешние переменные и функции таким образом, чтобы они были доступны не глобально, а только в пределах одного исходного файла.
<p>     В силу своей глобальной доступности внешние переменные предоставляют другую, отличную от аргументов и возвращаемых значений, возможность для обмена данными между функциями. Если имя внешней переменной каким-либо образом описано, то любая функция имеет доступ к этой переменной, ссылаясь к ней по этому имени.
<p>     В случаях, когда связь между функциями осуществляется с помощью большого числа переменных, внешние переменные оказываются более удобными и эффективными, чем использование длинных списков аргументов. Как, однако, отмечалось в главе 1, это соображение следует использовать с определенной осторожностью, так как оно может плохо отразиться на структуре программ и приводить к программам с большим числом связей по данным между функциями.
<p>     Вторая причина использования внешних переменных связана с инициализацией. В частности, внешние массивы могут быть инициализированы а автоматические нет. Мы рассмотрим вопрос об инициализации в конце этой главы.
<p>     Третья причина использования внешних переменных обусловлена их областью действия и временем существования. Автоматические переменные являются внутренними по отношению к функциям; они возникают при входе в функцию и исчезают при выходе из нее. Внешние переменные, напротив, существуют постоянно. Они не появляютя и не исчезают, так что могут сохранять свои значения в период от одного обращения к функции до другого. В силу этого, если две функции используют некоторые общие данные, причем ни одна из них не обращается к другой, то часто наиболее удобным оказывается хранить эти общие данные в виде внешних переменных, а не передавать их в функцию и обратно с помощью аргументов.
<p>     Давайте продолжим обсуждение этого вопроса на большом примере. Задача будет состоять в написании другой программы для калькулятора, лучшей,чем предыдущая. Здесь допускаются операции +,-,*,/ и знак = (для выдачи ответа).вместо инфиксного представления калькулятор будет использовать обратную польскую нотацию,поскольку ее несколько легче реализовать. В обратной польской нотации знак следует за операндами; инфиксное выражение типа
<pre> 
    (1-2)*(4+5)=
</pre>     
записывается в виде
<pre>
    12-45+*=
</pre>
круглые скобки при этом не нужны.
<p>     Реализация оказывается весьма простой.каждый операнд помещается в стек; когда поступает знак операции,нужное число операндов (два для бинарных операций) вынимается,к ним применяется операция и результат направляется обратно в стек.так в приведенном выше примере 1 и 2 помещаются в стек и затем заменяются их разностью, -1.после этого 4 и 5 вводятся в стек и затем заменяются своей суммой, 9. Далее числа -1 и 9 заменяются в стеке на их произведение,равное -9.операция = печатает верхний элемент стека, не удаляя его (так что промежуточные вычисления могут быть проверены).
<p>     Сами операции помещения чисел в стек и их извлечения очень просты,но, в связи с включением в настоящую программу обнаружения ошибок и восстановления,они оказываются достаточно длинными. Поэтому лучше оформить их в виде отдельных функций,чем повторять соответствующий текст повсюду в программе. Кроме того, нужна отдельная функция для выборки из ввода следующей операции или операнда. Таким образом, структура программы имеет вид:
<pre> 
 while( поступает операция или операнд, а не конец
    if ( число )
         поместить его в стек
    else if ( операция )
         вынуть операнды из стека
         выполнить операцию
         поместить результат в стек
    else
         ошибка
</pre> 
<p>     Основной вопрос, который еще не был обсужден, заключается в том,где поместить стек, т. Е. Какие процедуры смогут обращаться к нему непосредственно. Одна из таких возможностей состоит в помещении стека в main и передачи самого стека и текущей позиции в стеке функциям, работающим со стеком. Но функции main нет необходимости иметь дело с переменными, управляющими стеком; ей естественно рассуждать в терминах помещения чисел в стек и извлечения их оттуда. В силу этого мы решили сделать стек и связанную с ним информацию внешними переменными , доступными функциям push (помещение в стек) и pop (извлечение из стека), но не main.
<p>     Перевод этой схемы в программу достаточно прост. Ведущая программа является по существу большим переключателем по типу операции или операнду; это, по-видимому, более характерное применеие переключателя, чем то, которое было продемонстрировано в главе 3.
<pre>     
    #define MAXOP   20  /* max size of operand, operator */
    #define NUMBER '0'  /* signal that number found */
    #define TOOBIG '9'  /* signal that string is too big */
     
    main()  /* reverse polish desk calculator */
    {
     int tupe;
     char s[MAXOP];
     double op2,atof(),pop(),push();
 
     while ((tupe=getop(s,MAXOP)) !=EOF);
       switch(tupe) {
       case NUMBER:
            push(atof(s));
            break;
       case '+':
            push(pop()+pop());
            break;
       case '*':
            push(pop()*pop());
            break;
       case '-':
            op2=pop();
            push(pop()-op2);
            break;
       case '/':
            op2=pop();
            if (op2 != 0.0)
    push(pop()/op2);
            else
               printf("zero divisor popped\n");
            break;
       case '=':
            printf("\t%f\n",push(pop()));
            break;
       case 'c':
            clear();
            break;
       case TOOBIG:
            printf("%.2os ... is too long\n",s)
            break;
       }
    }
    #define MAXVAL 100 /* maximum depth of val stack */
    int sp = 0;        /* stack pointer */
    double val[MAXVAL]; /*value stack */
    double push(f)    /* push f onto value stack */
    double f;
    {
     if (sp &lt; MAXVAL)
             return(val[sp++] =f);
     else    {
             printf("ERROR: stack full\n");
             clear();
             return(0);
     }
    }
 
    double pop()   /* pop TOP value from stack */
    {
     if (sp &gt; 0)
             return(val[--sp]);
     else    {
             printf("ERROR: stack empty\n");
             clear();
             return(0);
     }
    }
 
    clear()       /* clear stack */
    {
      sp=0;
    }
</pre> 
<p>     Команда c очищает стек с помощью функции clear, которая также используется в случае ошибки функциями push и pop. К функции getop мы очень скоро вернемся.
<p>     Как уже говорилось в главе 1, переменная является внешней, если она определена вне тела какой бы то ни было функции. Поэтому стек и указатель стека, которые должны использоваться функциями push, pop и clear, определены вне этих трех функций. Но сама функция main не ссылается ни к стеку, ни к указателю стека - их участие тщательно замаскировано. В силу этого часть программы, соответствующая операции = , использует конструкцию
<pre>  
    push(pop());
</pre> 
 
для того, чтобы проанализировать верхний элемент стека, не изменяя его.
<p>     Отметим также, что так как операции + и * коммутативны, порядок, в котором объединяются извлеченные операнды, несущественен, но в случае операций - и / необходимо различать левый и правый операнды.
     
<p><b><i>     Упражнение 4-3.</i></b></p>
<p>     Приведенная основная схема допускает непосредственное расширение возможностей калькулятора. Включите операцию деления по модулю (%) и унарный минус. Включите команду "стереть", которая удаляет верхний элемент стека. Введите команды для работы с переменными. (Это просто, если имена переменных будут состоять из одной буквы из имеющихся двадцати шести букв).
 
<a name=45>
<h3>      4.5. Правила, определяющие область действия.</h3>
 
<p>     Функции и внешние переменные, входящие в состав C-программы, не обязаны компилироваться одновременно; программа на исходном языке может располагаться в нескольких файлах, и ранее скомпилированные процедуры могут загружаться из библиотек. Два вопроса представляют интерес:
<p>     Как следует составлять описания, чтобы переменные правильно воспринимались во время компиляции ?
<p>     Как следует составлять описания, чтобы обеспечить правильную связь частей программы при загрузке ?
 
<a name=451>
<h4>     4.5.1. Область действия.</h4>
 
<p>     Областью действия имени является та часть программы, в которой это имя определено. Для автоматической переменной, описанной в начале функции, областью действия является та функция, в которой описано имя этой переменной, а переменные из разных функций, имеющие одинаковое имя, считаются не относящимися друг к другу. Это же справедливо и для аргументов функций.
<p>     Область действия внешней переменной простирается от точки, в которой она объявлена в исходном файле, до конца этого файла. Например, если val, sp, push, pop и clear определены в одном файле в порядке, указанном выше, а именно:
<pre>
      int  sp = 0;
      double  val[MAXVAL];
      double  push(f) {...}
      double  pop()  {...}
      clear()  {...}
</pre> 
то переменные val и sp можно использовать в push, pop и clear прямо по имени; никакие дополнительные описания не нужны.
<p>     С другой стороны, если нужно сослаться на внешнюю переменную до ее определения, или если такая переменная определена в файле, отличном от того, в котором она используется, то необходимо описание extern.
<p>     Важно различать описание внешней переменной и ее определение. описание указывает свойства переменной (ее тип, размер и т.д.); определение же вызывает еще и отведение памяти. Если вне какой бы то ни было функции появляются строчки
<pre> 
    int  sp;
    double  val[MAXVAL];
</pre> 
то они определяют внешние переменные sp и val, вызывают отведение памяти для них и служат в качестве описания для остальной части этого исходного файла. В то же время строчки
<pre> 
    extern  int  sp;
    extern  double  val[];
</pre> 
описывают в остальной части этого исходного файла переменную
 sp как int, а val как массив типа double (размер которого
 указан в другом месте), но не создают переменных и не отво-
 дят им места в памяти.
<p>     Во всех файлах, составляющих исходную программу, должно содержаться только одно определение внешней переменной; другие файлы могут содержать описания extern для доступа к ней. (Описание extern может иметься и в том файле, где находится определение). Любая инициализация внешней переменной проводится только в определении. В определении должны указываться размеры массивов, а в описании extern этого можно не делать.
<p>     Хотя подобная организация приведенной выше программы и маловероятна, но val и sp могли бы быть определены и инициализированы в одном файле, а функция push, pop и clear определены в другом. В этом случае для связи были бы необходимы следующие определения и описания:
<pre> 
 в файле 1:
 ----------
 
    int sp = 0;  /* stack pointer */
    double val[MAXVAL]; /* value stack */
 
  в файле 2:
  ----------
 
     extern int sp;
     extern double val[];
     double push(f)  {...}
     double pop()   {...}
     clear()   {...}
</pre> 
 
так как описания extern 'в файле 1' находятся выше и вне трех указанных функций, они относятся ко всем ним; одного набора описаний достаточно для всего 'файла 2'.
     
<p>     Для программ большого размера обсуждаемая позже в этой главе возможность включения файлов, #include, позволяет иметь во всей программе только одну копию описаний extern и вставлять ее в каждый исходный файл во время его компиляции.
<p>     Обратимся теперь к функции getop, выбирающей из файла ввода следующую операцию или операнд. Основная задача проста: пропустить пробелы, знаки табуляции и новые строки. Если следующий символ отличен от цифры и десятичной точки, то возвратить его. В противном случае собрать строку цифр (она может включать десятичную точку) и возвратить NUMBER как сигнал о том, что выбрано число.
<p>     Процедура существенно усложняется, если стремиться правильно обрабатывать ситуацию, когда вводимое число оказывается слишком длинным. Функция getop считывает цифры подряд (возможно с десятичной точкой) и запоминает их, пока последовательность не прерывается. Если при этом не происходит переполнения, то функция возвращает NUMBER и строку цифр. Если же число оказывается слишком длинным, то getop отбрасывает остальную часть строки из файла ввода, так что пользователь может просто перепечатать эту строку с места ошибки; функция возвращает TOOBIG как сигнал о переполнении.
<pre> 
  getop(s, lim) /* get next operator or operand */
  char s[];
  int lim;
  {
    int i, c;
 
      while((c=getch())==' '|| c=='\t' || c=='\n')
     ;
    if (c != '.' && (c &lt; '0' || c &gt; '9'))
     return(c);
    s[0] = c;
    for(i=1; (c=getchar()) &gt;='0' && c &lt;= '9'; i++)
     if (i &lt; lim)
     
        s[i] = c;
   if (c == '.') {   /* collect fraction */
    if (i &lt; lim)
       s[i] = c;
   for(i++;(c=getchar()) &gt;='0' && c&lt;='9';i++)
       if (i &lt; lim)
           s[i] =c;
   }
   if (i &lt; lim)  { /* number is OK */
   ungetch(c);
   s[i] = '\0';
   return (NUMBER);
 
  } else { /* it's too big; skip rest of line */
    while (c != '\n' && c != EOF)
           c = getchar();
    s[lim-1] = '\0';
    return (TOOBIG);
   }
 }    
</pre> 
<p>     Что же представляют из себя функции 'getch' и 'ungetch'? Часто так бывает, что программа, считывающая входные данные, не может определить, что она прочла уже достаточно, пока она не прочтет слишком много. Одним из примеров является выбор символов, составляющих число: пока не появится символ, отличный от цифры, число не закончено. Но при этом программа считывает один лишний символ, символ, для которого она еще не подготовлена.
<p>     Эта проблема была бы решена, если бы было бы возможно "прочесть обратно" нежелательный символ. Тогда каждый раз, прочитав лишний символ, программа могла бы поместить его обратно в файл ввода таким образом, что остальная часть программы могла бы вести себя так, словно этот символ никогда не считывался. к счастью, такое неполучение символа легко иммитировать, написав пару действующих совместно функций. Функция getch доставляет следующий символ ввода, подлежащий рассмотрению; функция ungetch помещает символ назад во ввод, так что при следующем обращении к getch он будет возвращен.
<p>     То, как эти функции совместно работают, весьма просто. Функция ungetch помещает возвращаемые назад символы в совместно используемый буфер, являющийся символьным массивом. Функция getch читает из этого буфера, если в нем что-либо имеется; если же буфер пуст, она обращается к getchar. При этом также нужна индексирующая переменная, которая будет фиксировать позицию текущего символа в буфере.
<p>     Так как буфер и его индекс совместно используются функциями getch и ungetch и должны сохранять свои значения в период между обращениями, они должны быть внешними для обеих функций. Таким образом, мы можем написать getch, ungetch и эти переменные как:
<pre> 
  #define  bUFSIZE  100
  char buf[bUFSIZE]; /* buffer for ungetch */
  int bufp = 0; /* next free position in buf */
 
      getch() /* get a (possibly pushed (back) character */
  {
    return((bufp &gt; 0) ? buf[--bufp] : getchar());
  }
 
      ungetch(c)  /* push character back on input */
  int c;
  {
     if (bufp &gt; bUFSIZE)
   printf("ungetch: too many characters\n");
     else
   buf [bufp++] = c;
  }
</pre> 
<p> Мы использовали для хранения возвращаемых символов массив, а не отдельный символ, потому что такая общность может пригодиться в дальнейшем.
     
<p><b><i>     Упражнение  4-4.</i></b></p>
<p> Напишите функцию ungets(s) , которая будет возвращать во ввод целую строку. Должна ли ungets иметь дело с buf и bufp или она может просто использовать ungetch?

<p><b><i>     Упражнение  4-5.</i></b></p>
<p> Предположите, что может возвращаться только один символ. Измените getch и ungetch соответствующим образом.

<p><b><i>     Упражнение  4-6.</i></b></p>
<p> Наши функции getch и ungetch не обеспечивают обработку возвращенного символа EOF переносимым образом. Решите, каким свойством должны обладать эти функции, если возвращается EOF, и реализуйте ваши выводы.

<a name=46> 
<h3>      4.6. Статические переменные.</h3>
 
<p>     Статические переменные представляют собой третий класс памяти, в дополнении к автоматическим переменным и extern, с которыми мы уже встречались.
<p>     Статические переменные могут быть либо внутренними, либо внешними. Внутренние статические переменные точно так же, как и автоматические, являются локальными для некоторой функции, но, в отличие от автоматических, они остаются существовать, а не появляются и исчезают вместе с обращением к этой функции. это означает, что внутренние статические переменные обеспечивают постоянное, недоступное извне хранение внутри функции. Символьные строки, появляющиеся внутри функции, как, например, аргументы printf , являются внутренними статическими.
<p>     Внешние статические переменные определены в остальной части того исходного файла, в котором они описаны, но не в каком-либо другом файле. Таким образом, они дают способ скрывать имена, подобные buf и bufp в комбинации getch-ungetch, которые в силу их совместного использования должны быть внешними, но все же не доступными для пользователей getch и ungetch , чтобы исключалась возможность конфликта. Если эти две функции и две переменные объеденить в одном файле следующим образом
<pre> 
 static char buf[bUFSIZE]; /* buffer for ungetch */
 static int bufp=0; /*next FREE position in buf */
 
 getch()  {...}
 
 ungetch()  {...}
</pre> 
 то никакая другая функция не будет в состоянии обратиться к buf и bufp; фактически, они не будут вступать в конфликт с такими же именами из других файлов той же самой программы.
<p>     Статическая память, как внутренняя, так и внешняя, специфицируется словом static , стоящим перед обычным описанием. Переменная является внешней, если она описана вне какой бы то ни было функции, и внутренней, если она описана внутри некоторой функции.
<p>     Нормально функции являются внешними объектами; их имена известны глобально. возможно, однако, объявить функцию как static ; тогда ее имя становится неизвестным вне файла, в котором оно описано.
<p>     В языке C "static" отражает не только постоянство, но и степень того, что можно назвать "приватностью". Внутренние статические объекты определены только внутри одной функции; внешние статические объекты (переменные или функции) определены только внутри того исходного файла, где они появляются, и их имена не вступают в конфликт с такими же именами переменных и функций из других файлов.
<p>     Внешние статические переменные и функции предоставляют способ организовывать данные и работающие с ними внутренние процедуры таким образом, что другие процедуры и данные не могут прийти с ними в конфликт даже по недоразумению. Например, функции getch и ungetch образуют "модуль" для ввода и возвращения символов; buf и bufp должны быть статическими, чтобы они не были доступны извне. Точно так же функции push, pop и clear формируют модуль обработки стека; var и sp тоже должны быть внешними статическими.
 
<a name=47>
<h3>      4.7. Регистровые переменные.</h3>
 
<p>     Четвертый и последний класс памяти называется регистровым. Описание register указывает компилятору, что данная переменная будет часто использоваться. Когда это возможно, переменные, описанные как register, располагаются в машинных регистрах, что может привести к меньшим по размеру и более быстрым программам. Описание register выглядит как
<pre> 
  register int x;
  register char c;
</pre> 
и т.д.; часть int может быть опущена. Описание register можно использовать только для автоматических переменных и формальных параметров функций. В этом последнем случае описания выглядят следующим образом:
<pre> 
  f(c,n)
  register int c,n;
  {
     register int i;
     ...
  }
</pre>           
<p>     На практике возникают некоторые ограничения на регистровые переменные, отражающие реальные возможности имеющихся аппаратных средств. В регистры можно поместить только несколько переменных в каждой функции, причем только определенных типов. В случае превышения возможного числа или использования неразрешенных типов слово register игнорируется. Кроме того невозможно извлечь адрес регистровой переменной (этот вопрос обсуждается в главе 5). Эти специфические ограничения варьируются от машины к машине. Так, например, на PDP-11 эффективными являются только первые три описания register в функции, а в качестве типов допускаются int, char или указатель.
 
<a name=48>
<h3>      4.8. Блочная структура.</h3>
 
<p>     Язык C не является языком с блочной структурой в смысле PL/1 или алгола; в нем нельзя описывать одни функции внутри других.
<p>     Переменные же, с другой стороны, могут определяться по методу блочного структурирования. Описания переменных (включая инициализацию) могут следовать за левой фигурной скобкой,открывающей любой оператор, а не только за той, с которой начинается тело функции. Переменные, описанные таким образом, вытесняют любые переменные из внешних блоков, имеющие такие же имена, и остаются определенными до соответствующей правой фигурной скобки. Например в
<pre> 
 if (n &gt; 0)  {
    int i;  /* declare a new i */
    for (i = 0; i &lt; n; i++)
            ...
 }
</pre> 
<p>     Областью действия переменной i является "истинная" ветвь if; это i никак не связано ни с какими другими i в программе.
<p>     Блочная структура влияет и на область действия внешних переменных. Если даны описания
<pre> 
 int x;
 
 f()
 {
    double x;
    ...
 }
</pre> 
то появление x внутри функции f относится к внутренней переменной типа double, а вне f - к внешней целой переменной. это же справедливо в отношении имен формальных параметров:
<pre> 
 int x;
 f(x)
 double x;
 {
    ...
 }
</pre> 
<p> Внутри функции f имя x относится к формальному параметру, а не к внешней переменной.
 
<a name=49>
<h3>      4.9. Инициализация.</h3>
 
<p>     Мы до сих пор уже много раз упоминали инициализацию, но всегда мимоходом , среди других вопросов. Теперь, после того как мы обсудили различные классы памяти, мы в этом разделе просуммируем некоторые правила, относящиеся к инициализации.
<p>     Если явная инициализация отсутствует, то внешним и статическим переменным присваивается значение нуль; автоматические и регистровые переменные имеют в этом случае неопределенные значения (мусор).
<p>     Простые переменные (не массивы или структуры) можно инициализировать при их описании, добавляя вслед за именем знак равенства и константное выражение:
<pre> 
  int x = 1;
  char squote = '\'';
  long day = 60 * 24;    /* minutes in a day */
</pre> 
<p> Для внешних и статических переменных инициализация выполняется только один раз, на этапе компиляции. Автоматические и регистровые переменные инициализируются каждый раз при входе в функцию или блок.
<p> В случае автоматических и регистровых переменных инициализатор не обязан быть константой: на самом деле он может быть любым значимым выражением, которое может включать определенные ранее величины и даже обращения к функциям. Например, инициализация в программе бинарного поиска из главы 3 могла бы быть записана в виде
 
<pre> 
  binary(x, v, n)
  int x, v[], n;
  {
     int low = 0;
     int high = n - 1;
     int mid;
     ...
  }
</pre> 
вместо
<pre> 
  binary(x, v, n)
  int x, v[], n;
  {
     int low, high, mid;
 
     low = 0;
    high = n - 1;
    ...
 }
</pre> 
<p> По своему результату, инициализации автоматических переменных являются сокращенной записью операторов присваивания. Какую форму предпочесть - в основном дело вкуса. мы обычно используем явные присваивания, потому что инициализация в описаниях менее заметна.
<p> Автоматические массивы не могут быть инициализированы. Внешние и статические массивы можно инициализировать, помещая вслед за описанием заключенный в фигурные скобки список начальных значений, разделенных запятыми. Например программа подсчета символов из главы 1, которая начиналась с
<pre>     
 main()     /* count digits, white space, othres */
  (
   int c, i, nwhite, nothre;
   int ndigit[10];
   
   nwhite = nothre = 0;
   for (i = 0; i &lt; 10; i++)
      ndigit[i] = 0;
   ...
  )
</pre> 
Может быть переписана в виде
<pre> 
  int nwhite = 0;
  int nothre = 0;
  int ndigit[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    
  main()     /* count digits, white space, othres */
   (
    int c, i;
    ...
   )
</pre> 
<p> Эти инициализации фактически не нужны, так как все присваиваемые значения равны нулю, но хороший стиль - сделать их явными. Если количество начальных значений меньше, чем указанный размер массива, то остальные элементы заполняются нулями. Перечисление слишком большого числа начальных значений является ошибкой. К сожалению, не предусмотрена возможность указания, что некоторое начальное значение повторяется, и нельзя инициализировать элемент в середине массива без перечисления всех предыдущих.
<p>     Для символьных массивов существует специальный способ инициализации; вместо фигурных скобок и запятых можно использовать строку:
<pre> 
  char pattern[] = "the";
</pre> 
Это сокращение более длинной, но эквивалентной записи:
<pre> 
  char pattern[] = { 't', 'H', 'E', '\0' };
</pre> 
<p> Если размер массива любого типа опущен, то компилятор определяет его длину, подсчитывая число начальных значений. В этом конкретном случае размер равен четырем (три символа плюс конечное \0).
     
<a name=410>
<h3>      4.10. Рекурсия.</h3>
 
<p>     В языке C функции могут использоваться рекурсивно; это означает, что функция может прямо или косвенно обращаться к себе самой. Традиционным примером является печать числа в виде строки символов. как мы уже ранее отмечали, цифры генерируются не в том порядке: цифры младших разрядов появляются раньше цифр из старших разрядов, но печататься они должны в обратном порядке.
<p>     Эту проблему можно решить двумя способами. Первый способ, которым мы воспользовались в главе 3 в функции itoa, заключается в запоминании цифр в некотором массиве по мере их поступления и последующем их печатании в обратном порядке. Первый вариант функции printd следует этой схеме.
<pre> 
   printd(n)    /* print n in decimal */
   int n;
   {
     char s[10];
     int i;
    
     if (n &lt; 0) {
        putchar('-');
        n = -n;
     }
     i = 0;
     do {
        s[i++] = n % 10 + '0'; /* get next char */
     } while ((n /= 10) &gt; 0); /* DISCARD IT */
     while (--i &gt;= 0)
        putchar(s[i]);
   }
 </pre>   
 
<p>     Альтернативой этому способу является рекурсивное решение, когда при каждом вызове функция printd сначала снова обращается к себе, чтобы скопировать лидирующие цифры, а затем печатает последнюю цифру.
<pre> 
  printd(n)   /* print n in decimal (recursive)*/
  int n;
   (
    int i;
    
    if (n &lt; 0) {
       putchar('-');
       n = -n;
    }
    if ((i = n/10) != 0)
       printd(i);
    putchar(n % 10 + '0');
   )       
</pre> 
<p>     Когда функция вызывает себя рекурсивно, при каждом обращении образуется новый набор всех автоматических переменных, совершенно не зависящий от предыдущего набора. Таким образом, в printd(123) первая функция printd имеет n = 123. Она передает 12 второй printd, а когда та возвращает управление ей, печатает 3. Точно так же вторая printd передает 1 третьей (которая эту единицу печатает), а затем печатает 2.
<p>     Рекурсия обычно не дает никакой экономиии памяти, поскольку приходится где-то создавать стек для обрабатываемых значений. Не приводит она и к созданию более быстрых программ. Но рекурсивные программы более компактны, и они зачастую становятся более легкими для понимания и написания. Рекурсия особенно удобна при работе с рекурсивно определяемыми структурами данных, например, с деревьями; хороший пример будет приведен в главе 6.

<p><b><i>     Упражнение 4-7.</i></b></p>
<p>     Приспособьте идеи, использованные в printd для рекурсивного  написания itoa; т.е. Преобразуйте целое в строку с помощью рекурсивной процедуры.
 
<p><b><i>     Упражнение 4-8.</i></b></p>
<p>     Напишите рекурсивный вариант функции reverse(s), которая располагает в обратном порядке строку s.
 
<a name=411>
<h3>      4.11. Препроцессор языка C.</h3>
 
<p>     В языке "C" предусмотрены определенные расширения языка с помощью простого макропредпроцессора. одним из самых распространенных таких расширений, которое мы уже использовали, является конструкция #define; другим расширением является возможность включать во время компиляции содержимое других файлов.
 
<a name=4111>
<h4>      4.11.1. Включение файлов</h4>
 
<p>     Для облегчения работы с наборами конструкций #define и описаний (среди прочих средств) в языке "C" предусмотрена возможность включения файлов. Любая строка вида
<pre> 
    #include "filename"
</pre> 
заменяется содержимым файла с именем filename. (Кавычки обязательны). Часто одна или две строки такого вида появляются в начале каждого исходного файла, для того чтобы включить общие конструкции #define и описания extern для глобальных переменных. Допускается вложенность конструкций #include.
<p>     Конструкция #include является предпочтительным способом связи описаний в больших программах. Этот способ гарантирует, что все исходные файлы будут снабжены одинаковыми определениями и описаниями переменных, и, следовательно, исключает особенно неприятный сорт ошибок. Естественно, когда какой-to включаемый файл изменяется, все зависящие от него файлы должны быть перекомпилированы.
     
<a name=4112>
<h4>     4.11.2. Макроподстановка</h4>
 
<p>     Определение вида
<pre> 
  #define TES     1
</pre> 
приводит к макроподстановке самого простого вида - замене имени на строку символов. Имена в #define имеют ту же самую форму, что и идентификаторы в "C"; заменяющий текст совершенно произволен. Нормально заменяющим текстом является остальная часть строки; длинное определение можно продолжить, поместив \ в конец продолжаемой строки. "Область действия" имени, определенного в #define, простирается от точки определения до конца исходного файла. имена могут быть переопределены, и определения могут использовать определения, сделанные ранее. Внутри заключенных в кавычки строк подстановки не производятся, так что если, например, YES - определенное имя, то в printf("YES") не будет сделано никакой подстановки.
<p>     Так как реализация #define является частью работы макропредпроцессора, а не собственно компилятора, имеется очень мало грамматических ограничений на то, что может быть определено. Так, например, любители алгола могут объявить
<pre> 
 #define THEN
 #define bEGIN {
 #define END   ;}
</pre> 
 и затем написать
<pre> 
 if (i &gt; 0) THEN
    bEGIN
            a = 1;
            b = 2
    END
</pre> 
<p>     Имеется также возможность определения макроса с аргументами, так что заменяющий текст будет зависеть от вида обращения к макросу. Определим, например, макрос с именем MAX следующим образом:
<pre> 
 #define MAX(a, b)  ((a) &gt; (b) ? (a) : (b))
</pre> 
 когда строка
<pre> 
 x = MAX(p+q, r+s);
</pre> 
 будет заменена строкой
<pre> 
 x = ((p+q) &gt; (r+s) ? (p+q) : (r+s));
</pre> 
<p> Такая возможность обеспечивает "функцию максимума", которая расширяется в последовательный код, а не в обращение к функции. При правильном обращении с аргументами такой макрос бдет работать с любыми типами данных; здесь нет необходимости в различных видах MAX для данных разных типов, как это было бы с функциями.
<p>     Конечно, если вы тщательно рассмотрите приведенное выше расширение MAX, вы заметите определенные недостатки. Выражения вычисляются дважды; это плохо, если они влекут за собой побочные эффекты, вызванные, например, обращениями к функциям или использованием операций увеличения. Нужно позаботиться о правильном использовании круглых скобок, чтобы гарантировать сохранение требуемого порядка вычислений. (Рассмотрите макрос
<pre> 
   #define SQUARE(x)  x * x
</pre> 
при обращении к ней, как SQUARE(z+1)). Здесь возникают даже некоторые чисто лексические проблемы: между именем макро и левой круглой скобкой, открывающей список ее аргументов, не должно быть никаких пробелов.
<p>     Тем не менее аппарат макросов является весьма ценным. Один практический пример дает описываемая в главе 7 стандартная библиотека ввода-вывода, в которой getchar и putchar определены как макросы (очевидно putchar должна иметь аргумент), что позволяет избежать затрат на обращение к функции при обработке каждого символа.
<p>     Другие возможности макропроцессора описаны в приложении
 А.

<p><b><i>     Упражнение 4-9.</i></b></p>
<p>     Определите макрос SWAP(x, y), который обменивает значениями два своих аргумента типа int. (В этом случае поможет блочная структура).
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_3.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_5.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>