<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Керниган и Ритчи </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://kulichki.rambler.ru/moshkow/  -->
<!-- (C) Owner: Alexander S. Derevjanko (web-design only)-->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=index.html#index>Оглавление</a></td><td><a href=c_2.html>Вперед</a></td></tr>
</table>
</p>
<a name=l01>
<hr><h2> Введение.</h2>
<p>      Язык C является универсальным языком программирования. Он тесно связан с операционной системой UNIX, так как был развит на этой системе и так как UNIX и ее программное обеспечение написано на C. Сам язык, однако, не связан с какой-либо одной операционной системой или машиной; и хотя его называют языком системного программирования, так как он удобен для написания операционных систем, он с равным успехом использовался при написании больших вычислительных программ, программ для обработки текстов и баз данных.
<p>      Язык C - это язык относительно "низкого уровня". В такой характеристике нет ничего оскорбительного; это просто означает, что C имеет дело с объектами того же вида, что и большинство ЭВМ, а именно, с символами, числами и адресами. Они могут объединяться и пересылаться посредством обычных арифметических и логических операций, осуществляемых реальными ЭВМ.
<p>      В языке C отсутствуют операции, имеющие дело непосредственно с составными объектами, такими как строки символов, множества, списки или с массивами, рассматриваемыми как целое. Здесь, например, нет никакого аналога операциям PL/1, оперирующим с целыми массивами и строками. Язык не предоставляет никаких других возможностей распределения памяти, кроме статического определения и механизма стеков, обеспечиваемого локальными переменными функций; здесь нет ни "куч"(<samp>heap</samp>), ни "сборки мусора", как это предусматривается в АЛГОЛЕ-68. Наконец, сам по себе C не обеспечивает никаких возможностей ввода-вывода: здесь нет операторов read или write и никаких встроенных методов доступа к файлам. Все эти механизмы высокого уровня должны обеспечиваться явно вызываемыми функциями.
<p>      Аналогично, язык C предлагает только простые, последовательные конструкции потоков управления: проверки, циклы, группирование и подпрограммы, но не мультипрограммирование, параллельные операции, синхронизацию или сопрограммы.
<p>      Хотя отсутствие некоторых из этих средств может выглядеть как удручающая неполноценность ("выходит, что я должен обращаться к функции, чтобы сравнить две строки символов?!"), но удержание языка в скромных размерах дает реальные преимущества. Так как C относительно мал, он не требует много места для своего описания и может быть быстро выучен. Компилятор с C может быть простым и компактным. Кроме того, компиляторы легко пишутся; при использовании современной технологии можно ожидать написания компилятора для новой ЭВМ за пару месяцев и при этом окажется, что 80 процентов программы нового компилятора будет общей с программой для уже существующих компиляторов. Это обеспечивает высокую степень мобильности языка. Поскольку типы данных и структуры управления, имеющиеся в C, непосредственно поддерживаются большинством существующих ЭВМ, библиотека, необходимая во время прогона изолированных программ, оказывается очень маленькой. На PDP -11, например, она содержит только программы для 32-битового умножения и деления и для выполнения программ ввода и вывода последовательностей. Конечно, каждая реализация обеспечивает исчерпывающую, совместимую библиотеку функций для выполнения операций ввода-вывода, обработки строк и распределения памяти, но так как обращение к ним осуществляется только явно, можно, если необходимо, избежать их вызова; эти функции могут быть компактно написаны на самом C.
<p>      Опять же из-за того, что язык C отражает возможности современных компьютеров, программы на C оказываются достаточно эффективными, так что не возникает побуждения писать вместо этого программы на языке ассемблера. Наиболее убедительным примером этого является сама операционная система UNIX, которая почти полностью написана на C. Из 13000 строк программы системы только около 800 строк самого низкого уровня написаны на ассемблере. Кроме того, по существу все прикладное программное обеспечение системы UNIX написано на C; подавляющее большинство пользователей системы UNIX (включая одного из авторов этой книги) даже не знает языка ассемблера PDP-11.
<p>      Хотя C соответствует возможностям многих ЭВМ, он не зависит от какой-либо конкретной архитектуры машины и в силу этого без особых усилий позволяет писать "переносимые" программы, т.е. программы, которые можно пропускать без изменений на различных аппаратных средствах. В наших кругах стал уже традицией перенос программного обеспечения, разработанного на системе UNIX, на системы ЭВМ: HONEYWELL, IBM и INTERDATA. Фактически компиляторы с C и программное обеспечение во время прогона программ на этих четырех системах, по-видимому, гораздо более совместимы, чем стандартные версии Фортрана американского национального института стандартов (ANSI). Сама операционная система UNIX теперь работает как на PDP-11, так и на INTERDATA 8/32. За исключением программ, которые неизбежно оказываются в некоторой степени машинно-зависимыми, таких как компилятор, ассемблер и отладчик. Написанное на языке C программное обеспечение идентично на обеих машинах. Внутри самой операционной системы 7000 строк программы, исключая математическое обеспечение языка ассемблера ЭВМ и управления операциями ввода-вывода, совпадают на 95 процентов.
<p>      Программистам, знакомым с другими языками, для сравнения и противопоставления может оказаться полезным упоминание нескольких исторических, технических и философских аспектов C.
<p>      Многие из наиболее важных идей C происходят от гораздо более старого, но все еще вполне жизненного языка BCPL, разработанного Мартином Ричардсом. Косвенно язык BCPL оказал влияние на C через язык B, написанный Кеном Томпсоном в 1970 году для первой операционной системы UNIX на ЭВМ PDP-7.
<p>      Хотя язык C имеет несколько общих с BCPL характерных особенностей, он никоим образом не является диалектом последнего. И BCPL и B - "безтипные" языки; единственным видом данных для них являются машинное слово, а доступ к другим объектам реализуется специальными операторами или обращением к функциям. В языке C объектами основных типов данных являются символы, целые числа нескольких размеров и числа с плавающей точкой. Кроме того, имеется иерархия производных типов данных, создаваемых указателями, массивами, структурами, объединениями и функциями.
<p>      Язык C включает основные конструкции потока управления, требуемые для хорошо структурированных программ: группирование операторов, принятие решений (<samp>if</samp>), циклы с проверкой завершения в начале (<samp>while, for</samp>) или в конце (<samp>do</samp>) и выбор одного из множества возможных вариантов (<samp>switch</samp>). (Все эти возможности обеспечивались и в BCPL, хотя и при несколько отличном синтаксисе; этот язык предчувствовал наступившую через несколько лет моду на структурное программирование). 
<p>      В языке C имеются указатели и возможность адресной арифметики. Аргументы передаются функциям посредством копирования значения аргумента, и вызванная функция не может изменить фактический аргумент в вызывающей программе. Если желательно добиться "вызова по ссылке", можно неявно передать указатель, и функция сможет изменить объект, на который этот указатель указывает. Имена массивов передаются указанием начала массивов, так что аргументы типа массивов эффективно вызываются по ссылке.
<p>      К любой функции можно обращаться рекурсивно, и ее локальные переменные обычно "автоматические", т.е. Создаются заново при каждом обращении. Описание одной функции не может содержаться внутри другой, но переменные могут описываться в соответствии с обычной блочной структурой. Функции в C-программе могут транслироваться отдельно. переменные по отношению к функции могут быть внутренними, внешними, но известными только в пределах одного исходного файла, или полностью глобальными. Внутренние переменные могут быть автоматическими или статическими. Автоматические переменные для большей эффективности можно помещать в регистры, но объявление регистра является только указанием для компилятора и никак не связано с конкретными машинными регистрами.
<p>      Язык C не является языком со строгими типами в смысле Паскаля или Алгола-68. Он сравнительно снисходителен к преобразованию данных, хотя и не будет автоматически преобразовывать типы данных с буйной непринужденностью языка PL/1. Существующие компиляторы не предусматривают никакой проверки во время выполнения программы индексов массивов, типов аргументов и т.д.
<p>      В тех ситуациях, когда желательна строгая проверка типов, используется специальная версия компилятора. Эта программа называется <samp>lint</samp> очевидно потому, она выбирает кусочки пуха из вашей программы. Программа <samp>lint</samp> не генерирует машинного кода, а делает очень строгую проверку всех тех сторон программы, которые можно проконтролировать во время компиляции и загрузки. Она определяет несоответствие типов, несовместимость аргументов, неиспользованные или очевидным образом неинициализированные переменные, потенциальные трудности переносимости и т.д. Для программ, которые благополучно проходят через <samp>lint</samp>, гарантируется отсутствие ошибок типа примерно с той же полнотой, как и для программ, написанных, например, на АЛГОЛЕ-68. Другие возможности программы <samp>lint</samp> будут отмечены, когда представится соответствующий случай.
<p>      Наконец, язык C, подобно любому другому языку, имеет свои недостатки. Некоторые операции имеют неудачное старшинство; некоторые разделы синтаксиса могли бы быть лучше; существует несколько версий языка, отличающихся небольшими деталями. Тем не менее язык C зарекомендовал себя как исключительно эффективный и выразительный язык для широкого разнообразия применений программирования.
<p>      Содержание книги организовано следующим образом. Глава 1 является учебным введением в центральную часть языка C. Цель - позволить читателю стартовать так быстро, как только возможно, так как мы твердо убеждены, что единственный способ изучить новый язык - писать на нем программы. При этом, однако, предполагается рабочее владение основными элементами программирования; здесь не объясняется, что такое ЭВМ или компилятор, не поясняется смысл выражений типа <samp>n=n+1</samp>. Хотя мы и пытались, где это возможно, продемонстрировать полезную технику программирования. Эта книга не предназначается быть справочным руководством по структурам данных и алгоритмам; там, где мы вынуждены были сделать выбор, мы концентрировались на языке.
<p>      В главах со 2-й по 6-ю различные аспекты C излагаются более детально и несколько более формально, чем в главе 1, хотя ударение по-прежнему делается на разборе примеров законченных, полезных программ, а не на отдельных фрагментах.
<p>      В главе 2 обсуждаются основные типы данных, операторы и выражения. 
<p>В главе 3 рассматриваются управляющие операторы: <samp>if-else, while, for</samp> и т.д. <p>Глава 4 охватывает функции и структуру программы - внешние переменные, правила определенных областей действия описания и т.д. 
<p>В главе 5 обсуждаются указатели и адресная арифметика. 
<p>Глава 6 содержит подробное описание структур и объединений.
<p>      В главе 7 описывается стандартная библиотека ввода-вывода языка C, которая обеспечивает стандартный интерфейс с операционной системой. Эта библиотека ввода-вывода поддерживается на всех машинах, на которых реализован C, так что программы, использующие ее для ввода, вывода и других системных функций, могут переноситься с одной системы на другую по существу без изменений.
<p>      В главе 8 описывается интерфейс между C - программами и операционной системой UNIX. Упор делается на ввод-вывод, систему файлов и переносимость. Хотя некоторые части этой главы специфичны для операционной системы UNIX, программисты, не использующие UNIX, все же должны найти здесь полезный материал, в том числе некоторое представление о том, как реализована одна версия стандартной библиотеки и предложения для достижения переносимости программы.
<p>      Приложение A содержит справочное руководство по языку C. Оно является "официальным" изложением синтаксиса и семантики C и (исключая чей-либо собственный компилятор) окончательным арбитром для всех двусмысленностей и упущений в предыдущих главах.
<p>      Так как C является развивающимся языком, реализованным на множестве систем, часть материла настоящей книги может не соответствовать текущему состоянию разработки на какой-то конкретной системе. Мы старались избегать таких проблем и предостерегать о возможных трудностях. В сомнительных случаях, однако, мы обычно предпочитали описывать ситуацию для системы UNIX PDP-11, так как она является средой для большинства программирующих на языке C. В приложении а также описаны расхождения в реализациях языка C на основных системах.

<a name=l1>
<h2>      1. Учебное введение.</h2>
<p>      Давайте начнем с быстрого введения в язык C. Наша цель - продемонстрировать существенные элементы языка на реальных программах, не увязая при этом в деталях, формальных правилах и исключениях. В этой главе мы не пытаемся изложить язык полностью или хотя бы строго (разумеется, приводимые
 примеры будут корректными). Мы хотим как можно скорее довести вас до такого уровня, на котором вы были бы в состоянии писать полезные программы, и чтобы добиться этого, мы сосредотачиваемся на основном: переменных и константах, арифметике, операторах передачи управления, функциях и элементарных сведениях о вводе и выводе. Мы совершенно намеренно оставляем за пределами этой главы многие элементы языка C, которые имеют первостепенное значение при написании больших
 программ, в том числе указатели, структуры, большую часть из богатого набора операторов языка C, несколько операторов передачи управления и несметное количество деталей.
<p>      Такой подход имеет, конечно, свои недостатки. Самым существенным является то, что полное описание любого конкретного элемента языка не излагается в одном месте, а пояснения, в силу краткости, могут привести к неправильному истолкованию. Кроме того, из-за невозможности использовать всю мощь языка, примеры оказываются не столь краткими и элегантными, как они могли бы быть. И хотя мы старались свести эти недостатки к минимуму, все же имейте их в виду.
<p>      Другой недостаток состоит в том, что последующие главы
 будут неизбежно повторять некоторые части этой главы. Мы надеемся, что такое повторение будет скорее помогать, чем раздражать.
<p>      Во всяком случае, опытные программисты должны оказаться в состоянии экстраполировать материал данной главы на свои собственные программистские нужды. Начинающие же должны в дополнение писать аналогичные маленькие самостоятельные программы. И те, и другие могут использовать эту главу как каркас, на который будут навешиваться более подробные описания, начинающиеся с главы 2.

<a name=l11>
<h3>      1.1. Hачинаем. </h3>
<p>Единственный способ освоить новый язык программирования - писать на нем программы. Первая программа, которая должна быть написана, - одна для всех языков: напечатать слова: hello, world.
<p>      Это - самый существенный барьер; чтобы преодолеть его, вы должны суметь завести где-то текст программы, успешно его скомпилировать, загрузить, прогнать и найти, где оказалась ваша выдача. Если вы научились справляться с этими техническими деталями, все остальное сравнительно просто.
<p>      Программа печати "hello, world" на языке C имеет вид:
<pre>
    main ()
    {
            printf("hello, world\n");
    }
</pre>                    
<p>      Как пропустить эту программу - зависит от используемой вами системы. В частности, на операционной системе UNIX вы должны завести исходную программу в файле, имя которого оканчивается на ".C", например, <samp>hello.c</samp>, и затем скомпилировать ее по команде
 <pre>     
            cc hello.c
</pre>      
<p>      Если вы не допустили какой-либо небрежности, такой как пропуск символа или неправильное написание, компиляция пройдет без сообщений и будет создан исполняемый файл с именем <samp>а.out</samp>. Прогон его по команде
<pre>      
               a.out
</pre>      
приведет к выводу
<pre>      
           hello, world
</pre>      
<p>      На других системах эти правила будут иными; проконсультируйтесь с местным авторитетом.

<p><b><i>      Упражнение 1-1.</i></b></p> 
<p>      Пропустите эту программу на вашей системе. Попробуйте не включать различные части программы и посмотрите какие сообщения об ошибках вы при этом получите.
<p>      Теперь некоторые пояснения к самой программе. Любая C-программа, каков бы ни был ее размер, состоит из одной или более "функций", указывающих фактические операции компьютера, которые должны быть выполнены. Функции в языке C подобны функциям и подпрограммам FORTRAN и процедурам PL/1, PASCAL и т.д. В нашем примере такой функцией является <samp>main</samp>. Обычно вы можете давать функциям любые имена по вашему усмотрению, но <samp>main</samp> - это особое имя; выполнение вашей программы начинается сначала с функции <samp>main</samp>. Это означает, что каждая программа должна в каком-то месте содержать функцию с именем <samp>main</samp>. Для выполнения определенных действий функция <samp>main</samp> обычно обращается к другим функциям, часть из которых находится в той же самой программе, а часть - в библиотеках, содержащих ранее написанные функции.
<p>      Одним способом обмена данными между функциями является передача посредством аргументов. Круглые скобки, следующие за именем функции, заключают в себе список аргументов; здесь <samp>маin</samp> - функция без аргументов, что указывается как (). Операторы, составляющие функцию, заключаются в фигурные скобки { и }, которые аналогичны <samp>do-end</samp> в PL/1 или <samp>BEGIN-END</samp> в Алголе, Паскале и т.д. Обращение к функции осуществляется указанием ее имени, за которым следует заключенный в круглые скобки список аргументов. Здесь нет никаких операторов <samp>CALL</samp>, как в Фортране или PL/1. Круглые скобки должны присутствовать и в том случае, когда функция не имеет аргументов.
<p> Строка
<pre>      
      printf("hello, world\n");
</pre>      
является обращением к функции, которое вызывает функцию с именем <samp>printf</samp> и аргументом "hello, world\n". Функция <samp>printf</samp> является библиотечной функцией, которая выдает выходные данные на терминал (если только не указано какое-то другое место назначения). В данном случае печатается строка символов, являющаяся аргументом функции.
<p>      Последовательность из любого количества символов, заключенных в удвоенные кавычки "...", называется 'символьной строкой' или 'строчной константой'. Пока мы будем использовать символьные строки только в качестве аргументов для printf и других функций.
<p>      Последовательность <samp>\n</samp> в приведенной строке является обозначением на языке C для 'символа новой строки', который служит указанием для перехода на терминале к левому краю следующей строки. Если вы не включите <samp>\n</samp> (полезный эксперимент), то обнаружите, что ваша выдача не закончится переходом терминала на новую строку. Использование последовательности <samp>\n</samp> - единственный способ введения символа новой строки в аргумент функции <samp>printf</samp>; если вы попробуете что-нибудь вроде
<pre>      
          printf("hello, world
          ");
</pre>      
то C-компилятор  будет печатать злорадные диагностические сообщения о недостающих кавычках.
<p>      Функция <samp>printf</samp> не обеспечивает автоматического перехода на новую строку, так что многократное обращение к ней можно использовать для поэтапной сборки выходной строки. Наша первая программа, печатающая идентичную выдачу, с точно таким же успехом могла бы быть написана в виде
<pre>      
     main()
     {
             printf("hello, ");
             printf("world");
             printf("\n");
     }
</pre>    
<p>      Подчеркнем, что <samp>\n</samp> представляет только один символ. Условные 'последовательности', подобные <samp>\n</samp>, дают общий и допускающий расширение механизм для представления трудных для печати или невидимых символов. Среди прочих символов в языке C предусмотрены следующие: <samp>\t</samp> - для табуляции, <samp>\b</samp> - для возврата на одну позицию, <samp>\"</samp> - для двойной кавычки и <samp>\\</samp> для самой обратной косой черты.

<p><b><i>      Упражнение 1-2.</i></b></p>
<p>     Проведите эксперименты для того, чтобы узнать что произойдет, если в строке, являющейся аргументом функции <samp>printf</samp> будет содержаться <samp>\x</samp>, где <samp>x</samp> - некоторый символ, не входящий в вышеприведенный список.

<a name=l12>
<h3>     1.2. Переменные и арифметика.</h3>
<p>      Следующая программа печатает приведенную ниже таблицу температур по Фаренгейту и их эквивалентов по стоградусной шкале Цельсия, используя для перевода формулу
<pre>      
          c = (5/9)*(f-32).
     0       -17.8
    20        -6.7
    40         4.4
    60        15.6
   ...         ...
   260       126.7
   280       137.8
   300       140.9
</pre>      
<p>       Теперь сама программа:
<pre>      
    /* print Fahrenheit-celsius table for f = 0, 20, ..., 300 */
    main()
    {
    int lower, upper, step;
    float fahr, celsius;
    lower = 0;  /* lower limit of temperature table */
    upper =300; /* upper limit */
    step  = 20; /* step size */
    fahr = lower;
    while (fahr <= upper) {
      celsius = (5.0/9.0) * (fahr -32.0);
      printf("%4.0f %6.1f\n", fahr, celsius);
      fahr = fahr + step;
    }
    }
</pre>    
<p>Первые две строки
<pre>      
      /* print fahrenheit-celsius table
         for  f = 0, 20, ..., 300 */
</pre>      
являются комментарием, который в данном случае кратко поясняет, что делает программа. Любые символы между /* и */ игнорируются компилятором; можно свободно пользоваться комментариями для облегчения понимания программы. Комментарии могут появляться в любом месте, где возможен пробел или переход на новую строку.
<p>     В языке C все переменные должны быть описаны до их использования, обычно это делается в начале функции до первого выполняемого оператора. Если вы забудете вставить описание, то получите диагностическое сообщение от компилятора. Описание состоит из типа и списка переменных, имеющих этот тип, как в
<pre>     
     int lower, upper, step;
     float fahr, celsius;
</pre>     
<p>     Тип <samp>int</samp> означает, что все переменные списка целые; тип <samp>float</samp> предназначен для чисел с плавающей точкой, т.е. для чисел, которые могут иметь дробную часть. Точность как <samp>int</samp>, так и <samp>float</samp> зависит от конкретной машины, на которой вы работаете. На PDP-11, например, тип <samp>int</samp> соответствует 16-битовому числу со знаком, т.е. числу, лежащему между -32768 и +32767. Число типа <samp>float</samp> - это 32-битовое число, имеющее около семи значащих цифр и лежащее в диапазоне от 10е-38 до 10е+38. В главе 2 приводится список размеров для других машин.
<p>     В языке C предусмотрено несколько других основных типов данных, кроме <samp>int</samp> и <samp>float</samp>:<br>
 <samp>char</samp>    символ - один байт;<br>
 <samp>short</samp>   короткое целое;<br>
 <samp>long</samp>    длинное целое;<br>
 <samp>double</samp>  плавающее с двойной точностью</p>
<p>     Размеры этих объектов тоже машинно-независимы; детали приведены в главе 2. Имеются также массивы, структуры и объединения этих основных типов, указатели на них и функции, которые их возвращают; со всеми ними мы встретимся в свое время.
<p>     Фактически вычисления в программе перевода температур начинаются с операторов присваивания
<pre>
    lower = 0;
    upper =300;
    step = 20;
    fahr =lower;
</pre>
которые придают переменным их начальные значения. каждый отдельный оператор заканчивается точкой с запятой.
<p>     Каждая строка таблицы вычисляется одинаковым образом, так что мы используем цикл, повторяющийся один раз на строку. В этом назначение оператора <samp>while</samp>:
<pre>     
    while (fahr <= upper) {
 
    }         
</pre>
проверяется условие в круглых скобках. Если оно истинно (<samp>fahr</samp> меньше или равно <samp>upper</samp>), то выполняется тело цикла (все операторы, заключенные в фигурные скобки { и } ). Затем вновь проверяется это условие и, если оно истинно, опять выполняется тело цикла. Если же условие не выполняется (<samp>fahr</samp> превосходит <samp>upper</samp>), цикл заканчивается и происходит переход к выполнению оператора, следующего за оператором цикла. Так как в настоящей программе нет никаких последующих операторов, то выполнение программы завершается.
<p>     Тело оператора <samp>while</samp> может состоять из одного или более операторов, заключенных в фигурные скобки, как в программе перевода температур, или из одного оператора без скобок, как, например, в
<pre>     
     while (i < j)
           i = 2 * i;
</pre>     
<p>     В обоих случаях операторы, управляемые оператором <samp>while</samp>, сдвинуты на одну табуляцию, чтобы вы могли с первого взгляда видеть, какие операторы находятся внутри цикла. Такой сдвиг подчеркивает логическую структуру программы. Хотя в языке C допускается совершенно произвольное расположение операторов в строке, подходящий сдвиг и использование пробелов значительно облегчают чтение программ. Мы рекомендуем писать только один оператор на строке и (обычно) оставлять пробелы вокруг операторов. Расположение фигурных скобок менее существенно; мы выбрали один из нескольких популярных стилей. Выберите подходящий для вас стиль и затем используйте его последовательно.
<p>     Основная часть работы выполняется в теле цикла. Температура по Цельсию вычисляется и присваивается переменной <samp>celsius</samp> оператором
<pre>     
      celsius = (5.0/9.0) * (fahr-32.0);
</pre>     
причина использования выражения 5.0/9.0 вместо выглядящего проще 5/9 заключается в том, что в языке C, как и во многих других языках, при делении целых происходит усечение, состоящее в отбрасывании дробной части результата. Таким образом, результат операции 5/9 равен нулю, и, конечно, в этом случае все температуры оказались бы равными нулю. Десятичная точка в константе указывает, что она имеет тип с плавающей точкой, так что, как мы и хотели, 5.0/9.0 равно 0.5555... .
<p>     Мы также писали 32.0 вместо 32, несмотря на то, что так как переменная <samp>fahr</samp> имеет тип <samp>float</samp>, целое 32 автоматически бы преобразовалось к типу <samp>float</samp> ( в 32.0) перед вычитанием. С точки зрения стиля разумно писать плавающие константы с явной десятичной точкой даже тогда, когда они имеют целые значения; это подчеркивает их плавающую природу для просматривающего программу и обеспечиивает то, что компилятор буде смотреть на вещи так же, как и Вы.
<p>     Подробные правила о том, в каком случае целые преобразуются к типу с плаваюшей точкой, приведены в главе 2. Сейчас же отметим, что присваивание
<pre>     
            fahr = lower;
</pre>     
 проверка
<pre>     
            while (fahr <= upper)
</pre>     
работают, как ожидается, - перед выполнением операций целые преобразуются в плавающую форму.
<p>     Этот же пример сообщает чуть больше о том, как работает <samp>printf</samp>. Функция <samp>printf</samp> фактически является универсальной функцией форматных преобразований, которая будет полностью описана в главе 7. Ее первым аргументом является строка символов, которая должна быть напечатана, причем каждый знак % указывает, куда должен подставляться каждый из остальных аргументов (второй, третий, ...) и в какой форме он должен печататься. Например, в операторе
<pre>     
   printf("%4.0f %6.1f\n", fahr, celsius);
</pre>     
спецификация преобразования <samp>%4.0f</samp> говорит, что число с плавающей точкой должно быть напечатано в поле шириной по крайней мере в четыре символа без цифр после десятичной точки. спецификация <samp>%6.1f</samp> описывает другое число, которое должно занимать по крайней мере шесть позиций с одной цифрой после десятичной точки, аналогично спецификациям <samp>F6.1</samp> в Фортране или <samp>F(6,1)</samp> в PL/1. Различные части спецификации могут быть опущены: спецификация <samp>%6f</samp> говорит, что число будет шириной по крайней мере в шесть символов; спецификация <samp>%.2</samp> требует двух позиций после десятичной точки, но ширина при этом не ограничивается; спецификация <samp>%f</samp> говорит только о том, что нужно напечатать число с плавающей точкой. Функция <samp>printf</samp> также распознает следующие спецификации: <samp>%d</samp> - для десятичного целого, <samp>%о</samp> - для восьмеричного числа, <samp>%х</samp> - для шестнадцатиричного, <samp>%с</samp> - для символа, <samp>%s</samp> - для символьной строки и <samp>%%</samp> - для самого символа %.
<p>     Каждая конструкция с символом % в первом аргументе функции printf сочетается с соответствующим вторым, третьим, и т.д. Аргументами; они должны согласовываться по числу и типу; в противномслучае вы получите бессмысленные результаты.
<p>     Между прочим, функция <samp>printf</samp> не является частью языка C; в самом языке C не определены операции ввода-вывода. Нет ничего таинственного и в функции <samp>printf</samp>; это - просто полезная функция, являющаяся частью стандартной библиотеки подпрограмм, которая обычно доступна C-программам. Чтобы сосредоточиться на самом языке, мы не будем подробно останавливаться на операциях ввода-вывода до главы 7. В частности, мы до тех пор отложим форматныйввод. Если вам надо ввести числа - прочитайте описание функции <samp>scanf</samp> в главе 7, раздел 7.4. Функция <samp>scanf</samp> во многом сходна с <samp>printf</samp>, но она считывает входные данные, а не печатает выходные.
     
<p><b><i>      Упражнение  1-3. </i></b></p>
<p>     Преобразуйте программу перевода температур таким образом, чтобы она печатала заголовок к таблице.

<p><b><i>      Упражнение  1-4.</i> </b></p>
<p>     Напишите программы печати соответствующей таблицы перехода от градусов Цельсия к градусам Фаренгейта.
     
<a name=l13>
<h3>     1.3. Оператор <samp>for</samp>.</h3>
<p>     Как и можно было ожидать, имеется множество различных способов написания каждой программы. Давайте рассмотрим такой вариант программы перевода температур:
<pre>     
 main()  /* fahrenheit-celsius table */
 {
    int fahr;
    for (fahr = 0; fahr <= 300; fahr = fahr + 20)
  printf("%4d %6.1f\n", fahr, (5.0/9.0)*(fahr-32.0));
 }
</pre>     
<p>     Эта программа выдает те же самые результаты, но выглядит безусловно по-другому. Главное изменение - исключение большинства переменных; осталась только переменная <samp>fahr</samp>, причем типа <samp>int</samp> (это сделано для того, чтобы продемонстрировать преобразование <samp>%d</samp> в функции <samp>printf</samp>). Нижняя и верхняя границы и размер шага появляются только как константы в операторе <samp>for</samp>, который сам является новой конструкцией, а выражение, вычисляющее температуру по Цельсию, входит теперь в виде третьего аргумента функции <samp>printf</samp>, а не в виде отдельного оператора присваивания.
<p>     Последнее изменение является примером вполне общего правила языка C - в любом контексте, в котором допускается использование значения переменной некоторого типа, вы можете использовать выражение этого типа. Так как третий аргумент функции <samp>printf</samp> должен иметь значение с плавающей точкой, чтобы соответствовать спецификации <samp>%6.1f</samp>, то в этом месте может встретиться любое выражение плавающего типа.
<p>     Сам оператор <samp>for</samp> - это оператор цикла, обобщающий оператор <samp>while</samp>. Его функционирование должно стать ясным, если вы сравните его с ранее описанным оператором <samp>while</samp>. Оператор <samp>for</samp> содержит три части, разделяемые точкой с запятой. Первая часть
<pre> 
 fahr = 0
</pre> 
выполняется один раз перед входом в сам цикл. Вторая часть - проверка, или условие, которое управляет циклом:
<pre> 
 fahr <= 300
</pre> 
это условие проверяется и, если оно истинно, то выполняется тело цикла (в данном случае только функция <samp>printf</samp>). Затем выполняется шаг реинициализации
<pre> 
 fahr =fahr + 20
</pre> 
и условие проверяется снова. цикл завершается, когда это условие становится ложным. Так же, как и в случае оператора <samp>while</samp>, тело цикла может состоять из одного оператора или из группы операторов, заключенных в фигурные скобки. Инициализирующая и реинициализирующая части могут быть любыми отдельными выражениями.
<p>     Выбор между операторами <samp>while</samp> и <samp>for</samp> произволен и основы вается на том, что выглядит яснее. Оператор <samp>for</samp> обычно удобен для циклов, в которых инициализация и реинициализация логически связаны и каждая задается одним оператором, так как в этом случае запись более компактна, чем при использовании оператора <samp>while</samp>, а операторы управления циклом сосредотачиваются вместе в одном месте.

<p><b><i>     Упражнение  1-5.</i></b></p>
<p>     Модифицируйте программу перевода температур таким образом, чтобы она печатала таблицу в обратном порядке, т.е. От 300 градусов до 0.

<a name=l14>
<h3>     1.4. Символические константы.</h3>
<p>     Последнее замечание, прежде чем мы навсегда оставим программу перевода температур. Прятать "магические числа", такие как 300 и 20, внутрь программы - это неудачная практика; они дают мало информации тем, кто, возможно, должен будет разбираться в этой программе позднее, и их трудно изменять систематическим образом. К счастью в языке C предусмотрен способ, позволяющий избежать таких "магических чисел". Используя конструкцию <samp>#define</samp>, вы можете в начале программы определить символическое имя или символическую константу, которая будет конкретной строкой символов. Впоследствии компилятор заменит все не заключенные в кавычки появления этого имени на соответствующую строку. Фактически это имя может быть заменено абсолютно произвольным текстом, не обязательно цифрами
<pre> 
  #define  lower 0  /* lower limit OF table */
  #define  upper 300  /* upper limit */
  #define  step  20  /* step size */
  main () /* fahrenheit-celsius table */
  {
  int fahr;
 for (fahr =lower; fahr <= upper; fahr =fahr + step)
   printf("%4d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
  }
</pre> 
 
<p>Величины <samp>lower</samp>, <samp>upper</samp> и <samp>step</samp> являются константами и поэтому они не указываются в описаниях. Символические имена обычно пишут прописными буквами, чтобы их было легко отличить от написанных строчными буквами имен переменных. Отметим, что в конце определения не ставится точка с запятой. Так как подставляется вся строка, следующая за определенным именем, то это привело бы к слишком большому числу точек с запятой в операторе <samp>for</samp>.
     
<a name=l15>
<h3>     1.5. Набор полезных программ.</h3>
     
<p>     Теперь мы собираемся рассмотреть семейство родственных программ, предназначенных для выполнения простых операций над символьными данными. В дальнейшем вы обнаружите, что многие программы являются просто расширенными версиями тех прототипов, которые мы здесь обсуждаем.
     
<a name=l151>
<h4>     1.5.1. Ввод и вывод символов.</h4>
     
<p>     Стандартная библиотека включает функции для чтения и записи по одному символу за один раз. функция <samp>getchar()</samp> извлекает следующий вводимый символ каждый раз, как к ней обращаются, и возвращает этот символ в качестве своего значения. Это значит, что после
<pre> 
         c = getchar()
</pre> 
переменная <samp>c</samp> содержит следующий символ из входных данных. Символы обычно поступают с терминала, но это не должно нас касаться до главы 7.
<p>     Функция <samp>putchar(c)</samp> является дополнением к <samp>getchar</samp>: в результате обращения
<pre> 
         putchar (c)
</pre> 
содержимое переменной <samp>c</samp> выдается на некоторый выходной носитель, обычно опять на терминал. Обращение к функциям <samp>putchar</samp> и <samp>printf</samp> могут перемежаться; выдача будет появляться в том порядке, в котором происходят обращения.
<p>     Как и функция <samp>printf</samp>, функции <samp>getchar</samp> и <samp>putchar</samp> не содержат ничего экстраординарного. Они не входят в состав языка C, но к ним всегда можно обратиться.
 
<a name=l152>
<h4>     1.5.2. Копирование файла.</h4>
 
<p>     Имея в своем распоряжении только функции <samp>getchar</samp> и <samp>putchar</samp> вы можете, не зная ничего более об операциях ввода-вывода, написать удивительное количество полезных программ. Простейшим примером может служить программа посимвольного копирования вводного файла в выводной. Общая схема имеет вид:
<pre>
    ввести символ
    while (символ не является признаком конца файла) {
      вывести только что прочитанный символ
      ввести новый символ
    }
</pre> 
<p>Программа, написанная на языке C, выглядит следующим образом:
<pre> 
  main()  /* copy input to output; 1-st version */
  {
     int c;
 
     c = getchar();
     while (c != EOF) {
            putchar (c);
            c = getchar();
     }
  }
</pre>     
оператор отношения != означает "не равно".
<p>      Основная проблема заключается в том, чтобы зафиксировать конец файла ввода. Обычно, когда функция <samp>getchar</samp> наталкивается на конец файла ввода, она возвращает значение, не являющееся действительным символом; таким образом, программа может установить, что файл ввода исчерпан. Единственное осложнение, являющееся значительным неудобством, заключается в существовании двух общеупотребительных соглашений о том, какое значение фактически является признаком конца файла. Мы отсрочим решение этого вопроса, использовав символическое имя <samp>EOF</samp> для этого значения, каким бы оно ни было. На практике <samp>EOF</samp> будет либо -1, либо 0, так что для правильной работы перед программой должно стоять собственно либо
<pre> 
  #define  EOF  -1
</pre> 
 либо
<pre> 
  #define  EOF   0
</pre> 
<p>      Использовав символическую константу <samp>EOF</samp> для представления значения, возвращаемого функцией <samp>getchar</samp> при выходе на конец файла, мы обеспечили, что только одна величина в программе зависит от конкретного численного значения.
<p>      Мы также описали переменную <samp>c</samp> как <samp>int</samp>, а не <samp>char</samp>, с тем чтобы она могла хранить значение, возвращаемое <samp>getchar</samp>. как мы увидим в главе 2, эта величина действительно <samp>int</samp>, так как она должна быть в состоянии в дополнение ко всем возможным символам представлять и <samp>EOF</samp>.
<p>      Программистом, имеющим опыт работы на C, программа копирования была бы написана более сжато. В языке C любое присваивание, такое как
<pre> 
  c = getchar()
</pre> 
может быть использовано в выражении; его значение - просто значение, присваиваемое левой части. Если присваивание символа переменной <samp>c</samp> поместить внутрь проверочной части оператора <samp>while</samp>, то программа копирования файла запишется в виде: <pre> 
 main()  /* copy input to output; 2-nd version */
 {
 int c;
 
 while ((c = getchar()) != EOF)
 putchar(c);
 }
</pre> 
<p>      Программа извлекает символ, присваивает его переменной <samp>c</samp> и затем проверяет, не является ли этот символ признаком конца файла. Если нет - выполняется тело оператора <samp>while</samp>, выводящее этот символ. Затем цикл <samp>while</samp> повторяется. когда, наконец, будет достигнут конец файла ввода, оператор <samp>while</samp> завершается, а вместе с ним заканчивается выполнение и функции <samp>main</samp>.
<p>     В этой версии централизуется ввод - в программе только одно обращение к функции <samp>getchar</samp> - и ужимается программа. Вложение присваивания в проверяемое условие - это одно из тех мест языка C, которое приводит к значительному сокращению программ. Однако, на этом пути можно увлечься и начать писать недоступные для понимания программы. Эту тенденцию мы будем пытаться сдерживать.
<p>      Важно понять, что круглые скобки вокруг присваивания в условном выражении действительно необходимы. Старшинство операции != выше, чем операции присваивания =, а это означает, что в отсутствие круглых скобок проверка условия != будет выполнена до присваивания =. Таким образом, оператор
<pre> 
 c = getchar()  != EOF
</pre> 
эквивалентен оператору
<pre> 
 c = (getchar() != EOF)
</pre> 
<p>      Это, вопреки нашему желанию, приведет к тому, что <samp>c</samp> будет принимать значение 0 или 1 в зависимости от того, натолкнется или нет <samp>getchar</samp> на признак конца файла. (Подробнее об этом будет сказано в главе 2).
 
<a name=l153>
<h4>     1.5.3. Подсчет символов.</h4>
 
<p>      Следующая программа подсчитывает число символов; она представляет собой небольшое развитие программы копирования.
<pre> 
  main()  /* count characters in input */
  {
      long nc;
 
      nc = 0;
      while (getchar() != EOF )
     ++nc;
      printf("%1d\n", nc);
  }
</pre> 
<p>  Оператор
<pre> 
     ++nc;
</pre> 
демонстрирует новую операцию, ++, которая означает увеличение на единицу. Вы могли бы написать <samp>nc = nc + 1</samp>, но <samp>++nc</samp> более кратко и зачастую более эффективно. Имеется соответствующая операция -- уменьшение на единицу. Операции ++ и -- могут быть либо префиксными (<samp>++nc</samp>), либо постфиксными (<samp>nc++</samp>); эти две формы, как будет показано в главе 2, имеют в выражениях различные значения, но как <samp>++nc</samp>, так и <samp>nc++</samp> увеличивают <samp>nc</samp>. Пока мы будем придерживаться префиксных операций.
<p>     Программа подсчета символов накапливает их количество в переменной типа <samp>long</samp>, а не <samp>int</samp>. На PDP-11 максимальное значение равно 32767, и если описать счетчик как <samp>int</samp>, то он будет переполняться даже при сравнительно малом файле ввода; на языке C для HONEYWELL и IBM типы <samp>long</samp> и <samp>int</samp> являются синонимами и имеют значительно больший размер. Спецификация преобразования <samp>%1d</samp> указывает <samp>printf</samp>, что соответствующий аргумент является целым типа <samp>long</samp>.
<p>      Чтобы справиться с еще большими числами, вы можете использовать тип <samp>double</samp> (<samp>float</samp> двойной длины). Мы также используем оператор <samp>for</samp> вместо <samp>while</samp> с тем, чтобы проиллюстрировать другой способ записи цикла.
<pre> 
  main()  /* count characters in input  */
  {
      double  nc;
 
      for (nc = 0; getchar() != EOF; ++nc);
      printf("%.0f\n", nc);
  }
</pre> 
<p>      Функция <samp>printf</samp> использует спецификацию <samp>%f</samp> как для <samp>float</samp>, так и для <samp>double</samp>; спецификация <samp>%.0f</samp> подавляет печать несуществующей дробной части.
<p>      Тело оператора цикла <samp>for</samp> здесь пусто, так как вся работа выполняется в проверочной и реинициализационной частях. Но грамматические правила языка C требуют, чтобы оператор <samp>for</samp> имел тело. Изолированная точка с запятой, соответствующая пустому оператору, появляется здесь, чтобы удовлетворить этому требованию. Мы выделили ее на отдельную строку, чтобы сделать ее более заметной.
<p>      Прежде чем мы распростимся с программой подсчета символов, отметим, что если файл ввода не содержит никаких символов, то условие в <samp>while</samp> или <samp>for</samp> не выполнится при самом первом обращении к <samp>getchar</samp>, и, следовательно, программа выдаст нуль, т.е. правильный ответ. Это важное замечание. Одним из приятных свойств операторов <samp>while</samp> и <samp>for</samp> является то, что они проверяют условие в начале цикла, т.е. до выполнения тела. Если делать ничего не надо, то ничего не будет сделано, даже если это означает, что тело цикла никогда не будет выполняться. программы должны действовать разумно, когда они обращаются с файлами типа "никаких символов". Операторы <samp>while</samp> и <samp>for</samp> помогают обеспечить правильное поведение программ при граничных значениях проверяемых условий.
 
<a name=l154>
<h4>    1.5.4. Подсчет строк.</h4>
 
<p>      Следующая программа подсчитывает количество строк в файле ввода. Предполагается, что строки ввода заканчиваются символом новой строки <samp>\n</samp>, скрупулезно добавленным к каждой выписанной строке.
<pre>     
 main()  /* count lines in input */
 {
     int c,nl;
 
     nl = 0;
     while ((c = getchar()) != EOF)
        if (c =='\n')
           ++nl;
     printf("%d\n", nl);
 }
</pre> 
<p>      Тело <samp>while</samp> теперь содержит оператор <samp>if</samp>, который в свою очередь управляет оператором увеличения <samp>++nl</samp>. Оператор <samp>if</samp> проверяет заключенное в круглые скобки условие и, если оно истинно, выполняет следующий за ним оператор (или группу операторов, заключенных в фигурные скобки). Мы опять использовали сдвиг вправо, чтобы показать, что чем управляет.
<p>      Удвоенный знак равенства == является обозначением в языке C для "равно" (аналогично <samp>.EQ.</samp> в Фортране). Этот символ введен для того, чтобы отличать проверку на равенство от одиночного =, используемого при присваивании. Поскольку в типичных C - программах знак присваивания встречается при мерно в два раза чаще, чем проверка на равенство, то естественно, чтобы знак оператора был вполовину короче.
<p>      Любой отдельный символ может быть записан внутри одиночных кавычек, и при этом ему соответствует значение, равное численному значению этого символа в машинном наборе символов; это называется символьной константой. Так, например, <samp>'a'</samp> - символьная константа; ее значение в наборе символов ASCII (американский стандартный код для обмена информацией) равно 65, внутреннему представлению символа <samp>а</samp>. Конечно, <samp>'a'</samp> предпочтительнее, чем 65: его смысл очевиден и он не зависит от конкретного машинного набора символов.
<p>      Условные последовательности, используемые в символьных строках, также занимают законное место среди символьных констант. Так в проверках и арифметических выражениях <samp>'\n'</samp> представляет значение символа новой строки. Вы должны твердо уяснить, что <samp>'\n'</samp> - отдельный символ, который в выражениях эквивалентен одиночному целому; с другой стороны <samp>"\n"</samp> - это символьная строка, которая содержит только один символ. Вопрос о сопоставлении строк и символов обсуждается в главе 2.

<p><b><i>     Упражнение  1-6.</i> </b></p>
<p>      Напишите программу для подсчета пробелов, табуляций и новых строк.

<p><b><i>     Упражнение  1-7.</i> </b></p>
<p>      Напишите программу, которая копирует ввод на вывод, заменяя при этом каждую последовательность из одного или более пробелов на один пробел.
 
<a name=l155>
<h4>      1.5.5. Подсчет слов.</h4>
 
<p>      Четвертая программа из нашей серии полезных программ подсчитывает количество строк, слов и символов, используя при этом весьма широкое определение, что словом является любая последовательность символов, не содержащая пробелов, табуляций или новых строк. (Это - упрощенная версия утилиты <samp>wc</samp> системы UNIX)
<pre>     
 #define    YES  1
 #define    NO   0
 
 main()  /* count lines, words, chars in input */
 {
    int c, nl, nw, inword;
 
    inword = NO;
    nl = nw = nc = 0;
    while((c = getchar()) != EOF)  {
        ++nc;
        if (c == '\n')
             ++nl;
        if (c==' ' || c=='\n' || c=='\t')
             inword = NO;
        else if (inword == NO)  {
             inword = YES;
             ++nw;
        }
    }
    printf("%d %d %d\n", nl, nw, nc);
 }
</pre> 
<p>      Каждый раз, когда программа встречает первый символ слова, она увеличивает счетчик числа слов на единицу. Переменная <samp>inword</samp> следит за тем, находится ли программа в настоящий момент внутри слова или нет; сначала этой переменной присваивается " не в слове", чему соответствует значение <samp>NO</samp>. Мы предпочитаем символические константы <samp>YES</samp> и <samp>NO</samp> литерным значениям 1 и 0, потому что они делают программу более удобной для чтения. Конечно, в такой крошечной программе, как эта, это не приводит к заметной разнице, но в больших программах увеличение ясности вполне стоит тех скромных дополнительных усилий, которых требует следование этому принципу с самого начала. Вы также обнаружите, что существенные изменения гораздо легче вносить в те программы, где числа фигурируют только в качестве символьных констант.
     Строка
<pre> 
       nl = nw = nc = 0;
</pre> 
полагает все три переменные  равными  нулю.  Это  не особый случай, а следствие того обстоятельства, что оператору присваивания соответствует некоторое значение и присваивания проводятся последовательно справа налево. Таким образом, дело обстоит так, как если бы мы написали
<pre> 
        nc = (nl = (nw = 0));
</pre> 
операция || означает   <samp>OR</samp>, так что строка
<pre> 
        if( c==' ' || c=='\n' || c=='\t')
</pre> 
 говорит "если <samp>с</samp> - пробел, или <samp>с</samp> - символ новой строки, или <samp>с</samp> - табуляция ...".(Условная последовательность <samp>\t</samp> является изображением символа табуляции).
<p>    Имеется соответствующая операция && для <samp>AND</samp>. Выражения, связанные операциями && или ||, Рассматриваются слева направо, и при этом гарантируется, что оценивание выражений будет прекращено, как только станет ясно, является ли все выражение истинным или ложным. Так, если <samp>c</samp> оказывается пробелом, то нет никакой необходимости проверять, является ли <samp>c</samp> символом новой строки или табуляции, и такие проверки действительно не делаются. В данном случае это не имеет принципиального значения, но, как мы скоро увидим, в более сложных ситуациях эта особенность языка весьма существенна. Этот пример также демонстрирует оператор <samp>else</samp> языка C, который указывает то действие, которое должно выполняться, если условие, содержащееся в операторе <samp>if</samp>, окажется ложным.
  
Общая форма такова:
<pre> 
  if (выражение)
  оператор-1
  else оператор-2
</pre>  
<p>     Выполняется один и только один из двух операторов, связанных с конструкцией <samp>if-else</samp>. Если выражение истинно, выполняется <samp>оператор-1</samp>; если нет - выполняется <samp>оператор-2</samp>. Фактически каждый оператор может быть довольно сложным. В программе подсчета слов оператор, следующий за <samp>else</samp>, является оператором <samp>if</samp>, который управляет двумя операторами в фигурных скобках.

<p><b><i>     Упражнение  1-9.</i> </b></p>
<p>     Как бы вы стали проверять программу подсчета слов? Kакие имеются ограничения ?

<p><b><i>     Упражнение  1-10.</i> </b></p>
     Напишите программу, которая будет печатать слова из файла ввода, причем по одному на строку.

<p><b><i>     Упражнение  1-11.</i> </b></p>
<p>     Переделайте программу подсчета слов, используя лучшее определение "слова"; считайте, например словом последовательность букв, цифр и апострофов, начинающуюся с буквы.
 
<a name=l16>
<h3>      1.6. Массивы.</h3>
 
<p>     Давайте напишем программу подсчета числа появлений каждой цифры, символов пустых промежутков (пробел, табуляции, новая строка) и всех остальных символов. Конечно, такая за дача несколько искусственна, но она позволит нам проиллюстрировать в одной программе сразу несколько аспектов языка C.
<p>     Мы разбили вводимые символы на двенадцать категорий, и нам удобнее использовать массив для хранения числа появлений каждой цифры, а не десять отдельных переменных. Вот один из вариантов программы:
<pre>      
 main()  /* count digits, whtie space, others */  {
     int  c, i, nwhtie, nother;
     int  ndigit[10];
 
     nwhtie = nother = 0;
     for (i = 0; i < 10; ++i)
  ndigit[i] = 0;
 
     while ((c = getchar()) != EOF)
  if (c >= '0' && c <= '9')
      ++ndigit[c-'0'];
  else if(c== ' ' || c== '\n' || c== '\t')
      ++nwhtie;
  else
      ++nother;  
     printf("digits =");
     for (i = 0; i < 10; ++i)
     printf(" %d", ndigit[i]);
     printf("\nwhtie space = %d, other = %d\n",
      nwhtie, nother);
 }
</pre>  
<p>Описание
<pre>  
    int  ndigit[10];
</pre>  
объявляет, что <samp>ndigit</samp> является массивом из десяти целых. вязыке C индексы массива всегда начинаются с нуля (а не с 1, как в Фортране или PL/1), так что элементами массива являются <samp>ndigit[0], ndigit[1],..., ndigit[9]</samp>. Эта особенность отражена в циклах <samp>for</samp>, которые инициализируют и печатают массив.
<p>      Индекс может быть любым целым выражением, которое, конечно, может включать целые переменные, такие как <samp>i</samp>, и целые константы.
<p>      Эта конкретная программа сильно опирается на свойства символьного представления цифр. Так, например, в программе проверка
<pre> 
    if( c >= '0' && c <= '9')...
</pre>  
определяет, является ли символ в <samp>c</samp> цифрой, и если это так, то численное значение этой цифры определяется по формуле <samp>(c - '0')</samp>. Такой способ работает только в том случае, если значения символьных констант '0', '1' и т.д. положительные и расположены в порядке возрастания и нет ничего, кроме цифр, между константами '0' и '9'. К счастью, это верно для всех общепринятых наборов символов.
<p>     По определению перед проведением арифметических операций, вовлекающих переменные типа <samp>char</samp> и <samp>int</samp>, все они преобразуются к типу <samp>int</samp>, так что в арифметических выражениях переменные типа <samp>char</samp> по существу идентичны переменным типа <samp>int</samp>. Это вполне естественно и удобно; например, <samp>c -'0'</samp> - это целое выражение со значением между 0 и 9 в соответствии с тем, какой символ от '0' до '9' хранится в <samp>c</samp>, и, следовательно, оно является подходящим индексом для массива <samp>ndigit</samp>.
<p>     Выяснение вопроса, является ли данный символ цифрой, символом пустого промежутка или чем-либо еще, осуществляется последовательностью операторов
<pre>  
  if (c >= '0' && c <= '9')
  ++ndigit[c-'0'];
  else if(c == ' ' || c == '\n' || c == '\t')
  ++nwhtie;
  else
  ++nother;
</pre>  
<p>Конструкция
<pre>     if  (условие)
             оператор
     else if  (условие)
             оператор
     else
             оператор
</pre>       
часто встречаются в программах как средство выражения ситуаций, в которых осуществляется выбор одного из нескольких возможных решений.
<p>     Программа просто движется сверху вниз до тех пор, пока не удовлетворится какое-нибудь условие; тогда выполняется соответствующий <samp>оператор</samp>, и вся конструкция завершается. (Конечно, <samp>оператор</samp> может состоять из нескольких операторов, заключенных в фигурные скобки). Если ни одно из условий не удовлетворяется, то выполняется <samp>оператор</samp>, стоящий после заключительного <samp>else</samp>, если оно присутствует. Если последнее <samp>else</samp> и соответствующий <samp>оператор</samp> опущены (как в программе подсчета слов), то никаких действий не производится. Между начальным <samp>if</samp> и конечным <samp>else</samp> может помещаться произвольное количество групп
<pre>  
    else if (условие)
       оператор
</pre>  
<p>     С точки зрения стиля целесообразно записывать эту конструкцию так, как мы показали, с тем чтобы длинные выражения не залезали за правый край страницы.
<p>     Оператор <samp>switch</samp> (переключатель), который рассматривается в главе 3, представляет другую возможность для записи разветвления на несколько вариантов. этот оператор особенно удобен, когда проверяемое выражение является либо просто некоторым целым, либо символьным выражением, совпадающим с одной из некоторого набора констант. Версия этой программы, использующая оператор <samp>switch</samp>, будет для сравнения приведена в главе 3.
      
<p><b><i>     Упражнение  1-12.</i></b></p>
<p>     Напишите программу, печатающую гистограмму длин слов из файла ввода. Самое легкое - начертить гистограмму горизонтально; вертикальная ориентация требует больших усилий.
 
<a name=l17>
<h3>      1.7. Функции.</h3>
 
<p>     В языке C функции эквивалентны подпрограммам или функциям в Фортране или процедурам в PL/1, паскале и т.д. Функции дают удобный способ заключения некоторой части вычислений в черный ящик, который в дальнейшем можно использовать, не интересуясь его внутренним содержанием. Использование функций является фактически единственным способом справиться с потенциальной сложностью больших программ. Если функции организованы должным образом, то можно игнорировать то, как делается работа; достаточно знание того, что делается. Язык C разработан таким образом, чтобы сделать использование функций легким, удобным и эффективным. Вам будут часто встречаться функции длиной всего в несколько строчек, вызываемые только один раз, и они используются только потому, что это проясняет некоторую часть программы.
<p>     До сих пор мы использовали только предоставленные нам функции типа <samp>printf, getchar</samp> и <samp>putchar</samp>; теперь пора написать несколько наших собственных. так как в C нет операции возведения в степень, подобной операции ** в Фортране или PL/1, давайте проиллюстрируем механику определения функции на примере функции <samp>power(m,n)</samp>, возводящей целое <samp>m</samp> в целую положительную степень <samp>n</samp>. Так значение <samp>power(2,5)</samp> равно 32. Конечно, эта функция не выполняет всей работы операции **, поскольку она действует только с положительными степенями небольших чисел, но лучше не создавать дополнительных затруднений, смешивая несколько различных вопросов.
<p>     Ниже приводится функция power и использующая ее основная программа, так что вы можете видеть целиком всю структуру.
<pre>  
  main()  /* test power function */
  {
     int i;
 
     for(i = 0; i < 10; ++i)
      printf("%d %d %d\n",i,power(2,i),power(-3,i));
  }
 
  power(x,n)  /* raise x n-th power; n > 0  */
  int x,n;
  {
     int i, p;
     p = 1;
     for (i =1; i <= n; ++i)
     p = p * x;
     return (p);
  }
</pre> 
<p>     Все функции имеют одинаковый вид:
<pre> 
  имя (список аргументов, если они имеются)
  описание аргументов, если они имеются
  {
  описания
     операторы
  }
 </pre> 
 
<p>     Эти функции могут быть записаны в любом порядке и находиться в одном или двух исходных файлах. Конечно, если исходная программа размещается в двух файлах, вам придется дать больше указаний при компиляции и загрузке, чем если бы она находилась в одном, но это дело операционной системы, а не атрибут языка. В данный момент, для того чтобы все полученные сведения о прогоне C-программ, не изменились в дальнейшем, мы будем предполагать, что обе функции находятся в одном и том же файле.
<p>     Функция <samp>power</samp> вызывается дважды в строке
<pre>  
 printf("%d %d %d\n",i,power(2,i),power(-3,i));
</pre>  
при каждом обращении функция <samp>power</samp>, получив два аргумента, возвращает целое значение, которое печатается в заданном формате. В выражениях <samp>power(2,i)</samp> является точно таким же целым, как 2 и <samp>i</samp>. (Не все функции выдают целое значение; мы займемся этим вопросом в главе 4).
<p>     Аргументы функции power должны быть описаны соответствующим образом, так как их типы известны. Это сделано в строке
<pre>  
 int x,n;
</pre>  
 которая следует за именем функции.
<p>     Описания аргументов помещаются между списком аргументов и открывающейся левой фигурной скобкой; каждое описание заканчивается точкой с запятой. Имена, использованные для аргументов функции <samp>power</samp>, являются чисто локальными и недоступны никаким другим функциям: другие процедуры могут использовать те же самые имена без возникновения конфликта. Это верно и для переменных <samp>i</samp> и <samp>p</samp>; <samp>i</samp> в функции <samp>power</samp> никак не связано с <samp>i</samp> в функции <samp>main</samp>.
<p>     Значение, вычисленное функцией <samp>power</samp>, передаются в <samp>main</samp> с помощью оператора <samp>return</samp>, точно такого же, как в PL/1. Внутри круглых скобок можно написать любое выражение. Функция не обязана возвращать какое-либо значение; оператор <samp>return</samp>, не содержащий никакого выражения, приводит к такой же передаче управления, как "сваливание на конец" функции при достижении конечной правой фигурной скобки, но при этом в вызывающую функцию не возвращается никакого полезного значения.

<p><b><i>     Упражнение  1-13.</i></b></p>
<p>     Напишите программу преобразования прописных букв из файла ввода в строчные, используя при этом функцию <samp>ower(c)</samp>, которая возвращает значение <samp>c</samp>, если <samp>c</samp>- не буква, и значение соответствующей строчной буквы, если <samp>c</samp> - буква.
     
<a name=l18>
<h3>     1.8. Аргументы - вызов по значению.</h3>
 
<p>     Один аспект в C может оказаться непривычным для программистов, которые использовали другие языки, в частности, Фортран и PL/1. в языке C все аргументы функций передаются "по значению". это означает, что вызванная функция получает значения своих аргументов с помощью временных переменных (фактически через стек), а не их адреса. Это приводит к некоторым особенностям, отличным от тех, с которыми мы сталкивались в языках типа Фортрана и PL/1, использующих "вызов по ссылке ", где вызванная процедура работает с адресом аргумента, а не с его значением.
<p>     Главное отличие состоит в том, что в C вызванная функция не может изменить переменную из вызывающей функции; она может менять только свою собственную временную копию.
<p>     Вызов по значению, однако, не помеха, а весьма ценное качество. Оно обычно приводит к более компактным программам, содержащим меньше не относящихся к делу переменных, потому что с аргументами можно обращаться как с удобно инициализированными локальными переменными вызванной процедуры. Вот, например, вариант функции <samp>power</samp> использующей это обстоятельство
<pre>  
  power(x,n)  /* raise  x  n-th power; n > 0; version 2 */
  int x,n;
  {
  int p;
 
  for (p = 1; n > 0; --n)
       p = p * x;
  return (p);
  }
</pre>  
 
<p>     Аргумент <samp>n</samp> используется как временная переменная; из него вычитается единица до тех пор, пока он не станет нулем. Переменная <samp>i</samp> здесь больше не нужна. Что бы ни происходило с <samp>n</samp> внутри <samp>power</samp> это никак не влияет на аргумент, с которым первоначально обратились к функции <samp>power</samp>.
<p>     При необходимости все же можно добиться, чтобы функция изменила переменную из вызывающей программы. Эта программа должна обеспечить установление адреса переменной (технически, через указатель на переменную), а в вызываемой функции надо описать соответствующий аргумент как указатель и ссылаться к фактической переменной косвенно через него. Мы рассмотрим это подробно в главе 5.
<p>     Когда в качестве аргумента выступает имя массива, то фактическим значением, передаваемым функции, является адрес начала массива. (Здесь нет никакого копирования элементов массива). С помощью индексации и адреса начала функция может  найти и изменить любой элемент массива. Это - тема следующего раздела.

<a name=l19>
<h3>      1.9. Массивы символов.</h3>
 
<p>     По-видимому самым общим типом массива в C является массив символов. Чтобы проиллюстрировать использование массивов символов и обрабатывающих их функций, давайте напишем программу, которая читает набор строк и печатает самую длинную из них. Основная схема программы достаточно проста:
<pre>  
    while (имеется еще строка)
      if (эта строка длиннее самой длинной из предыдущих)
         запомнить эту строку и ее длину
    напечатать самую длинную строку
</pre> 
<p>     По этой схеме ясно, что программа естественным образом распадается на несколько частей. Одна часть читает новую строку, другая проверяет ее, третья запоминает, а остальные части программы управляют этим процессом.
<p>     Поскольку все так прекрасно делится, было бы хорошо и написать программу соответствующим образом. Давайте сначала напишем отдельную функцию <samp>getline</samp>, которая будет извлекать следующую строку из файла ввода; это - обобщение функции <samp>getchar</samp>. Мы попытаемся сделать эту функцию по возможности более гибкой, чтобы она была полезной и в других ситуациях. Как минимум, <samp>getline</samp> должна передавать сигнал о возможном появлении конца файла; более общий полезный вариант мог бы передавать длину строки или нуль, если встретится конец файла. нуль не может быть длиной строки, так как каждая строка содержит по крайней мере один символ; даже строка, содержащая только символ новой строки, имеет длину 1.
<p>     Когда мы находим строку, которая длиннее самой длинной из предыдущих, то ее надо где-то запомнить. Это наводит на мысль о другой функции, <samp>copy</samp>, которая будет копировать новую строку в место хранения.
<p>     Наконец, нам нужна основная программа для управления функциями <samp>getline</samp> и <samp>copy</samp>. Вот результат:
<pre>  
 #define  MAXLINE  1000 /* maximum input line size */
  main()  /* find longest line */
  {
  int len; /* current line length */
  int max; /* maximum length seen so far */
  char line[MAXLINE]; /* current input line */
  char save[MAXLINE]; /* longest line, saved */
 
  max = 0;
  while ((len = getline(line, MAXLINE)) > 0)
      if (len > max) {
     max = len;
     copy(line, save);
      }
      if (max > 0)   /* there was a line */
     printf("%s", save);
  }
     
  getline(s,lim) /* get line into s, return length */
  char s[];
  int lim;
  {
     int c, i;
 
     for(i=0;i&lt;lim-1 &amp;&amp; (c=getchar())!=EOF && c!='\n'; ++i)
     s[i] = c;
     if (c == '\n')  {
   s[i] = c;
   ++i;
     }
     s[i] = '\0';
     return(i);
  }
 
  copy(s1, s2)    /* copy s1 to s2; assume s2 big enough */   
  char s1[], s2[];
  {
  int i;
 
  i = 0;
  while ((s2[i] = s1[i] != '\0')
     ++i;
  }
</pre>      
<p>     Функция <samp>main</samp> и <samp>getline</samp> общаются как через пару аргументов, так и через возвращаемое значение. Аргументы <samp>getline</samp>  описаны в строках
<pre>  
     char s[];
     int lim;
</pre>  
которые указывают, что первый аргумент является массивом, а второй - целым.
<p>     Длина массива <samp>s</samp> не указана, так как она определена в <samp>main</samp>. Функция <samp>getline</samp> использует оператор <samp>return</samp> для передачи значения назад в вызывающую программу точно так же, как это делала функция <samp>power</samp>. Одни функции возвращают некоторое нужное значение; другие, подобно <samp>copy</samp>, используются из-за их действия и не возвращают никакого значения.
<p>     Чтобы пометить конец строки символов, функция getline помещает в конец создаваемого ей массива символ \0 (нулевой символ, значение которого равно нулю). Это соглашение используется также компилятором с языка C: когда в C - программе встречается строчная константа типа
<pre>  
    "hello\n"
</pre>            
то компилятор создает массив символов, содержащий символы той строки, и заканчивает его символом \0, с тем чтобы функции, подобные printf, могли зафиксировать конец массива:
<table border=1 align=center>
<tr><td>h</td><td>e</td><td>l</td><td>l</td><td>o</td><td>\n</td><td>\0</td>
</tr></table>

<p>Спецификация формата <samp>%s</samp> указывает, что <samp>printf</samp> ожидает строку, представленную в такой форме. Проанализировав функцию <samp>copy</samp>, вы обнаружите, что и она опирается на тот факт, что ее входной аргумент оканчивается символом \0, и копирует этот символ в выходной аргумент <samp>s2</samp>. (Все это подразумевает, что символ \0 не является частью нормального текста.)
<p>     Между прочим, стоит отметить, что даже в такой маленькой программе, как эта, возникает несколько неприятных организационных проблем. Например, что должна делать <samp>main</samp>, если она встретит строку, превышающую ее максимально возможный размер? Функция <samp>getline</samp> поступает разумно: при заполнении массива она прекращает дальнейшее извлечение символов, даже если не встречает символа новой строки. Проверив полученную длину и последний символ, функция main может установить, не была ли эта строка слишком длинной, и поступить затем, как она сочтет нужным. Ради краткости мы опустили эту проблему.
<p>     Пользователь функции <samp>getline</samp> никак не может заранее узнать, насколько длинной окажется вводимая строка. Поэтому в <samp>getline</samp> включен контроль переполнения. В то же время пользователь функции copy уже знает (или может узнать), каков размер строк, так что мы предпочли не включать в эту функцию дополнительный контроль.

<p><b><i>     Упражнение  1-14.</i> </b></p>
<p>     Переделайте ведущую часть программы поиска самой длинной строки таким образом, чтобы она правильно печатала длины сколь угодно длинных вводимых строк и возможно больший текст.

<p><b><i>     Упражнение   1-15. </i></b></p>
<p>     Напишите программу печати всех строк длиннее 80 символов.

<p><b><i>     Упражнение  1-16. </i></b></p>
<p>     Напишите программу, которая будет удалять из каждой строки стоящие в конце пробелы и табуляции, а также строки, целиком состоящие из пробелов.

<p><b><i>     Упражнение  1-17.</i> </b></p>
<p>     Напишите функцию reverse(s), которая располагает символьную строку s в обратном порядке. С ее помощью напишите программу, которая обратит каждую строку из файла ввода.

<a name=l110>
<h3>1.10. Область действия: внешние переменные.</h3>
<p>       Переменные в <samp>main</samp> (<samp>line, save</samp> и т.д.) являются внутренними или локальными по отношению к функции <samp>main</samp>, потому что они описаны внутри <samp>main</samp> и никакая другая функция не имеет к ним прямого доступа. Это же верно и относительно переменных в других функциях; например, переменная <samp>i</samp> в функции <samp>getline</samp> никак не связана с <samp>i</samp> в <samp>copy</samp>. Каждая локальная переменная существует только тогда, когда произошло обращение к соответствующей функции, и исчезает, как только закончится выполнение этой функции. По этой причине такие переменные, следуя терминологии других языков, обычно называют автоматическими. Мы впредь будем использовать термин автоматические при ссылке на эти динамические локальные переменные. (В главе 4 обсуждается класс статической памяти, когда локальные переменные все же оказываются в состоянии сохранить свои значения между обращениями к функциям.)
<p>     Поскольку автоматические переменные появляются и исчезают вместе с обращением к функции, они не сохраняют своих значений в промежутке от одного вызова до другого, в силу чего им при каждом входе нужно явно присваивать значения. Если этого не сделать, то они будут содержать мусор.
<p>     В качестве альтернативы к автоматическим переменным можно определить переменные, которые будут внешними для всех функций, т.е. глобальными переменными, к которым может обратиться по имени любая функция, которая пожелает это сделать. (этот механизм весьма сходен с <samp>COMMON</samp> в Фортране и <samp>EXTERNAL</samp> в PL/1). Так как внешние переменные доступны всюду, их можно использовать вместо списка аргументов для передачи данных между функциями. Кроме того, поскольку внешние переменные существуют постоянно, а не появляются и исчезают вместе с вызываемыми функциями, они сохраняют свои значения и после того, как функции, присвоившие им эти значения, завершат свою работу.
<p>     Внешняя переменная должна быть определена вне всех функций; при этом ей выделяется фактическое место в памяти. Такая переменная должна быть также описана в каждой функции, которая собирается ее использовать; это можно сделать либо явным описанием <samp>extern</samp>, либо неявным по контексту. Чтобы сделать обсуждение более конкретным, давайте перепишем программу поиска самой длинной строки, сделав <samp>line, save</samp> и <samp>max</samp> внешними переменными. Это потребует изменения описаний и тел всех трех функций, а также обращений к ним.
<pre>  
 #define MAXLINE 1000   /* max. input line size*/
 
 char   line[MAXLINE];  /* input line */
 char   save[MAXLINE];/* longest line saved here */
 int   max;/*length of longest line seen so far */
     
 main()  /*find longest line; specialized version */
 {
    int     len;
    extern  int   max;
    extern  char   save[];
    max = 0;
 
 while ( (len = getline()) > 0 )
    if ( len > max )  {
            max = len;
            copy();
    }
 if ( max > 0 )  /* there was a line */
    printf( "%s", save );
 }
 
 getline()       /* specialized version */
 {
    int c, i;
    extern char line[];
 
    for (i = 0; i < MAXLINE-1
         && (c=getchar()) !=EOF && c!='\n'; ++I)
             line[I] = c;
             ++i;
     }
     line[i] = '\0';
     return(i);
  }
  copy()  /* specialized version */
  {      int i;
     extern char line[], save[];
 
     i = 0;
     while ((save[i] = line[i]) !='\0')
             ++i;
  }
</pre>      
<p>     Внешние переменные для функций <samp>main, getline</samp> и <samp>copy</samp> определены в первых строчках приведенного выше примера, которыми указывается их тип и вызывается отведение для них памяти. синтаксически внешние описания точно такие же, как описания, которые мы использовали ранее, но так как они расположены вне функций, соответствующие переменные являются внешними. Чтобы функция могла использовать внешнюю переменую, ей надо сообщить ее имя. Один способ сделать это - включить в функцию описание extern; это описание отличается от предыдущих только добавлением ключевого слова <samp>extern</samp>.
<p>     В определенных ситуациях описание <samp>extern</samp> может быть опущено: если внешнее определение переменной находится в том же исходном файле, раньше ее использования в некоторой конкретной функции, то не обязательно включать описание <samp>extern</samp> для этой переменной в саму функцию. Описания <samp>extern</samp> в функциях <samp>main, getline</samp> и <samp>copy</samp> являются, таким образом, излишними. Фактически, обычная практика заключается в помещении определений всех внешних переменных в начале исходного файла и последующем опускании всех описаний <samp>extern</samp>.
<p>     Если программа находится в нескольких исходных файлах, и некоторая переменная определена, скажем в файле 1, а используется в файле 2, то чтобы связать эти два вхождения переменной, необходимо в файле 2 использовать описание extern. Этот вопрос подробно обсуждается в главе 4.
<p>     Вы должно быть заметили, что мы в этом разделе при ссылке на внешние переменные очень аккуратно используем слова описание и определение. "Определение" относится к тому месту, где переменная фактически заводится и ей выделяется память; "описание" относится к тем местам, где указывается природа переменной, но никакой памяти не отводится.
<p>     Между прочим, существует тенденция объявлять все, что ни попадется, внешними переменными, поскольку кажется, что это упрощает связи, - списки аргументов становятся короче и переменные всегда присутствуют, когда бы вам они ни понадобились. Но внешние переменные присутствуют и тогда, когда вы в них не нуждаетесь. Такой стиль программирования чреват опасностью, так как он приводит к программам, связи данных внутри которых не вполне очевидны. Переменные при этом могут изменяться неожиданным и даже неумышленным образом, а программы становится трудно модифицировать, когда возникает такая
 необходимость. Вторая версия программы поиска самой длинной
 строки уступает первой отчасти по этим причинам, а отчасти
 потому, что она лишила универсальности две весьма полезные
 функции, введя в них имена переменных, с которыми они будут
 манипулировать.

<p><b><i>     Упражнение 1-18.</i></b></p>
<p>     Проверка в операторе <samp>for</samp> функции <samp>getline</samp> довольно неуклюжа. Перепишите программу таким образом, чтобы сделать эту проверку более ясной, но сохраните при этом то же самое поведение в конце файла и при переполнении буфера. Является ли это поведение самым разумным?
 
<a name=l111>
<h3>     1.11. Резюме</h3>
 
<p>     На данном этапе мы обсудили то, что можно бы назвать традиционным ядром языка C. Имея эту горсть строительных блоков, можно писать полезные программы весьма значительного размера, и было бы вероятно неплохой идеей, если бы вы задержались здесь на какое-то время и поступили таким образом: следующие ниже упражнения предлагают вам ряд программ несколько большей сложности, чем те, которые были приведены в этой главе.
<p>     После того как вы овладеете этой частью C, приступайте к чтению следующих нескольких глав. Усилия, которые вы при этом затратите, полностью окупятся, потому что в этих главах обсуждаются именно те стороны C, где мощь и выразительность языка начинает становиться очевидной.

<p><b><i>    Упражнение 1-19.</i></b></p>
<p>     Напишите программу <samp>detab</samp>, которая заменяет табуляции во вводе на нужное число пробелов так, чтобы промежуток достигал следующей табуляционной остановки. Предположите фиксированный набор табуляционных установок, например, через каждые n позиций.

<p><b><i>     Упражнение 1-20. </i></b></p>
<p>     Напишите программу <samp>entab</samp>, которая заменяет строки пробелов минимальным числом табуляций и пробелов, достигая при этом тех же самых промежутков. Используйте те же табуляционные остановки, как и в <samp>detab</samp>.

<p><b><i>     Упражнение 1-21.</i> </b></p>
<p>     Напишите программу для "сгибания" длинных вводимых строк после последнего отличного от пробела символа, стоящего до столбца <samp>n</samp> ввода, где <samp>n</samp> - параметр. Убедитесь, что ваша программа делает что-то разумное с очень длинными строками и в случае, когда перед указанным столбцом нет ни табуляций, ни пробелов.

<p><b><i>     Упражнение 1-22. </i></b></p>
<p>     Напишите программу удаления из C-программы всех комментариев. Не забывайте аккуратно обращаться с "закавыченными" строками и символьными константами.

<p><b><i>     Упражнение 1-23.</i> </b></p>
<p>     Напишите программу проверки C-программы на элементарные синтаксические ошибки, такие как несоответствие круглых, квадратных и фигурных скобок. Не забудьте о кавычках, как одиночных, так и двойных, и о комментариях. (Эта программа весьма сложна, если вы будете писать ее для самого общего случая).

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=index.html#index>Оглавление</a></td><td><a href=c_2.html>Вперед</a></td></tr>
</table><hr>
</p>
</body>
</html>

