<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Керниган и Ритчи </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://kulichki.rambler.ru/moshkow/  -->
<!-- Owner: Alexander S. Derevjanko (web-design only)-->
<!-- ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_7.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_9.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2>8. Интерфейс системы UNIX</h2>
<p>     Материал этой главы относится к интерфейсу между C-программами и операционной системой UNIX. Так как большинство пользователей языка C работают на системе UNIX, эта глава окажется полезной для большинства читателей. даже если вы используете C-компилятор на другой машине, изучение приводимых здесь примеров должно помочь вам глубже проникнуть в методы программирования на языке C.
<p>     Эта глава делится на три основные части: ввод/вывод, система файлов и распределение памяти. Первые две части предполагают небольшое знакомство с внешними характеристика ми системы UNIX.
<p>     В главе 7 мы имели дело с системным интерфейсом, который одинаков для всего многообразия операционных систем. На каждой конкретной системе функции стандартной библиотеки должны быть написаны в терминах ввода-вывода, доступных на данной машине. В следующих нескольких разделах мы опишем основную систему связанных с вводом и выводом точек входа операционной системы UNIX и проиллюстрируем, как с их помощью могут быть реализованы различные части стандартной библиотеки.
 
<a name=81>
<h3>     8.1. Дескрипторы файлов</h3>
<p>     В операционной системе UNIX весь ввод и вывод осуществляется посредством чтения файлов или их записи, потому что все периферийные устройства, включая даже терминал пользователя, являются файлами определенной файловой системы. Это означает, что один однородный интерфейс управляет всеми связями между программой и периферийными устройствами.
<p>     В наиболее общем случае перед чтением из файла или записью в файл необходимо сообщить системе о вашем намерении; этот процесс называется "открытием" файла. Система выясняет, имеете ли вы право поступать таким образом (существует ли этот файл? имеется ли у вас разрешение на обращение к нему?), и если все в порядке, возвращает в программу небольшое положительное целое число, называемое дескриптором файла. всякий раз, когда этот файл используется для ввода или вывода, для идентификации файла употребляется дескриптор файла, а не его имя. (Здесь существует примерная аналогия с использованием READ (5,...) и WRITE (6,...) в Фортране). Вся информация об открытом файле содержится в системе; программа пользователя обращается к файлу только через дескриптор файла.
<p>     Для удобства выполнения обычных операций ввода и вывода с помощью терминала пользователя существуют специальные соглашения. Когда интерпретатор команд ("shell") прогоняет программу, он открывает три файла, называемые стандартным вводом, стандартным выводом и стандартным выводом ошибок, которые имеют соответственно числа 0, 1 и 2 в качестве дескрипторов этих файлов. В нормальном состоянии все они связаны с терминалом, так что если программа читает с дескриптором файла 0 и пишет с дескрипторами файлов 1 и 2, то она может осуществлять ввод и вывод с помощью терминала, не заботясь об открытии соответствующих файлов.
<p>     Пользователь программы может перенаправлять ввод и вывод на файлы, используя операции командного интерпретатора shell "&lt;" и "&gt;" :
<pre> 
   prog &lt;infile&gt;outfile
</pre> 
<p> В этом случае интерпретатор команд shell изменит присваивание по умолчанию дескрипторов файлов 0 и 1 с терминала на указанные файлы. Нормально дескриптор файла 2 остается связанным с терминалом, так что сообщения об ошибках могут поступать туда. Подобные замечания справедливы и тогда, когда ввод и вывод связан с каналом. Следует отметить, что во всех случаях прикрепления файлов изменяются интерпретатором shell, а не программой. Сама программа, пока она использует файл 0 для ввода и файлы 1 и 2 для вывода, не знает ни откуда приходит ее ввод, ни куда поступает ее выдача.
     
<a name=82>
<h3>     8.2. Низкоуровневый ввод/вывод - операторы read и write. </h3>
<p>     Самый низкий уровень ввода/вывода в системе UNIX не предусматривает ни какой-либо буферизации, ни какого-либо другого сервиса; он по существу является непосредственным входом в операционную систему. Весь ввод и вывод осуществляется двумя функциями: read и write. Первым аргументом обеих функций является дескриптор файла. Вторым аргументом является буфер в вашей программе, откуда или куда должны поступать данные. Третий аргумент - это число подлежащих пересылке байтов. Обращения к этим функциям имеют вид:
<pre> 
 n_read=read(fd,buf,n);
 n_written=write(fd,buf,n);
</pre> 
<p> При каждом обращении возвращается счетчик байтов, указывающий фактическое число переданных байтов. При чтении возвращенное число байтов может оказаться меньше, чем запрошенное число. Возвращенное нулевое число байтов означает конец файла, а "-1" указывает на наличие какой-либо ошибки. При записи возвращенное значение равно числу фактически записанных байтов; несовпадение этого числа с числом байтов, которое предполагалось записать, обычно свидетельствует об ошибке.
<p>     Количество байтов, подлежащих чтению или записи, может быть совершенно произвольным. Двумя самыми распространенными величинами являются "1", которая означает передачу одного символа за обращение (т.е., без использования буфера), и "512", которая соответствует физическому размеру блока на многих периферийных устройствах. Этот последний размер будет наиболее эффективным, но даже ввод или вывод по одному символу за обращение не будет необыкновенно дорогим.
<p>     Объединив все эти факты, мы написали простую программу для копирования ввода на вывод, эквивалентную программе копирования файлов, написанной в главе 1. На системе UNIX эта программа будет копировать что угодно куда угодно, потому что ввод и вывод могут быть перенаправлены на любой файл или устройство.
<pre> 
    #define BUFSIZE 512 /*best size for PDP-11 UNIX*/
    main() /*copy input to output*/
    {
   char buf[BUFSIZE];
   int n;
   while((n=read(0,buf,BUFSIZE))&gt;0)
   write(1,buf,n);
    }
</pre> 
<p> Если размер файла не будет кратен BUFSIZE, то при некотором обращении к read будет возвращено меньшее число байтов, которые затем записываются с помощью write; при следующем после этого обращении к read будет возвращен нуль.
<p>     Поучительно разобраться, как можно использовать функции read и write для построения процедур более высокого уровня, таких как getchar, putchar и т.д. Вот, например, вариант функции getchar, осуществляющий ввод без использования буфера.
<pre> 
    #define CMASK 0377 /*for making char's &gt; 0*/
    getchar() /*unbuffered single character input*/
    {
   char c;
   return((read(0,&c,1)&gt;0 7 & CMASK : EOF);
    }
</pre> 
<p> Переменная 'c' должна быть описана как char, потому что функция read принимает указатель на символы. Возвращаемый символ должен быть маскирован числом 0377 для гарантии его положительности; в противном случае знаковый разряд может сделать его значение отрицательным. (Константа 0377 подходит для ЭВМ PDP-11, но не обязательно для других машин).
<p>     Второй вариант функции getchar осуществляет ввод большими порциями, а выдает символы по одному за обращение.
<pre> 
   #define CMASK 0377 /*for making char's&gt;0*/
   #define BUFSIZE 512
   getchar() /*buffered version*/
   {
  static char  buf[BUFSIZE];
  static char  *bufp = buf;
  static int   n = 0;
  if (n==0) { /*buffer is empty*/
  n=read(0,buf,BUFSIZE);
  bufp = buf;
  }
  return((--n&gt;=0) ? *bufp++ & CMASK : EOF);
   }
</pre>
     
<a name=83>
<h3>     8.3. Открытие, создание, закрытие и уничтожение (unlink). </h3>
<p>     Кроме случая, когда по умолчанию определены стандартные файлы ввода, вывода и ошибок, вы должны явно открывать файлы, чтобы затем читать из них или писать в них. Для этой цели существуют две точки входа: open и creat.
<p>     Функция open весьма сходна с функцией fopen, рассмотренной в главе 7, за исключением того, что вместо возвращения указателя файла она возвращает дескриптор файла, который является просто целым типа int.
<pre> 
 int fd;
 fd=open(name,rwmode);
</pre> 
<p> Как и в случае fopen, аргумент name является символьной строкой, соответствующей внешнему имени файла. Однако аргумент, определяющий режим доступа, отличен: rwmode равно: 0 - для чтения, 1 - для записи, 2 - для чтения и записи. Если происходит какая-то ошибка, функция open возвращает "-1"; в противном случае она возвращает действительный дескриптор файла.
<p>     Попытка открыть файл, который не существует, является ошибкой. Точка входа creat предоставляет возможность создания новых файлов или перезаписи старых. В результате обращения
<pre>     
   fd=creat(name,pmode);
</pre> 
возвращает дескриптор файла, если оказалось возможным создать файл с именем name, и "-1" в противном случае. Если файл с таким именем уже существует, creat усечет его до нулевой длины; создание файла, который уже существует, не является ошибкой.
<p>     Если файл является совершенно новым, то creat создает его с определенным режимом защиты, специфицируемым аргументом pmode. В системе файлов на UNIX с файлом связываются девять битов защиты информации, которые управляют разрешением
 на чтение, запись и выполнение для владельца файла, для группы владельцев и для всех остальных пользователей. Таким образом, трехзначное восьмеричное число наиболее удобно для спецификации разрешений. Например, число 0755 свидетельствует о разрешении на чтение, запись и выполнение для владельца и о разрешении на чтение и выполнение для группы и всех остальных.
<p>     Для иллюстрации ниже приводится программа копирования одного файла в другой, являющаяся упрощенным вариантом утилиты cp системы UNIX. (Основное упрощение заключается в том, что наш вариант копирует только один файл и что второй аргумент не должен быть справочником).
<pre> 
    #define NULL 0
    #define BUFSIZE 512
    #define pmode 0644/*RW for owner,r for group,others*/
    main(argc,argv) /*cp: copy f1 to f2*/
    int argc;
    char *argv[];
    {
   int f1, f2, n;
   char buf[BUFSIZE];
   if (argc ! = 3)
   error("usage:cp from to", NULL);
   if ((f1=open(argv[1],0))== -1)
   error("cp:can't open %s", argv[1]);
   if ((f2=creat(argv[2],pmode))== -1)
   error("cp: can't create %s", argv[2]);
   while ((n=read(f1,buf,BUFSIZE))&gt;0)
   if (write(f2,buf,n) !=n)
        error("cp: write error", NULL);
   exit(0);
    }
    error(s1,s2) /*print error message and die*/
    char *s1, s2;
    {
   printf(s1,s2);
   printf("\n");
   exit(1);
    }
</pre> 
<p>     Существует ограничение (обычно 15 - 25) на количество файлов, которые программа может иметь открытыми одновременно. В соответствии с этим любая программа, собирающаяся работать со многими файлами, должна быть подготовлена к повторному использованию дескрипторов файлов. Процедура close прерывает связь между дескриптором файла и открытым файлом и освобождает дескриптор файла для использования с некоторым другим файлом. Завершение выполнения программы через exit или в результате возврата из ведущей программы приводит к закрытию всех открытых файлов.
<p>     Функция уничтожения unlink(filename) удаляет из системы файлов файл с именем filename (из данного справочного файла. Файл может быть сцеплен с другим справочником, возможно, под другим именем - примеч.переводчика).

<p><b><i>     Упражнение 8-1. </i></b></p>
<p>     Перепишите программу cat из главы 7, используя функции read, write, open и close вместо их эквивалентов из стандартной библиотеки. Проведите эксперименты для определения относительной скорости работы этих двух вариантов.
 
<a name=84>
<h3>     8.4. Произвольный доступ - seek и lseek. </h3>
<p>     Нормально при работе с файлами ввод и вывод осуществляется последовательно: при каждом обращении к функциям read и write чтение или запись начинаются с позиции, непосредственно следующей за предыдущей обработанной. Но при необходимости файл может читаться или записываться в любом произвольном порядке. Обращение к системе с помощью функции lseek позволяет передвигаться по файлу, не производя фактического чтения или записи. В результате обращения
<pre> 
  lseek(fd,offset,origin);
</pre>
текущая позиция в файле с дескриптором fd передвигается на позицию offset (смещение), которая отсчитывается от места, указываемого аргументом origin (начало отсчета). Последующее чтение или запись будут теперь начинаться с этой позиции. Аргумент offset имеет тип long; fd и origin имеют тип int. Аргумент origin может принимать значения 0,1 или 2, указывая на то, что величина offset должна отсчитываться соответственно от начала файла, от текущей позиции или от конца файла. Например, чтобы дополнить файл, следует перед записью найти его конец:
<pre> 
  lseek(fd,0L,2);
</pre> 
чтобы вернуться к началу ("перемотать обратно"), можно написать:
<pre> 
  lseek(fd,0L,0);
</pre> 
обратите внимание на аргумент 0L; его можно было бы записать и в виде (long) 0.
<p>     Функция lseek позволяет обращаться с файлами примерно так же, как с большими массивами, правда ценой более медленного доступа. следующая простая функция, например, считывает любое количество байтов, начиная с произвольного места в файле.
<pre> 
    get(fd,pos,buf,n) /*read n bytes from position pos*/
    int fd, n;
    long pos;
    char *buf;
    {
   lseek(fd,pos,0); /*get to pos*/
   return(read(fd,buf,n));
    }
</pre> 
<p>     В более ранних редакциях, чем редакция 7 системы UNIX, основная точка входа в систему ввода-вывода называется seek. Функция seek идентична функции lseek, за исключением того, что аргумент offset имеет тип int, а не long. в соответствии с этим, поскольку на PDP-11 целые имеют только 16 битов, аргумент offset, указываемый функции seek, ограничен величиной 65535; по этой причине аргумент origin может иметь значения 3, 4, 5, которые заставляют функцию seek умножить заданное значение offset на 512 (количество байтов в одном физическом
 блоке) и затем интерпретировать origin, как если это 0, 1 или 2 соответственно. Следовательно, чтобы достичь произвольного места в большом файле, нужно два обращения к seek: сначала одно, которое выделяет нужный блок, а затем второе, где origin имеет значение 1 и которое осуществляет передвижение на желаемый байт внутри блока.

<p><b><i>     Упражнение 8-2. </i></b></p>
<p>     Очевидно, что seek может быть написана в терминалах lseek и наоборот. напишите каждую функцию через другую.
     
<a name=85>
<h3>     8.5. Пример - реализация функций fopen и getc. </h3>
<p>     Давайте теперь на примере реализации функций fopen и getc из стандартной библиотеки подпрограмм продемонстрируем, как некоторые из описанных элементов объединяются вместе.
<p>     Напомним, что в стандартной библиотеке файлы описываются посредством указателей файлов, а не дескрипторов. Указатель файла является указателем на структуру, которая содержит несколько элементов информации о файле: указатель буфера, чтобы файл мог читаться большими порциями; счетчик числа символов, оставшихся в буфере; указатель следующей позиции символа в буфере; некоторые признаки, указывающие режим чтения или записи и т.д.; дескриптор файла.
<p>     Описывающая файл структура данных содержится в файле stdio.h, который должен включаться (посредством #include) в любой исходный файл, в котором используются функции из стандартной библиотеки. Он также включается функциями этой библиотеки. В приводимой ниже выдержке из файла stdio.h имена, предназначаемые только для использования функциями библиотеки, начинаются с подчеркивания, с тем чтобы уменьшить вероятность совпадения с именами в программе пользователя.
<pre> 
  define _BUFSIZE 512
  define _nfile   20 /*files that can be handled*/
   typedef struct _iobuf {
     char *_ptr;   /*next character position*/
     int  _cnt;    /*number of characters left*/
     char *_base;  /*locatoin of buffer*/
     int  _flag;   /*mode of file access*/
     int  _fd;     /*file descriptor*/
  ) file;
  extern file _iob[_nfile];
   
  define   stdin         (&_iob[0])
  define   stdout        (&_iob[1])
  define   stderr        (&_iob[2])
   
  define   _READ   01  /* file open for reading */
  define   _WRITE  02  /* file open for writng */
  define   _UNBUF  04  /* file is unbuffered */
  define   _BIGBUF 010 /* big buffer allocated */
  define   _EOF 020 /* EOF has occurred on this file */
  define   _ERR 040 /* error has occurred on this file */
  define   NULL 0
  define   EOF  (-1)
   
  define   getc(p) (--(p)-&gt;_cnt &gt;= 0 \
    ? *(p)-&gt;_ptr++ & 0377 : _filebuf(p))
  define   getchar() getc(stdin)
   
  define   putc(x,p) (--(p)-&gt;_cnt &gt;= 0 \
    ? *(p)-&gt;_ptr++ = (x) : _flushbuf((x),p))
  define   putchar(x)       putc(x,stdout)
</pre>     
<p>     В нормальном состоянии макрос getc просто уменьшает счетчик, передвигает указатель и возвращает символ. (Если определение #define слишком длинное, то оно продолжается с помощью обратной косой черты). Если однако счетчик становится отрицательным, то getc вызывает функцию _filebuf, которая снова заполняет буфер, реинициализирует содержимое структуры и возвращает символ. Функция может предоставлять переносимый интерфейс и в то же время содержать непереносимые конструкции: getc маскирует символ числом 0377, которое подавляет знаковое расширение, осуществляемое на PDP-11, и тем самым гарантирует положительность всех символов.
<p>     Хотя мы не собираемся обсуждать какие-либо детали, мы все же включили сюда определение макроса putc, для того чтобы показать, что она работает в основном точно также, как и getc, обращаясь при заполнении буфера к функции _flushbuf.
<p>     Теперь может быть написана функция fopen. Большая часть программы функции fopen связана с открыванием файла и расположением его в нужном месте, а также с установлением битов признаков таким образом, чтобы они указывали нужное состояние. Функция fopen не выделяет какой-либо буферной памяти; это делается функцией _filebuf при первом чтении из файла.
<pre> 
  #include &lt;stdio.h&gt;
  #define  pmode  0644 /*r/w for owner; r for others*/
  file *fopen(name,mode) /*open file,return file ptr*/
  register char *name, *mode;
  {
      register int fd;
      register file *fp;
  if(*mode !='r'&&*mode !='w'&&*mode !='a') {
      fprintf(stderr,"illegal mode %s opening %s\n",
     mode,name);
      exit(1);
  }
  for (fp=_iob;fp&lt;_iob+_nfile;fp++)
      if((fp-&gt;_flag & (_READ | _WRITE))==0)
     break; /*found free slot*/
  if(fp&gt;=_iob+_nfile) /*no free slots*/
      return(NULL);
  if(*mode=='w') /*access file*/
      fd=creat(name,pmode);
  else if(*mode=='a') {
      if((fd=open(name,1))==-1)
     fd=creat(name,pmode);
      lseek(fd,OL,2);
  } else
      fd=open(name,0);
  if(fd==-1) /*couldn't access name*/
      return(NULL);
  fp-&gt;_fd=fd;
  fp-&gt;_cnt=0;
  fp-&gt;_base=NULL;
  fp-&gt;_flag &=(_READ | _WRITE);
  fp-&gt;_flag |=(*mode=='r') ? _READ : _WRITE;
  return(fp);
  }        
</pre>
<p>     Функция _filebuf несколько более сложная. Основная трудность заключается в том, что _filebuf стремится разрешить доступ к файлу и в том случае, когда может не оказаться достаточно места в памяти для буферизации ввода или вывода. если пространство для нового буфера может быть получено обращением к функции calloc, то все отлично; если же нет, то _filebuf осуществляет небуферизованный ввод/ вывод, используя отдельный символ, помещенный в локальном массиве.
<pre> 
   #include  &lt;stdio.h&gt;
   _fillbuf(fp) /*allocate and fill input buffer*/
   register file *fp;
    {
   static char smallbuf(nfile);/*for unbuffered 1/0*/
    char *calloc();
  if((fr-&gt;_flag&_READ)==0||(fp-&gt;_flag&(EOF|_ERR))|=0
     return(EOF);
  while(fp-&gt;_base==NULL) /*find buffer space*/
     if(fp-&gt;_flag & _UNBUF) /*unbuffered*/
    fp-&gt;_base=&smallbuf[fp-&gt;_fd];
     else if((fp-&gt;_base=calloc(_BUFSIZE,1))==NULL)
     fp-&gt;_flag |=_UNBUF; /*can't get big buf*/
     else
     fp-&gt;_flag |=_BIGBUF; /*got big one*/
  fp-&gt;_ptr=fp-&gt;_base;
  fp-&gt;_cnt=read(fp-&gt;_fd, fp-&gt;_ptr,
     fp-&gt;_flag & _UNBUF ? 1 : _BUFSIZE);
  FF(--fp-&gt;_cnt&lt;0) {
     if(fp-&gt;_cnt== -1)
     fp-&gt;_flag | = _EOF;
     else
     fp-&gt;_flag | = _ ERR;
     fp-&gt;_cnt = 0;
     return(EOF);
      }
      return(*fp-&gt;_ptr++ & 0377); /*make char positive*/
   )
</pre> 
<p> При первом обращении к getc для конкретного файла счетчик оказывается равным нулю, что приводит к обращению к _filebuf. Если функция _filebuf найдет, что этот файл не открыт для чтения, она немедленно возвращает EOF. В противном случае она пытается выделить большой буфер, а если ей это не удается, то буфер из одного символа. При этом она заносит в _flag соответствующую информацию о буферизации.
<p>     Раз буфер уже создан, функция _filebuf просто вызывает функцию read для его заполнения, устанавливает счетчик и указатели и возвращает символ из начала буфера.
<p>     Единственный оставшийся невыясненным вопрос состоит в том, как все начинается. Массив _iob должен быть определен и инициализирован для stdin, stdout и stderr:
<pre>     
   file _iob[nfile] = {
  (NULL,0,_READ,0), /*stdin*/
  (NULL,0,NULL,1),  /*stdout*/
  (NULL,0,NULL,_WRITE | _UNBUF,2) /*stderr*/
);
</pre> 
<p> Из инициализации части _flag этого массива структур видно, что файл stdin предназначен для чтения, файл stdout - для записи и файл stderr - для записи без использования буфера.


<p><b><i>     Упражнение 8-3. </i></b></p>
<p>     Перепишите функции fopen и _filebuf, используя поля вместо явных побитовых операций.

<p><b><i>     Упражнение 8-4. </i></b></p>
<p>     Разработайте и напишите функции _flushbuf и fclose.

<p><b><i>     Упражнение 8-5. </i></b></p>
<p>     Стандартная библиотека содержит функцию
<pre> 
   fseek(fp, offset, origin)
</pre> 
 которая идентична функции lseek, исключая то, что fp является указателем файла, а не дескриптором файла. Напишите fseek. Убедитесь, что ваша fseek правильно согласуется с буферизацией, сделанной для других функций библиотеки.
 
<a name=86>
<h3>     8.6. Пример - распечатка справочников</h3>
<p>     Иногда требуется другой вид взаимодействия с системой файлов - определение информации о файле, а не того, что в нем содержится. Примером может служить команда ls ("список справочника") системы UNIX. По этой команде распечатываются имена файлов из справочника и, необязательно, другая информация, такая как размеры, разрешения и т.д.
<p>     Поскольку, по крайней мере, на системе UNIX справочник является просто файлом, то в такой команде, как ls нет ничего особенного; она читает файл и выделяет нужные части из находящейся там информации. Однако формат информации определяется системой, так что ls должна знать, в каком виде все представляется в системе.
<p>     Мы это частично проиллюстрируем при написании программы fsize. Программа fsize представляет собой специальную форму ls, которая печатает размеры всех файлов, указанных в списке ее аргументов. Если один из файлов является справочником, то для обработки этого справочника программа fsize обращается сама к себе рекурсивно. если же аргументы вообще отсутствуют, то обрабатывается текущий справочник.
<p>     Для начала дадим краткий обзор структуры системы файлов. Справочник - это файл, который содержит список имен файлов и некоторое указание о том, где они размещаются. Фактически это указание является индексом для другой таблицы, которую называют "i - узловой таблицей". Для файла i-узел - это то, где содержится вся информация о файле, за исключением его имени. Запись в справочнике состоит только из двух элементов: номера i-узла и имени файла. Точная спецификация поступает при включении файла sys/dir.h, который содержит
<pre> 
   #define DIRSIZ 14 /*max length of file name*/
   struct direct /*structure of directory entry*/
   {
  ino_t&_ino; /*inode number*/
  char &_name[DIRSIZ]; /*file name*/
   };
</pre> 
<p>     "Тип" ino_t - это определяемый посредством typedef тип, который описывает индекс i-узловой таблицы. На PDP-11 UNIX этим типом оказывается unsigned, но это не тот сорт информации, который помещают внутрь программы: на разных системах этот тип может быть различным. Поэтому и следует использовать typedef. Полный набор "системных" типов находится в файле sys/types.h.
<p>     Функция stat берет имя файла и возвращает всю содержащуюся в i-ом узле информацию об этом файле (или -1, если имеется ошибка). Таким образом, в результате
<pre> 
   struct stat stbuf;
   char *name;
   stat(name,&stbuf);
</pre> 
структура stbuf наполняется информацией из i-го узла о файле с именем name. Структура, описывающая возвращаемую функцией stat информацию, находится в файле sys/stat.h и выглядит следующим образом:
<pre> 
   struct stat /*structure returned by stat*/
   {
     dev_t st_dev;   /* device of inode */
     ino_t st_ino;   /* inode number */
     short st_mode   /* mode bits */
     short st_nlink; / *number of links to file */
     short st_uid;   /* owner's user ID */
     short st_gid;   /* owner's group ID */
     dev_t st_rdef;  /* for special files */
     OFF_t st_size;  /* file size in characters */
     time_t st_atime; /* time last accessed */
     time_t st_mtime; /* time last modified */
     time_t st_cmtime; /* time originally created */
   }
</pre> 
<p> Большая часть этой информации объясняется в комментариях. Элемент st.mode содержит набор флагов, описывающих файл; для удобства определения флагов также находятся в файле sys/stat.h.
<pre>      
  #define S_IFMT    0160000 /* type of file */
  #define S_IFDIR   0040000 /* directory */
  #define S_IFCHR   0020000 /* character special */
  #define S_IFBLK   0060000 /* block special */
  #define S_IFREG   0100000 /* regular */
  #define S_ISUID   04000   /* set user ID on execution */
  #define S_ISGID   02000   /* set group ID on execution */
  #define S_ISVTX   01000   /*save swapped text after use*/
  #define S_IREAD   0400    /* read permission */
  #define S_IWRITE  0200    /* write permission */
  #define S_IEXEC   0100    /* execute permission */
</pre> 
<p>     Теперь мы в состоянии написать программу fsize. Если полученный от функции stat режим указывает, что файл не является справочником, то его размер уже под рукой и может быть напечатан непосредственно. Если же он оказывается справочником, то мы должны обрабатывать этот справочник отдельно для каждого файла; так как справочник может в свою очередь содержать подсправочники, этот процесс обработки является рекурсивным.
<p>     Как обычно, ведущая программа главным образом имеет дело с командной строкой аргументов; она передает каждый аргумент функции fsize в большой буфер.
<pre> 
#include &lt;stdio.h.&gt;
#include &lt;sys/types.h&gt; /* typedefs */
#include &lt;sys/dir.h&gt;   /*directory entry structure*/
#include &lt;sys/stat.h&gt;  /*structure returned by stat*/
#define BUFSIZE  256
main(argc,argv) /*fsize:print file sizes */
char *argv[];
{
   char buf[BUFSIZE];
   if(argc==1) { /* default: current directory */
  strcpy(buf,".");
  fsize(buf);
   } else
  while(--argc&gt;0) {
     strcpy(buf,*++argv);
     fsize(buf);
  }
}
</pre> 
<p>     Функция fsize печатает размер файла. Если однако файл оказывается справочником, то fsize сначала вызывает функцию directory для обработки всех указанных в нем файлов. Обратите внимание на использование имен флагов S_IFMT и S_IFDIR из файла stat.h.
<pre> 
  fsize(name) /*print size for name*/
  char *name;
  {
      struct stat stbuf;
      if(stat(name,&stbuf)== -1) {
  fprintf(stderr,"fsize:can't find %s\n",name);
  return;
  }
  if((stbuf.st_mode & S_IFMT)==S_IFDIR)
        directory(name);
  printf("%8ld %s\n",stbuf.st_size,name);
}
</pre>
<p>     Функция directory является самой сложной. Однако значительная ее часть связана с созданием для обрабатываемого в данный момент файла его полного имени, по которому можно восстановить путь в дереве.
<pre> 
  directory(name)    /*fsize for all files in name*/
  char *name;
   (
     struct direct dirbuf;
     char *nbp, *nep;
     int i, fd;
     nbp=name+strlen(name);
     *nbp++='/'; /*add slash to directory name*/
     if(nbp+DIRSIZ+2&gt;=name+BUFSIZE) /*name too long*/
    return;
     if((fd=open(name,0))== -1)
    return;
     while(read(fd,(char *)&dirbuf,sizeof(dirbuf))&gt;0) {
    if(dirbuf.d_ino==0) /*slot not in use*/
    continue;
    if(strcmp(dirbuf.d_name,".")==0
      || strcmp(dirbuf.d_name,"..")==0 )
      continue; /*skip self and parent*/
    for (i=0,nep=nbp;i&lt;DIRSIZ;i++)
    *nep++=dirbuf.d_name[i];
    *nep++='\0';
    fsize(name);
     }
     close(fd);
     *--nbp='\0'; /*restore name*/
   )
</pre> 
<p>     Если некоторая дыра в справочнике в настоящее время не используется (потому что файл был удален), то в соответствующее i-узловое число равно нулю, и эта позиция пропускается. Каждый справочник также содержит запись в самом себе, называемую ".", и о своем родителе, ".."; они, очевидно, также должны быть пропущены, а то программа будет работать весьма и весьма долго.
<p>     Хотя программа fsize довольно специализированна, она все же демонстрирует пару важных идей. во-первых, многие программы не являются "системными программами"; они только используют информацию, форма или содержание которой определяется операционной системой. Во-вторых, для таких программ существенно, что представление этой информации входит только в стандартные "заголовочные файлы", такие как stat.h и dir.h, и что программы включают эти файлы, а не помещают фактические описания внутрь самих программ.
 
<a name=87>
<h3>     8.7. Пример - распределитель памяти. </h3>
<p>     В главе 5 мы написали бесхитростный вариант функции alloc. Вариант, который мы напишем теперь, не содержит ограничений: обращения к функциям alloc и free могут перемежаться в любом порядке; когда это необходимо, функция alloc обращается к операционной системе за дополнительной памятью. Кроме того, что эти процедуры полезны сами по себе, они также иллюстрируют некоторые соображения, связанные с написанием машинно-зависимых программ относительно машинно-независимым образом, и показывают практическое применение структур, объединений и конструкций typedef.
<p>     Вместо того, чтобы выделять память из скомпилированного внутри массива фиксированного размера, функция alloc будет по мере необходимости обращаться за памятью к операционной системе. Поскольку различные события в программе могут требовать асинхронного выделения памяти, то память, управляемая alloc, не может быть непрерывной. В силу этого свободная память хранится в виде цепочки свободных блоков. Каждый блок включает размер, указатель следующего блока и саму свободную память. Блоки упорядочиваются в порядке возрастания адресов памяти, причем последний блок (с наибольшим адресом) указывает на первый, так что цепочка фактически оказывается кольцом.
<p>     При поступлении запроса список свободных блоков просматривается до тех пор, пока не будет найден достаточно большой блок. Если этот блок имеет в точности требуемый размер, то он отцепляется от списка и передается пользователю. Если же этот блок слишком велик, то он разделяется, нужное количество передается пользователю, а остаток возвращается в свободный список. Если достаточно большого блока найти не удается, то операционной системой выделяется новый блок, который включается в список свободных блоков; затем поиск возобновляется.
<p>     Освобождение памяти также влечет за собой просмотр свободного списка в поиске подходящего места для введения освобожденного блока. Если этот освободившийся блок с какой-либо стороны примыкает к блоку из списка свободных блоков, то они объединяются в один блок большего размера, так что память не становится слишком раздробленной. Обнаружить смежные блоки просто, потому что свободный список содержится в порядке возрастания адресов.
<p>     Одна из проблем, о которой мы упоминали в главе 5, заключается в обеспечении того, чтобы возвращаемая функцией alloc память была выровнена подходящим образом для тех объектов, которые будут в ней храниться. Хотя машины и различаются, для каждой машины существует тип, требующий наибольших ограничений по размещению памяти, если данные самого ограничительного типа можно поместить в некоторый определенный адрес, то это же возможно и для всех остальных типов. Например, на IBM 360/370,HONEYWELL 6000 и многих других машинах любой объект может храниться в границах, соответствующим переменным типа double; на PDP-11 будут достаточны переменные типа int.
<p>     Свободный блок содержит указатель следующего блока в цепочке, запись о размере блока и само свободное пространство; управляющая информация в начале называется заголовком. Для упрощения выравнивания все блоки кратны размеру заголовка, а сам заголовок выровнен надлежащим образом. Это достигается с помощью объединения, которое содержит желаемую структуру заголовка и образец наиболее ограничительного по выравниванию типа:
<pre> 
 typedef int align; /*forces alignment on PDP-11*/
 union header { /*free block header*/
    struct {
    union header *ptr; /*next free block*/
    unsigned size; /*size of this free block*/
    } s;
    align  x; /*force alignment of blocks*/
 };
 typedef union header header;
</pre> 
<p>     Функция alloc округляет требуемый размер в символах до нужного числа единиц размера заголовка; фактический блок, который будет выделен, содержит на одну единицу больше, предназначаемую для самого заголовка, и это и есть значение, которое записывается в поле size заголовка. Указатель, возвращаемый функцией alloc, указывает на свободное пространство, а не на сам заголовок.
<pre> 
 static header base; /*empty list to get started*/
 static header *allocp=NULL; /*last allocated block*/
 char *alloc(nbytes)/*general-purpose storage allocator*/
 unsigned nbytes;
 {
    header *morecore();
    register header *p, *g;
    register int nunits;
    nunits=1+(nbytes+sizeof(header)-1)/sizeof(header);
    if ((g=allocp)==NULL) { /*no free list yet*/
 base.s ptr=allocp=g=&base;
 base.s.size=0;
    }
    for (p=g&gt;s.ptr; ; g=p, p=p-&gt;s.ptr) {
 if (p-&gt;s.size&gt;=nunits) { /*big enough*/
     if (p-&gt;s.size==nunits) /*exactly*/
    g-&gt;s.ptr=p-&gt;s.ptr;
     else { /*allocate tail end*/
    p-&gt;s.size-=nunits;
    p+=p-&gt;s.size;
    p-&gt;s.size=nunits;
     }
     allocp=g;
     return((char *)(p+1));
  }
  if(p==allocp) /*wrapped around free list*/
      if((p=morecore(nunits))==NULL)
     return(NULL); /*none left*/
  }
     }
</pre> 
<p>     Переменная base используется для начала работы. Если allocp имеет значение NULL, как в случае первого обращения к alloc, то создается вырожденный свободный список: он состоит из свободного блока размера нуль и указателя на самого себя. В любом случае затем исследуется свободный список. Поиск свободного блока подходящего размера начинается с того места (allocp), где был найден последний блок; такая стратегия помогает сохранить однородность диска. Если найден слишком большой блок, то пользователю предлагается его хвостовая часть; это приводит к тому, что в заголовке исходного блока нужно изменить только его размер. Во всех случаях возвращаемый пользователю указатель указывает на действительно свободную область, лежащую на единицу дальше заголовка. Обратите внимание на то, что функция alloc перед возвращением "p" преобразует его в указатель на символы.
<p>     Функция morecore получает память от операционной системы. Детали того, как это осуществляется, меняются, конечно, от системы к системе. На системе UNIX точка входа sbrk(n) возвращает указатель на "n" дополнительных байтов памяти.(указатель удовлетворяет всем ограничениям на выравнивание). Так как запрос к системе на выделение памяти является сравнительно дорогой операцией, мы не хотим делать это при каждом обращении к функции alloc. Поэтому функция morecore округляет затребованное число единиц до большего значения; этот больший блок будет затем разделен так, как необходимо. Масштабирующая величина является параметром, который может быть подобран в соответствии с необходимостью.
<pre>     
  #define NALLOC 128 /*#units to allocate at once*/
  static header *morecore(nu) /*ask system for memory*/
  unsigned nu;
  {
     char *sbrk();
     register char *cp;
     register header *up;
     register int rnu;
     rnu=NALLOC*((nu+NALLOC-1)/NALLOC);
     cp=sbrk(rnu*sizeof(header));
     if ((int)cp==-1) /*no space at all*/
        return(NULL);
     up=(header *)cp;
     up-&gt;s.size=rnu;
     free((char *)(up+1));
     return(allocp);
  }
</pre> 
<p>     Если больше не осталось свободного пространства, то функция sbrk возвращает "-1", хотя NULL был бы лучшим выбором. Для надежности сравнения "-1" должна быть преобразована к типу int. Снова приходится многократно использовать явные преобразования (перевод) типов, чтобы обеспечить определенную независимость функций от деталей представления указателей на различных машинах.
<p>     И последнее - сама функция free. Начиная с allocp, она просто просматривает свободный список в поиске места для введения свободного блока. Это место находится либо между двумя существующими блоками, либо в одном из концов списка. В любом случае, если освободившийся блок примыкает к одному из соседних, смежные блоки объединяются. Следить нужно только затем, чтобы указатели указывали на то, что нужно, и чтобы размеры были установлены правильно.
<pre> 
 free(ap) /*put block ap in free list*/
 char *ap;
 {
    register header *p, *g;
    p=(header*)ap-1; /*point to header*/
    for (g=allocp; !(p&gt;g && p&gt;g-&gt;s.ptr);g=g-&gt;s.ptr)
 if (g&gt;=g-&gt;s.ptr && (p&gt;g || p&lt;g-&gt;s.ptr))
     break; /*at one end or other*/
 if (p+p-&gt;s.size==g-&gt;s.ptr){/*join to upper nbr*/
     p-&gt;s.size += g-&gt;s.ptr-&gt;s.size;
     p-&gt;s.ptr = g-&gt;s.ptr-&gt;s.ptr;
 } else
     p-&gt;s.ptr = g-&gt;s.ptr;
 if (g+g-&gt;s.size==p) { /*join to lower nbr*/
     g-&gt;s.size+=p-&gt;s.size;
     g-&gt;s.ptr=p-&gt;s.ptr;
 } else
     g-&gt;s.ptr=p;
 allocp = g;
    }      
</pre>
<p>     Хотя распределение памяти по своей сути зависит от используемой машины, приведенная выше программа показывает, как эту зависимость можно регулировать и ограничить весьма небольшой частью программы. Использование typedef и union позволяет справиться с выравниванием (при условии, что функция sbrk обеспечивает подходящий указатель). Переводы типов организуют выполнение явного преобразования типов и даже справляются с неудачно разработанным системным интерфейсом. И хотя рассмотренные здесь подробности связаны с распределением памяти, общий подход равным образом применим и к другим ситуациям.

<p><b><i>     Упражнение 8-6. </i></b></p>
<p>     Функция из стандартной библиотеки calloc(n,size) возвращает указатель на "n" объектов размера size, причем соответствующая память инициализируется на нуль. напишите программу для calloc, используя функцию alloc либо в качестве образца, либо как функцию, к которой происходит обращение.

<p><b><i>     Упражнение 8-7. </i></b></p>
<p>     Функция alloc принимает затребованный размер, не проверяя его правдоподобности; функция free полагает, что тот блок, который она должна освободить, содержит правильное значение в поле размера. Усовершенствуйте эти процедуры, затратив больше усилий на проверку ошибок.

<p><b><i>     Упражнение 8-8. </i></b></p>
<p>     Напишите функцию bfree(p,n), которая включает произвольный блок "p" из "n" символов в список свободных блоков, управляемый функциями alloc и free. С помощью функции bfree пользователь может в любое время добавлять в свободный список статический или внешний массив.
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_7.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_9.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>