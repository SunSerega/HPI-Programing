<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Керниган и Ритчи </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://kulichki.rambler.ru/moshkow/  -->
<!-- Owner: Alexander S. Derevjanko (web-design only)-->
<!-- ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_2.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_4.html>Вперед</a></td></tr>

</table>
</p>
<hr>
<h2>3. Поток управления</h2>
          
<p>      Управляющие операторы языка определяют порядок вычислений. В приведенных ранее примерах мы уже встречались с наиболее употребительными управляющими конструкциями языка "C"; здесь мы опишем остальные операторы управления и уточним действия операторов, обсуждавшихся ранее.
 
<a name=31>
<h3>      3.1. Операторы и блоки</h3>
      
<p>      Такие выражения, как x=0, или i++, или printf(...), становятся операторами, если за ними следует точка с запятой, как, например,
<pre> 
     x = 0;
     i++;
     printf(...);
</pre>  
<p>В языке "C" точка с запятой является признаком конца оператора, а не разделителем операторов, как в языках типа Алгола.
<p>     Фигурные скобки { и } используются для объединения описаний и операторов в составной оператор или блок, так что они оказываются синтаксически эквивалентны одному оператору. Один явный пример такого типа дают фигурные скобки, в которые заключаются операторы, составляющие функцию, другой - фигурные скобки вокруг группы операторов в конструкциях if, else, while и for.(на самом деле переменные могут быть описаны внутри любого блока; мы поговорим об этом в главе 4). Точка с запятой никогда не ставится после первой фигурной скобки, которая завершает блок.

<a name=32> 
<h3>      3.2. if - else</h3>
 
     Оператор if - else используется при необходимости сделать выбор. Формально синтаксис имеет вид
 <pre> 
     if  (выражение)
             оператор-1
     else
             оператор-2,
</pre>  
<p>     Где часть else является необязательной. Сначала вычисляется выражение; если оно "истинно" (т.е. значение выражения отлично от нуля), то выполняется оператор-1. Если оно ложно (значение выражения равно нулю), и если есть часть с else, то вместо оператора-1 выполняется оператор-2.
<p>     Так как if просто проверяет численное значение выражения, то возможно некоторое сокращение записи. Самой очевидной возможностью является запись
<pre>  
    if  (выражение)
</pre> 
 вместо
<pre> 
    if  (выражение !=0)
</pre> 
 
Иногда такая запись является ясной и естественной, но временами она становится загадочной.
<p>     То, что часть else в конструкции if - else является необязательной, приводит к двусмысленности в случае, когда else опускается во вложенной последовательности операторов if. Эта неоднозначность разрешается обычным образом - else связывается с ближайшим предыдущим if, не содержащим else. Например, в
<pre>  
 if ( n &gt; 0 )
    if( a &gt; b )
            z = a;
    else
            z = b;
</pre>  
конструкция else относится к внутреннему if, как мы и показали, сдвинув else под соответствующий if. Если это не то, что вы хотите, то для получения нужного соответствия необходимо использовать фигурные скобки:
<pre>  
 if (n &gt; 0)      {
    if (a &gt; b)
            z = a;
 }
 else
    z = b;
</pre>  
 
<p>     Tакая двусмысленность особенно пагубна в ситуациях типа
<pre>  
 if (n &gt; 0)
    for (i = 0; i &lt; n; i++)
            if (s[i] &gt; 0) {
     printf("...");
     return(i);
            }
 else   /* wrong */
    printf("ERROR - n is zero\n");
</pre>            
Запись else под if ясно показывает, чего вы хотите, но компилятор не получит соответствующего указания и свяжет else с внутренним if. Ошибки такого рода очень трудно обнаруживаются.
<p>      Между прочим, обратите внимание, что в
<pre>  
  if (a &gt; b)
     z = a;
  else
     z = b;
</pre>  
после z=a стоит точка с запятой. Дело в том, что согласно грамматическим правилам за if должен следовать оператор, а выражение типа z=a, являющееся оператором, всегда заканчивается точкой с запятой.
 
<a name=33>
<h3>      3.3. else - if</h3>
      
<p>      Конструкция
<pre>  
  if (выражение)
     оператор
  else    if (выражение)
             оператор
  else    if (выражение)
             оператор
  else
     оператор
</pre>  
встречается настолько часто, что заслуживает отдельного краткого рассмотрения. Такая последовательность операторов if является наиболее распространенным способом программирования выбора из нескольких возможных вариантов. выражения просматриваются последовательно; если какое-то выражение оказывается истинным, то выполняется относящийся к нему оператор, и этим вся цепочка заканчивается. Каждый оператор может быть либо отдельным оператором, либо группой операторов в фигурных скобках.
<p>     Последняя часть с else имеет дело со случаем, когда ни одно из проверяемых условий не выполняется. Иногда при этом не надо предпринимать никаких явных действий; в этом случае хвост
 <pre> 
    else
       оператор
</pre>  
может быть опущен, или его можно использовать для контроля, чтобы засечь "невозможное" условие.
<p>     Для иллюстрации выбора из трех возможных вариантов приведем программу функции, которая методом половинного деления определяет, находится ли данное значение х в отсортированном массиве v. Элементы массива v должны быть расположены в порядке возрастания. Функция возвращает номер позиции (число между 0 и n-1), в которой значение х находится в v, и -1, если х не содержится в v.
<pre>  
 binary(x, v, n) /* find x in v[0]...v[n-1] */
 int x, v[], n;
 {
    int low, high, mid;
 
    low = 0;
    high = n - 1;
    while (low &lt;= high) {
            mid = (low + high) / 2;
            if (x &lt; v[mid])
     high = mid - 1;
            else if (x &gt; v[mid])
     low = mid + 1;
            else   /* found match */
     return(mid);
    }
    return(-1);
 }
</pre>  
<p>     Основной частью каждого шага алгоритма является проверка, будет ли х меньше, больше или равен среднему элементу v[mid]; использование конструкции else - if здесь вполне естественно.
     
<a name=34>
<h3>      3.4. Переключатель</h3>
 
<p>     Оператор switch дает специальный способ выбора одного из многих вариантов, который заключается в проверке совпадения значения данного выражения с одной из заданных констант и соответствующем ветвлении. В главе 1 мы привели программу подсчета числа вхождений каждой цифры, символов пустых промежутков и всех остальных символов, использующую последовательность if...else if...else. Вот та же самая программа с переключателем.
<pre>      
 main() /* count digits,white space, others */
 {
    int c, i, nwhite, nother, ndigit[10];
 
    nwhite = nother = 0;
    for (i = 0; i &lt; 10; i++)
            ndigit[i] = 0;
 
    while ((c = getchar()) != EOF)
             switch(c) {
             case '0':
             case '1':
             case '2':
             case '3':
             case '4':
             case '5':
             case '6':
             case '7':
             case '8':
             case '9':
      ndigit[c-'0']++;
      break;
             case ' ':
             case '\n':
             case '\t':
      nwhite++;
      break;
             default :
      nother++;
      break;
             }
     printf("digits =");
     for (i = 0; i &lt; 10; i++)
             printf(" %d", ndigit[i]);
     printf("\nwhite space = %d, other = %d\n",
             nwhite, nother);
</pre> 
<p>     Переключатель вычисляет целое выражение в круглых скобках (в данной программе - значение символа с) и сравнивает его значение со всеми случаями (case). Каждый случай должен быть помечен либо целым, либо символьной константой, либо константным выражением. Если значение константного выражения, стоящего после вариантного префикса case, совпадает со значением целого выражения, то выполнение начинается с этого случая. Если ни один из случаев не подходит, то выполняется оператор после префикса default. Префикс default является необязательным ,если его нет, и ни один из случаев не подходит, то вообще никакие действия не выполняются. Случаи и выбор по умолчанию могут располагаться в любом порядке. Все случаи должны быть различными.
<p>     Оператор break приводит к немедленному выходу из переключателя. Поскольку случаи служат только в качестве меток, то если вы не предпримите явных действий после выполнения операторов, соответствующих одному случаю, вы провалитесь на следующий случай. Операторы break и return являются самым обычным способом выхода из переключателя. Как мы обсудим позже в этой главе, оператор break можно использовать и для немедленного выхода из операторов цикла while, for и do.
<p>     Проваливание сквозь случаи имеет как свои достоинства, так и недостатки. К положительным качествам можно отнести то, что оно позволяет связать несколько случаев с одним действием, как было с пробелом, табуляцией и новой строкой в нашем примере. Но в то же время оно обычно приводит к необходимости заканчивать каждый случай оператором break, чтобы избежать перехода к следующему случаю. Проваливание с одного случая на другой обычно бывает неустойчивым, так как оно склонно к расщеплению при модификации программы. За исключением, когда одному вычислению соответствуют несколько меток, проваливание следует использовать умеренно.
<p>     Заведите привычку ставить оператор break после последнего случая (в данном примере после default), даже если это не является логически необходимым. В один прекрасный день, когда вы добавите в конец еще один случай, эта маленькая мера предосторожности избавит вас от неприятностей.

<p><b><i>     Упражнение 3-1.</i></b></p>
<p>     Напишите программу для функции expand(s, t), которая копирует строку s в t, заменяя при этом символы табуляции и новой строки на видимые условные последовательности, как \n и \t, используйте переключатель.
 
<a name=35>
<h3>      3.5. Циклы - while и for</h3>
 
<p>     Мы уже сталкивались с операторами цикла while и for. В конструкции
<pre>  
 while (выражение)
    оператор
</pre>  
вычисляется выражение. Если его значение отлично от нуля, то выполняется оператор и выражение вычисляется снова. Этот цикл продолжается до тех пор, пока значение выражения не станет нулем, после чего выполнение программы продолжается с места после оператора.
 
<p>    Оператор
<pre>  
 for (выражение 1; выражение 2; выражение 3)
    оператор
</pre>      
эквивалентен последовательности
<pre>  
 выражение 1;
 while (выражение 2) {
    оператор
    выражение 3;
 }
</pre>  
<p>Грамматически все три компонента в for являются выражениями. наиболее распространенным является случай, когда выражение 1 и выражение 3 являются присваиваниями или обращениями к функциям, а выражение 2 - условным выражением. Любая из трех частей может быть опущена, хотя точки с запятой при этом должны оставаться. Если отсутствует выражение 1 или выражение 3, то оно просто выпадает из расширения. Если же отсутствует проверка, выражение 2, то считается, как будто оно всегда истинно, так что
<pre>  
  for (;;)        {
     ...
  }
</pre>  
является бесконечным циклом, о котором предполагается, что он будет прерван другими средствами (такими как break или return).
      Использовать ли while или for - это, в основном дело
 вкуса. Например в
<pre>  
 while ((c = getchar())== ' ' 
    || c == '\n' || c == '\t');    
         /* skip white space characters */
</pre>  
нет ни инициализации, ни реинициализации, так что цикл while выглядит самым естественным.
<p>     Цикл for, очевидно, предпочтительнее там, где имеется простая инициализация и реинициализация, поскольку при этом управляющие циклом операторы наглядным образом оказываются вместе в начале цикла. Это наиболее очевидно в конструкции
<pre>  
  for (i = 0; i &lt; n; i++)
</pre>  
которая является идиомой языка "C" для обработки первых n элементов массива, аналогичной оператору цикла do в Фортране и PL/1. Аналогия, однако, не полная, так как границы цикла могут быть изменены внутри цикла, а управляющая переменная сохраняет свое значение после выхода из цикла, какова бы ни была причина этого выхода. Поскольку компонентами for могут быть произвольные выражения, они не ограничиваются только арифметическими прогрессиями. Тем не менее является плохим стилем включать в for вычисления, которые не относятся к управлению циклом, лучше поместить их в управляемые циклом операторы.
<p>     В качестве большего по размеру примера приведем другой вариант функции atoi, преобразующей строку в ее численный эквивалент. Этот вариант является более общим; он допускает присутствие в начале символов пустых промежутков и знака + или -. (В главе 4 приведена функция atof, которая выполняет то же самое преобразование для чисел с плавающей точкой).
<p>     Общая схема программы отражает форму поступающих данных:
 <ul>
 <li>пропустить пустой промежуток, если он имеется
 <li>извлечь знак, если он имеется
<li>извлечь целую часть и преобразовать ее
</ul> 
<p> Каждый шаг выполняет свою часть работы и оставляет все в подготовленном состоянии для следующей части. Весь процесс заканчивается на первом символе, который не может быть частью числа.
<pre>  
 atoi(s)   /* convert s to integer */
 char s[];
 {
 int i, n, sign;
 for(i=0; s[i]==' ' ||
          s[i]=='\n' || s[i]=='\t';i++)
    ; /* skip white space */
 sign = 1;
 if(s[i] == '+' || s[i] == '-')  /* sign */
    sign = (s[i++]=='+') ? 1 : - 1;
 for( n = 0; s[i] &gt;= '0' && s[i] &lt;= '9'; i++)
    n = 10 * n + s[i] - '0';
 return(sign * n);
 }
</pre>  
<p>     Преимущества централизации управления циклом становятся еще более очевидными, когда имеется несколько вложенных циклов. Следующая функция сортирует массив целых чисел по методу Шелла. Основная идея сортировки по Шеллу заключается в том, что сначала сравниваются удаленные элементы, а не смежные, как в обычном методе сортировки. Это приводит к быстрому устранению большой части неупорядоченности и сокращает последующую работу. Интервал между элементами постепенно сокращается до единицы, когда сортировка фактически превращается в метод перестановки соседних элементов.
<pre>      
 shell(v, n)   /* sort v[0]...v[n-1]
                into increasing order */
 int v[], n;
 {
   int gap, i, j, temp;
 
   for (gap = n/2; gap &gt; 0; gap /= 2)
      for (i = gap; i &lt; n; i++)
   for (j=i-gap; j&gt;=0 && v[j]&gt;v[j+gap]; j-=gap) {
    temp = v[j];
    v[j] = v[j+gap];
    v[j+gap] = temp;
   }
 }
</pre>           
<p>Здесь имеются три вложенных цикла. Самый внешний цикл управляет интервалом между сравниваемыми элементами, уменьшая его от n/2 вдвое при каждом проходе, пока он не станет равным нулю. Средний цикл сравнивает каждую пару элементов, разделенных на величину интервала; самый внутренний цикл переставляет любую неупорядоченную пару. Так как интервал в конце концов сводится к единице, все элементы в результате упорядочиваются правильно. Отметим, что в силу общности конструкции for внешний цикл укладывается в ту же самую форму, что и остальные, хотя он и не является арифметической прогрессией.
<p>     Последней операцией языка "C" является запятая ",", которая чаще всего используется в операторе for. Два выражения, разделенные запятой, вычисляются слева направо, причем типом и значением результата являются тип и значение правого операнда. Таким образом, в различные части оператора for можно включить несколько выражений, например, для параллельного изменения двух индексов. Это иллюстрируется функцией reverse(s), которая располагает строку s в обратном порядке на том же месте.
<pre>  
  reverse(s)    /* reverse string s in place */
  char s[];
  {
  int c, i, j;
 
  for(i = 0, j = strlen(s) - 1; i &lt; j; i++, j--)  {
     c = s[i];
     s[i] = s[j];
     s[j] = c;
  }
  }
</pre>  
<p> Запятые, которые разделяют аргументы функций, переменные в описаниях и т.д., не имеют отношения к операции запятая и не обеспечивают вычислений слева направо.
     
<p><b><i>     Упражнение 3-2.</i></b></p>
<p>     Составьте программу для функции expand(s1,s2), которая расширяет сокращенные обозначения вида а-z из строки s1 в эквивалентный полный список авс...xyz в s2. Допускаются сокращения для строчных и прописных букв и цифр. Будьте готовы иметь дело со случаями типа а-b-c, а-z0-9 и -а-z. (Полезное соглашение состоит в том, что символ -, стоящий в начале или конце, воспринимается буквально).
 
<a name=36>
<h3>      3.6. Цикл do - while</h3>
 
<p>     Как уже отмечалось в главе 1, циклы while и for обладают тем приятным свойством, что в них проверка окончания осуществляется в начале, а не в конце цикла. Третий оператор цикла языка "C", do-while, проверяет условие окончания в конце, после каждого прохода через тело цикла; тело цикла всегда выполняется по крайней мере один раз. Синтаксис этого оператора имеет вид:
<pre>  
   do
      оператор
   while (выражение)
</pre>  
<p> Сначала выполняется оператор, затем вычисляется выражение. Если оно истинно, то оператор выполняется снова и т.д. Если выражение становится ложным, цикл заканчивается.
 
<p>     Как и можно было ожидать, цикл do-while используется значительно реже, чем while и for, составляя примерно пять процентов от всех циклов. Тем не менее, иногда он оказывается полезным, как, например, в следующей функции itoa, которая преобразует число в символьную строку (обратная функции atoi). Эта задача оказывается несколько более сложной, чем может показаться сначала. Дело в том, что простые методы выделения цифр генерируют их в неправильном порядке. Мы предпочли получить строку в обратном порядке, а затем обратить ее.
<pre>      
 itoa(n,s)   /*convert n to characters in s */
 char s[];
 int n;
 {
 int i, sign;
 
 if ((sign = n) &lt; 0)   /* record sign */
    n = -n;     /* make n positive */
 i = 0;
 do {    /* generate digits in reverse order */
    s[i++] = n % 10 + '0';/* get next digit */
 }   while ((n /=10) &gt; 0); /* delete it */
 if (sign &lt; 0)
    s[i++] = '-'
 s[i] = '\0';
 reverse(s);
 }
</pre>  
<p> Цикл do-while здесь необходим, или по крайней мере удобен, поскольку, каково бы ни было значение n, массив s должен содержать хотя бы один символ. Мы заключили в фигурные скобки один оператор, составляющий тело do-while, хотя это и не обязательно, для того, чтобы торопливый читатель не принял часть while за начало оператора цикла while.

<p><b><i>     Упражнение 3-3.</i></b></p>
<p>     При представлении чисел в двоичном дополнительном коде наш вариант itoa не справляется с наибольшим отрицательным числом, т.е. Со значением n равным -2 в степени m-1, где m - размер слова. объясните почему. Измените программу так, чтобы она правильно печатала это значение на любой машине.
 
<p><b><i>     Упражнение 3-4.</i></b></p>
<p>     Напишите аналогичную функцию itob(n,s), которая преобразует целое без знака n в его двоичное символьное представление в s. Запрограммируйте функцию itoh, которая преобразует целое в шестнадцатеричное представление.

<p><b><i>    Упражнение 3-5.</i></b></p>
<p>     Напишите вариант itoa, который имеет три, а не два аргумента. Третий аргумент - минимальная ширина поля; преобразованное число должно, если это необходимо, дополняться слева пробелами, так чтобы оно имело достаточную ширину.
     
<a name=37>
<h3> 3.7. Оператор break</h3>
 
<p>     Иногда бывает удобным иметь возможность управлять выходом из цикла иначе, чем проверкой условия в начале или в конце. Оператор break позволяет выйти из операторов for, while и do до окончания цикла точно так же, как и из переключателя. Оператор break приводит к немедленному выходу из самого внутреннего охватывающего его цикла (или переключателя).
<p>     Следующая программа удаляет хвостовые пробелы и табуляции из конца каждой строки файла ввода. Она использует оператор break для выхода из цикла, когда найден крайний правый отличный от пробела и табуляции символ.
<pre>  
  #define MAXLINE 1000
  main()    /* remove trailing blanks and tabs */
  {
  int n;
  char line[MAXLINE];
 
  while ((n = getline(line,MAXLINE)) &gt; 0) {
   while (--n &gt;= 0)
         if (line[n] != ' ' && line[n] != '\t'
         && line[n] != '\n')
               break;
   line[n+1] = '\0';
   printf("%s\n",line);
  }
  }
</pre>  
<p>     Функция getline возвращает длину строки. Внутренний цикл начинается с последнего символа line (напомним, что --n уменьшает n до использования его значения) и движется в обратном направлении в поиске первого символа, который отличен от пробела, табуляции или новой строки. Цикл прерывается, когда либо найден такой символ, либо n становится отрицательным (т.е., когда просмотрена вся строка). Советуем вам убедиться, что такое поведение правильно и в том случае, когда строка состоит только из символов пустых промежутков.
<p>     В качестве альтернативы к break можно ввести проверку в сам цикл:
<pre>  
 while ((n = getline(line,MAXLINE)) &gt; 0) {
  while (--n &gt;= 0
      && (line[n] == ' ' || line[n] == '\t'
      || line[n] == '\n'))
            ;
    ...
 }
</pre> 
<p> Это уступает предыдущему варианту, так как проверка становится труднее для понимания. Проверок, которые требуют переплетения &&, ||, ! И круглых скобок, по возможности следует избегать.
 
<a name=38>
<h3>      3.8. Оператор continue</h3>
 
<p>     Оператор continue родственен оператору break, но используется реже; он приводит к началу следующей итерации охватывающего цикла (for, while, do ). В циклах while и do это означает непосредственный переход к выполнению проверочной части; в цикле for управление передается на шаг реинициализации. (Оператор continue применяется только в циклах, но не в переключателях. Оператор continue внутри переключателя внутри цикла вызывает выполнение следующей итерации цикла).
<p>     В качестве примера приведем фрагмент, который обрабатывает только положительные элементы массива а; отрицательные значения пропускаются.
<pre>  
 for (i = 0; i &lt; n; i++) {
  if (a[i] &lt; 0) /* skip negative elements */
        continue;
      ...  /* do positive elements */
 }
</pre>  
<p> Оператор continue часто используется, когда последующая часть цикла оказывается слишком сложной, так что рассмотрение условия, обратного проверяемому, приводит к слишком глубокому уровню вложенности программы.
 
<p><b><i>Упражнение 3-6.</i></b></p>
<p>     Напишите программу копирования ввода на вывод, с тем исключением, что из каждой группы последовательных одинаковых строк выводится только одна. (Это простой вариант утилиты uniq систем UNIX).
     
<a name=39>
<h3>     3.9. Оператор goto и метки</h3>
 
<p>     В языке "C" предусмотрен и оператор goto, которым бесконечно злоупотребляют, и метки для ветвления. С формальной точки зрения оператор goto никогда не является необходимым, и на практике почти всегда можно обойтись без него. Мы не использовали goto в этой книге.
<p>     Тем не менее, мы укажем несколько ситуаций, где оператор goto может найти свое место. Наиболее характерным является его использование тогда, когда нужно прервать выполнение в некоторой глубоко вложенной структуре, например, выйти сразу из двух циклов. Здесь нельзя непосредственно использовать оператор break, так как он прерывает только самый внутренний цикл. Поэтому:
<pre>      
   for ( ... )
      for ( ... )    {
              ...
              if (disaster)
       goto ERROR;
      }
   ...
 
 ERROR:
    clean up the mess
</pre>      
<p> Если программа обработки ошибок нетривиальна и ошибки могут возникать в нескольких местах, то такая организация оказывается удобной. Метка имеет такуюю же форму, что и имя переменной, и за ней всегда следует двоеточие. Метка может быть приписана к любому оператору той же функции, в которой находится оператор goto.
<p>     В качестве другого примера рассмотрим задачу нахождения первого отрицательного элемента в двумерном массиве. (Многомерные массивы рассматриваются в главе 5). Вот одна из возможностей:
<pre>  
   for (i = 0; i &lt; n; i++)
      for (j = 0; j &lt; m; j++)
              if (v[i][j] &lt; 0)
       goto found;
      /* didn't find */
   ...
 found:
   /* found one at positoin i, j */
   ...
</pre>  
<p>     Программа, использующая оператор goto, всегда может быть написана без него, хотя, возможно, за счет повторения некоторых проверок и введения дополнительных переменных. Например, программа поиска в массиве примет вид:
<pre>  
 found = 0;
 for (i = 0; i &lt; n && !found; i++)
    for (j = 0; j &lt; m && !found; j++)
            found = v[i][j] &lt; 0;
 if (found)
    /* it was at i-1, j-1 */
    ...
 else
    /* not found */
    ...
</pre> 
<p>     Хотя мы не являемся в этом вопросе догматиками, нам все же кажется, что если и нужно использовать оператор goto, то весьма умеренно.
<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=c_2.htm >Назад</a></td><td><a href=index.html#index>Оглавление</a></td><td><a href=c_4.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>