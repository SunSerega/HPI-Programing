<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <meta name="Author" content="Alexander S. Derevjanko">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Data structures">
   <meta name="Owner" content="derev@insart.kharkov.ua">
   <meta name="Keywords" content="программирование, язык C">

<TITLE> Страустрап. Справочное руководство по C++. </TITLE>
<!--                                                                   -->
<!-- (C) Source: http://www.citforum.ru  -->
<!-- (C) Owner: Alexander S. Derevjanko (web-design only)-->
<!-- (C) ХГПУ. Каф.Информатики и интеллектуальной собственности, 2000. -->

</head>

<body background=../../iip_1.jpg>
<p>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=index.html>Оглавление</a></td><td><a href=gl1.html>Вперед</a></td></tr>
</table>
</p>
<hr>
<h2>       Предисловие </h2>

<p>    "Язык формирует наш способ мышления и определяет, о чем мы можем мыслить." 

                                                          Б.Л. Ворф

<p>  C++ -  универсальный язык программирования, задуманный так, чтобы

сделать   программирование    более   приятным    для    серьезного

программиста. За  исключением второстепенных  деталей C++  является

надмножеством  языка   программирования  C.   Помимо  возможностей,

которые дает  C, C++  предоставляет гибкие  и эффективные  средства

определения новых  типов. Используя  определения новых типов, точно

отвечающих  концепциям   приложения,  программист  может  разделять

разрабатываемую программу  на  легко  поддающиеся  контролю  части.

Такой метод  построения программ часто называют абстракцией данных.

Информация  о   типах  содержится   в  некоторых   объектах  типов,

определенных  пользователем.  Такие  объекты  просты  и  надежны  в

использовании в  тех ситуациях,  когда их  тип нельзя установить на

стадии компиляции.  Программирование с  применением таких  объектов

часто    называют    объектно-ориентированным.    При    правильном

использовании этот  метод дает  более короткие,  проще понимаемые и

легче контролируемые программы.

<br>  Ключевым  понятием   C++  является   класс.  Класс   -  это  тип,

определяемый пользователем.  Классы  обеспечивают  скрытие  данных,

гарантированную инициализацию  данных, неявное преобразование типов

для типов,  определенных пользователем,  динамическое задание типа,

контролируемое  пользователем   управление  памятью   и   механизмы

перегрузки операций.  C++ предоставляет  гораздо лучшие,  чем в  C,

средства выражения модульности программы и проверки типов. В языке

есть  также  усовершенствования,  не  связанные  непосредственно  с

классами,  включающие   в  себя  символические  константы,  inline-

подстановку функций,  параметры функции по умолчанию, перегруженные

имена функций,  операции управления  свободной памятью  и ссылочный

тип. В  C++ сохранены  возможности языка  C по  работе с  основными

объектами аппаратного  обеспечения (биты,  байты, слова,  адреса  и

т.п.).  Это   позволяет  весьма   эффективно  реализовывать   типы,

определяемые пользователем.

<br>  C++  и  его  стандартные  библиотеки  спроектированы  так,  чтобы

обеспечивать переносимость.  Имеющаяся на текущий момент реализация

языка будет  идти в  большинстве систем,  поддерживающих C.  Из C++

программ  можно   использовать  C   библиотеки,  и   с  C++   можно

использовать большую часть инструментальных средств, поддерживающих

программирование на C.

<br>  Эта книга  предназначена главным  образом для  того, чтобы помочь

серьезным  программистам   изучить   язык   и   применять   его   в

нетривиальных проектах.  В ней  дано  полное  описание  C++,  много

примеров и еще больше фрагментов программ.



 <a name=3>

<h2>    Благодарности </h2>

<p>  C++  никогда   бы   не   созрел  без  постоянного  использования,

предложений и  конструктивной критики  со стороны  многих друзей  и

коллег. Том  Карджил, Джим Коплин, Сту Фельдман, Сэнди Фрэзер, Стив

Джонсон, Брайэн Керниган, Барт Локанти, Дуг МакИлрой, Дэннис Риччи,

Лэрри Рослер, Джерри Шварц и Джон Шопиро подали важные для развития

языка идеи.  Дэйв Пресотто  написал текущую  реализацию  библиотеки

потоков ввода/вывода.

<br>  Кроме того, в развитие C++ внесли свой вклад сотни людей, которые

присылали   мне   предложения   по   усовершенствованию,   описания

трудностей, с  которыми они  сталкивались,  и  ошибки  компилятора.

Здесь я  могу упомянуть  лишь немногих  из них:  Гэри Бишоп,  Эндрю

Хьюм, Том Карцес, Виктор Миленкович, Роб Мюррэй, Леони Росс, Брайэн

Шмальт и Гарри Уокер.

<br>  В издании этой книги мне помогли многие люди, в частности, Джон

Бентли, Лаура Ивс, Брайэн Керниган, Тэд Ковальски, Стив Махани,

Джон Шопиро и участники семинара по C++, который проводился в Bell

Labs, Колумбия, Огайо, 26-27 июня 1985 года.



                      Мюррэй Хилл, Нью Джерси      Бьярн Страустрап

<a name=4>

<h2>   Заметки для читателя </h2>

<br>              "О многом," -молвил Морж, - "Пришла пора поговорить."

                                                          Л. Кэррол

<p>  В этой  главе содержится  обзор книги,  список  библиографических

ссылок и  некоторые замечания  по C++  вспомогательного  характера.

Замечания  касаются   истории  C++,   идей,  оказавших  влияние  на

разработку C++,  и мыслей  по поводу  программирования на  C++. Эта

глава  не   является  введением:  замечания  не    обязательны  для

понимания последующих  глав, и некоторые из них предполагают знание

C++.

<a name=5>

<h2>     Структура этой книги </h2>

<p>  <a HREF=gl1.html>Глава 1</a>  - это  короткое  турне  по  основным  особенностям  C++,

предназначенное для  того, чтобы  дать читателю почувствовать язык.

Программисты на  C первую  половину  главы  могут  прочитать  очень

быстро; она охватывает главным образом черты, общие для C и C++. Во

второй главе  описаны  средства  определения  новых  типов  в  C++;

начинающие могут  отложить более  подробное изучение этого до того,

как прочтут Главы <a HREF=gl2.html>2</a>, <a HREF=gl3.html>3</a> и <a HREF=gl4.html>4</a>.

<br>  В Главах  <a HREF=gl2.html>2</a>, <a HREF=gl3.html>3</a>  и <a HREF=gl4.html>4</a>  описываются средства  C++, не  включенные  в определение новых  типов:  основные  типы,  выражения  и  структуры управления в  C++ программах.  Другими словами,  в них  описывается

подмножество  C++,   которое  по   существу  является   языком   C.

Рассмотрение  в   них  проводится   гораздо  подробнее,  но  полную информацию можно найти только в справочном руководстве.

<br>  В Главах  <a HREF=gl5_1.html>5</a>, <a HREF=gl6.html>6</a>  и <a HREF=gl7.html>7</a>  описываются средства  C++ по  описанию новых

типов, особенности  языка, не  имеющие эквивалента  в C.  В <a HREF=gl5_1.html>Главе 5</a>

приводится понятие  базового  класса,  и  показывается,  как  можно

инициализировать   объекты   типа,   определенного   пользователем,

обращаться к ним и, наконец, убирать их. В <a HREF=gl6.html>Главе 6</a> объясняется, как

для определенного  пользователем типа определять унарные и бинарные

операции, как  задавать преобразования  между типами, определенными

пользователем,  и   как  задавать  то,  каким  образом  должно

обрабатываться каждое  создание, уничтожение и копирование значения

определенного  пользователем  типа. <a HREF=gl7.html>Глава  7</a>  описывает  концепцию

производных классов,  которая позволяет  программисту строить более

сложные  классы   из  более  простых,  обеспечивать  альтернативные

интерфейсы класса  и работать с объектами безопасным и не требующим

беспокоиться о  типе способом  в тех ситуациях, когда типы объектов

не могут быть известны на стадии компиляции.

<br>  В <a HREF=gl8.html>Главе  8</a> представлены классы ostream и istream, предоставляемые стандартной библиотекой  для осуществления  ввода-вывода. Эта глава

имеет двоякую  цель: в  ней  представлены  полезные  средства,  что

одновременно является реальным примером использования C++.

<br>  И, наконец, в книгу включено справочное руководство по C++.

 <br> Ссылки на различные части этой книги даются в форме #2.3.4 (Глава

2 подраздел  3.4). Глава  с - это справочное руководство; например,

#с.8.5.5.

<a name=6>

<h2>Замечания по реализации </h2>

<p>  Во время  написания этой  книги все  реализации C++  использовали

версии единственного интерфейсного компилятора #. Он используется на

многих   архитектурах,    включая   действующие    версии   системы

операционной системы  UNIX на AT&T 3B, DEC VAX, IBM 370 и Motorolla

68000. Фрагменты  программ, которые  приводятся в этой книге, взяты

непосредственно  из  исходных файлов, которые компилировались на 3B

в UNIX  System V  версии 2  [15], VAX11/750 под 8-ой Редакцией UNIX

[16] и  CCI Power 6/32 под BSD4.2 UNIX [17]. Язык, описанный в этой

книге,  -   это  "чистый  C++",  но  имеющиеся  на  текущий  момент

компиляторы реализуют  большое число  "анахронизмов"  (описанных  в

<a HREF=ref9_18.html#ref9_18.15.3>#с.15.3</a>), которые должны способствовать переходу от C к C++.

<a name=7>

<h2>     Упражнения </h2>

<p>  Упражнения находятся в конце глав. Все упражнения главным образом

типа напишите программу. Для решения всегда пишите такую программу,

которая  будет  компилироваться  и  работать  по  меньшей  мере  на

нескольких тестовых  случаях. Упражнения  различаются в основном по

сложности, поэтому  они помечены  оценкой степени  сложности. Шкала

экспоненциальная, так  что если на упражнение (*1) вам потребовалось

пять минут,  то упражнение  (*2) вам может  потребоваться час, а на

(*3) -  день. Время,  которое требуется  на то,  чтобы  написать  и

оттестировать программу,  зависит больше  от опыта читателя, нежели

от самого  упражнения. Упражнение  (*1) может  отнять день, если для

того, чтобы запустить ее,  читателю сначала  придется знакомиться с

новой вычислительной  системой. С  другой стороны,  тот, у кого под

рукой окажется нужный набор программ, может сделать упражнение (*5)

за  час.  В  качестве  источника  упражнений  к  Главам  2-4  можно

использовать любую  книгу по  C. У  Ахо и др. [1] приведено большое

количество общих структур данных и алгоритмов в терминах абстрактных

типов данных. Эту книгу также может служить источником упражнений к

Главам 5-7.  Однако языку,  который  в  этой  книге  использовался,

недостает как  функций членов,  так и  производных классов. Поэтому

определенные  пользователем  типы часто  можно выражать в C++ более

элегантно.

<a name=8>

<h2>     Замечания по проекту языка </h2>

<p>  Существенным критерием  при разработке  языка была простота; там,

где возникал  выбор между  упрощением руководства по языку и другой

документации и  упрощением компилятора, выбиралось первое. Огромное

значение также  придавалось совместимости с C; это помешало удалить

синтаксис C.

<br>  В C++  нет типов  данных высокого уровня и нет первичных операций

высокого уровня.  В нем  нет, например, матричного типа с операцией

обращения  или   типа  строка   с  операцией   конкатенации.   Если

пользователю понадобятся подобные типы, их можно определить в самом

языке. По  сути дела,  основное, чем занимается программирование на

C++, - это определение универсальных и специально-прикладных типов.

Хорошо разработанный тип, определенный пользователем, отличается от

встроенного  типа  только  способом  определения,  но  не  способом

использования.

<br>  Исключались те  черты, которые  могли бы  повлечь  дополнительные

расходы памяти или времени выполнения. Например, мысли о том, чтобы

сделать  необходимым   хранение  в   каждом  объекте  "хозяйственной"

информации, были отвергнуты; если пользователь описывает структуру,

состоящую из двух 16-битовых величин, то структура поместится в 32-

битовый регистр.

<br>  C++ проектировался  для  использования  в  довольно  традиционной

среде компиляции  и  выполнения,  среде  программирования  на  C  в

системе UNIX.  Средства обработки  особых ситуаций  и параллельного

программирования, требующие  нетривиальной загрузки  и поддержки  в

процессе выполнения,  не были  включены  в  C++.  Вследствие  этого

реализация C++ очень легко переносима. Однако есть полные основания

использовать C++  в среде,  где имеется  гораздо более существенная

поддержка. Такие  средства, как  динамическая  загрузка,  пошаговая

трансляция  и   база  данных  определений  типов  могут  с  пользой

применяться без воздействия на язык.

<br>  Типы и  средства скрытия  данных в C++ опираются на проводимый во

время компиляции  анализ программ с целью предотвращения случайного

искажения данных.  Они не  обеспечивают секретности  или защиты  от

умышленного  нарушения   правил.  Однако     эти   средства   можно

использовать без  ограничений, что  не  приводит  к  дополнительным

расходам времени на выполнение или пространства памяти.

<a name=9>

<h2>     Исторические замечания</h2>

<p>  Безусловно, C++ восходит главным образом к C [7]. C сохранено как

подмножество, поэтому  сделанного в  C акцента  на средствах низкого

уровня достаточно,  чтобы справляться  с самыми  насущными задачами

системного программирования.  C, в  свою  очередь,  многим  обязано

своему предшественнику  BCPL [9];  на самом  деле,  комментарии  //

(заново) введены  в C++  из  BCPL.  Если  вы  знаете  BCPL,  то  вы

заметите,  что  в  C++  по-прежнему  нет  VALOF  блока.  Еще  одним

источником вдохновения  послужил язык  Simula67 [2,3]; из него была

позаимствована концепция  класса (вместе  с производными классами и

функциями  членами).   Это  было   сделано,  чтобы   способствовать

модульности через  использование виртуальных  функций.  Возможности

C++ по перегрузке операций и свобода в расположении описаний везде,

где может встречаться оператор, похожи на Алгол68 [14].

<br>  Название C++  - изобретение совсем недавнее (лета 1983его). Более

ранние  версии  языка  использовались  начиная  с  1980ого  и  были

известны как  "C  с  Классами".  Первоначально  язык  был  придуман

потому, что  автор хотел написать модели, управляемые прерываниями,

для чего  был бы  идеален Simula67,  если не  принимать во внимание

эффективность. "C  с Классами" использовался  для  крупных проектов

моделирования,  в   которых    строго   тестировались   возможности

написания программ,  требующих минимального  (только)  пространства

памяти и  времени на  выполнение.  В  "C  с  Классами"  не  хватало

перегрузки операций,  ссылок, виртуальных функций и многих деталей.

C++ был впервые введен за пределами исследовательской группы автора

в июле  1983его; однако  тогда многие  особенности C++  были еще не

придуманы.

<br>  Название  C++   выдумал  Рик   Масситти.  Название  указывает  на

эволюционную природу  перехода к  нему от  C. "++"  - это  операция

приращения в  C. Чуть более короткое имя C+ является синтаксической

ошибкой; кроме  того, оно  уже было использовано как совсем другого

языка. Знатоки семантики C находят, что C++ хуже, чем ++C. Названия

D язык  не получил,  поскольку он является расширением C и в нем не

делается  попыток   исцеляться  от   проблем   путем   выбрасывания

различных особенностей.  Еще одну  интерпретацию названия C++ можно

найти в приложении к Оруэллу [8].

<br>  Изначально C++  был разработан,  чтобы автору  и его  друзьям  не

приходилось программировать на ассемблере, C или других современных

языках высокого  уровня. Основным  его предназначением было сделать

написание хороших  программ более простым и приятным для отдельного

программиста. Плана  разработки C++  на  бумаге  никогда  не  было;

проект,   документация   и   реализация   двигались   одновременно.

Разумеется, внешний  интерфейс C++  был написан  на C++.  Никогда не

существовало "Проекта  C++" и "Комитета по разработке C++". Поэтому

C++ развивался  и продолжает развиваться во всех направлениях чтобы

справляться со сложностями, с которыми сталкиваются пользователи, а

также в процессе дискуссий автора с его друзьями и коллегами.

<br>  В качестве базового языка для C++ был выбран C, потому что он (1)

многоцелевой,  лаконичный   и  относительно   низкого  уровня;  (2)

отвечает большинству  задач системного  программирования; (3)  идет

везде и  на всем; и (4) пригоден в среде программирования UNIX. В C

есть свои  сложности, но  в наспех спроектированном языке тоже были

бы свои,  а сложности  C нам  известны. Самое  главное, работа  с C

позволила  "C   с  Классами"   быть  полезным  (правда,  неудобным)

инструментом в  ходе первых  месяцев  раздумий  о  добавлении  к  C

Simula-образных классов.

<br>  C++ стал  использоваться шире,  и по  мере того, как возможности,

предоставляемые им  помимо возможностей  C, становились  все  более

существенными, вновь  и вновь поднимался вопрос о том, сохранять ли

совместимость с  C. Ясно,  что отказавшись  от  определенной  части

наследия C  можно было  бы избежать  ряда проблем   (см., например,

Сети [12]). Это не было сделано, потому что (1) есть миллионы строк

на C, которые могли бы принести пользу в C++ при условии, что их не

нужно было  бы полностью  переписывать с  C на  C++; (2) есть сотни

тысяч строк  библиотечных функций  и сервисных программ, написанных

на C, которые можно было бы использовать из или на C++ при условии,

что C++  полностью совместим  с C по загрузке и синтаксически очень

похож на  C; (3) есть десятки тысяч программистов, которые знают C,

и которым,  поэтому,  нужно  только  научиться  использовать  новые

особенности C++,  а не  заново изучать его основы; и (4), поскольку

C++ и  C будут  использоваться на  одних и тех же системах одними и

теми же людьми, отличия должны быть либо очень большими, либо очень

маленькими, чтобы свести к минимуму ошибки и недоразумения. Позднее

была проведена  проверка определения  C++, чтобы  удостовериться  в

том,  что   любая  конструкция,   допустимая  и   в  C  и  в  C++,

действительно означает в обоих языках одно и то же.

<br>  Язык C  сам эволюционировал  за последние несколько лет, частично

под влиянием  развития  C++  (см.  Ростлер  [11]).  Предварительный

грубый ANSI  стандарт C  [10] содержит  синтаксис описаний функций,

заимствованный из  "C с  Классами". Заимствование  идей идет  в обе

стороны; например,  указатель void*  был  придуман  для  ANSI  C  и

впервые реализован  в C++. Когда ANSI стандарт разовьется несколько

дальше, придет время пересмотреть C++, чтобы удалить необоснованную

несовместимость.  Будет,   например,  модернизирован   препроцессор

(#с.11),  и   нужно   будет,   вероятно,   отрегулировать   правила

осуществления  плавающей   арифметики.  Это   не  должно  оказаться

болезненным, и  C и  ANSI C   очень  близки  к  тому,  чтобы  стать

подмножествами C++ (см. <a HREF=ref9_18.html#ref9_18.11>#с.11</a>).

<a name=10>

<h2>     Эффективность и структура</h2>

<p>  C++ был  развит из  языка программирования C и за очень немногими

исключениями  сохраняет   C  как   подмножество.  Базовый  язык,  C

подмножество C++,  спроектирован так,  что  имеется  очень  близкое

соответствие  между   его  типами,   операциями  и   операторами  и

компьютерными  объектами,  с  которыми  непосредственно  приходится

иметь дело:  числами, символами и адресами. За исключением операций

свободной памяти  new и delete, отдельные выражения и операторы C++

обычно не  нуждаются в  скрытой поддержке  во время  выполнения или

подпрограммах.

<br>  В C++  используются те же последовательности вызова и возврата из

функций, что  и в  C. В  тех  случаях,  когда  даже  этот  довольно

эффективный механизм  является слишком  дорогим, C++  функция может

быть подставлена  inline, удовлетворяя, таким образом, соглашению о

записи функций без дополнительных расходов времени выполнения.

<br>  Одним из  первоначальных предназначений  C  было  применение  его

вместо программирования  на ассемблере  в  самых  насущных  задачах

системного программирования. Когда проектировался C++, были приняты

меры, чтобы  не ставить  под угрозу успехи в этой области. Различие

между C  и  C++  состоит  в  первую  очередь  в  степени  внимания,

уделяемого типам  и структурам.  C выразителен и снисходителен. C++

еще более  выразителен,  но  чтобы  достичь  этой  выразительности,

программист должен  уделить больше  внимания типам  объектов. Когда

известны типы  объектов, компилятор  может  правильно  обрабатывать

выражения, тогда  как в  противном случае  программисту пришлось бы

задавать  действия   с  мучительными  подробностями.  Знание  типов

объектов также позволяет компилятору обнаруживать ошибки, которые в

противном  случае   остались  бы  до  тестирования.  Заметьте,  что

использование системы  типов  для  того,  чтобы  получить  проверку

параметров функций, защитить данные от случайного искажения, задать

новые операции  и т.д.,  само по  себе не  увеличивает расходов  по

времени выполнения и памяти.

<br>  Особое  внимание,   уделенное  при   разработке  C++   структуре,

отразилось на  возрастании масштаба программ, написанных со времени

разработки C.  Маленькую программу  (меньше 1000  строк) вы  можете

заставить работать  с помощью грубой силы, даже нарушая все правила

хорошего стиля.  Для программ  больших размеров  это не совсем так.

Если программа  в  10 000  строк  имеет  плохую  структуру,  то  вы

обнаружите,  что   новые  ошибки  появляются  так  же  быстро,  как

удаляются старые.  C++ был  разработан так,  чтобы дать возможность

разумным образом  структурировать большие  программы таким образом,

чтобы  для   одного  человека  не  было  непомерным  справляться  с

программами в  25 000 строк.  Существуют программы  гораздо больших

размеров, однако  те, которые  работают, в  целом, как оказывается,

состоят из  большого числа  почти  независимых  частей,  каждая  из

которых намного  ниже указанных  пределов.  Естественно,  сложность

написания и  поддержки программы зависит от сложности разработки, а

не просто  от числа строк текста программы, так что точные цифры, с

помощью которых  были выражены  предыдущие соображения,  не следует

воспринимать слишком серьезно.

<br>  Не  каждая   часть   программы,   однако,   может   быть   хорошо

структурирована,  независима   от  аппаратного  обеспечения,  легко

читаема и  т.п. C++  обладает  возможностями,  предназначенные  для

того, чтобы  непосредственно и  эффективно работать  с  аппаратными

средствами, не беспокоясь о безопасности или простоте понимания. Он

также имеет  возможности, позволяющие  скрывать такие  программы за

элегантными и надежными интерфейсами.

<br>  В  этой  книге  особый  акцент  делается    на  методах  создания

универсальных  средств,   полезных  типов,  библиотек  и  т.д.  Эти

средства пригодятся  как тем программистам, которые пишут небольшие

программы, так  и тем, которые пишут большие. Кроме того, поскольку

все   нетривиальные    программы   состоят    из   большого   числа

полунезависимых частей,  методы написания таких частей пригодятся и

системным, и прикладным программистам.

<br>  У кого-то  может появиться подозрение, что спецификация программы

с помощью  более подробной  системы  типов  приведет  к  увеличению

исходных текстов  программы. В  C++  это  не  так;  C++  программа,

описывающая типы  параметров функций,  использующая классы  и т.д.,

обычно немного  короче эквивалентной  C программы,  в  которой  эти

средства не используются.

<a name=11>

<h2>     Философские замечания</h2>

<p>  Язык программирования служит двум связанным между собой целям: он

дает программисту аппарат для задания действий, которые должны быть

выполнены, и  формирует концепции, которыми пользуется программист,

размышляя о  том, что  делать. Первой  цели идеально отвечает язык,

который настолько  "близок к машине", что всеми основными машинными

аспектами можно легко и просто оперировать достаточно очевидным для

программиста образом.  С таким умыслом первоначально задумывался C.

Второй цели  идеально отвечает  язык, который  настолько "близок  к

решаемой задаче",  чтобы концепции  ее решения  можно было выражать

прямо  и  коротко.  С  таким  умыслом  предварительно  задумывались

средства, добавленные к C для создания C++.

<br>  Связь  между   языком,  на  котором  мы  думаем/программируем,  и

задачами  и  решениями,  которые  мы  можем  представлять  в  своем

воображении, очень  близка. По  этой причине  ограничивать свойства

языка только  целями исключения ошибок программиста в лучшем случае

опасно. Как  и в  случае с  естественными  языками,  есть  огромная

польза  быть   по  крайней   мере  двуязычным.  Язык  предоставляет

программисту  набор   концептуальных  инструментов;   если  они  не

отвечают задаче,  то  их  просто  игнорируют.  Например,  серьезные

ограничения концепции  указателя заставляют  программиста применять

вектора и  целую арифметику, чтобы реализовать структуры, указатели

и  т.п.   Хорошее  проектирование  и  отсутствие  ошибок  не  может

гарантироваться чисто за счет языковых средств.

<br>  Система  типов  должна  быть  особенно  полезна  в  нетривиальных

задачах. Действительно,  концепция  классов  в  C++  показала  себя

мощным концептуальным средством.

<a name=12>

<h2>     Размышления о программировании на C++</h2>

<p>  В идеальном  случае подход  к разработке программы делится на три

части: вначале  получить ясное  понимание  задачи,  потом  выделить

ключевые идеи,  входящие в ее решение, и наконец выразить решение в

виде программы.  Однако подробности  задачи и  идеи решения   часто

становятся ясны  только в   результате  попытки выразить  их в виде

программы -  именно  в  этом  случае  имеет  значение  выбор  языка

программирования.

<br>  В  большинстве   разработок  имеются   понятия,  которые   трудно

представить в  программе в  виде одного  из основных  типов или как

функцию без  ассоциированных с ней статических данных. Если имеется

подобное понятие,  опишите класс,  представляющий его  в программе.

Класс -  это тип;  это значит, что он задает поведение объектов его

класса: как  они создаются, как может осуществляться работа с ними,

и как  они уничтожаются.  Класс также  задает способ  представления

объектов; но на ранних стадиях разработки программы это не является

(не должно  являться) главной  заботой. Ключом  к написанию хорошей

программы является  разработка таких  классов, чтобы  каждый из них

представлял  одно   основное  понятие.  Обычно  это  означает,  что

программист  должен  сосредоточиться  на  вопросах:  Как  создаются

объекты этого  класса? Могут  ли  эти  объекты  копироваться  и/или

уничтожаться? Какие действия можно производить над этими объектами?

Если на такие вопросы нет удовлетворительных ответов, то во-первых,

скорее всего,   понятие  не было  "ясно", и  может быть неплохо еще

немного подумать  над задачей  и предлагаемым решением вместо того,

чтобы сразу начинать "программировать вокруг" сложностей.

<br>  Проще  всего   иметь  дело  с  такими  понятиями,  которые  имеют

традиционную математическую  форму: числа  всех  видов,  множества,

геометрические фигуры  и т.п.  На самом  деле, следовало  бы  иметь

стандартные библиотеки  классов, представляющих такие понятия, но к

моменту написания  это  не  имело  места.  C++  еще  молод,  и  его

библиотеки не развились еще до той же степени, что и сам язык.

<br>  Понятие не  существует в  пустоте, всегда  есть группы  связанных

между собой понятий. Организовать в программе взаимоотношения между

классами, то  есть определить  точную взаимосвязь  между различными

понятиями,  часто   труднее,  чем  сначала  спланировать  отдельные

классы. Лучше, чтобы  не получилось неразберихи, когда каждый класс

(понятие) зависит  от всех остальных. Рассмотрим два класса, A и B.

Взаимосвязи вроде  "A вызывает функции из B", "A создает объекты B"

и "A имеет члены B" редко вызывают большие сложности, а взаимосвязь

вроде "A  использует данные из B" обычно можно исключить (просто не

используйте  открытые   данные-члены).  Неприятными,  как  правило,

являются взаимосвязи,  которые по своей природе имеют вид "A есть B

и ...".

<br>  Одним из  наиболее мощных  интеллектуальных средств,  позволяющих

справляться со  сложностью, является иерархическое упорядочение, то

есть  организация  связанных  между  собой  понятий  в  древовидную

структуру с  самым общим  понятием в  корне. В  C++ такие структуры

представляются  производными  классами.  Часто  можно  организовать

программу как  множество  деревьев  (лес?).  То  есть,  программист

задает  набор   базовых  классов,  каждый  из  которых  имеет  свое

собственное множество  производных классов.  Для определения набора

действий для  самой общей  интерпретации понятия  (базового класса)

часто   можно    использовать   виртуальные    функции    (<a HREF=gl7.html#gl7.2.8>#7.2.8</a>).

Интерпретацию  этих   действий  можно,   в  случае   необходимости,

усовершенствовать для  отдельных специальных  классов  (производных

классов).

<br>  Естественно,  такая   организация  имеет   свои  ограничения.   В

частности, множество  понятий  иногда  лучше  организуется  в  виде

ациклического  графа,   в  котором  понятие  может  непосредственно

зависеть от более чем одного другого понятия; например, "A есть B и

C и  ...". В  C++ нет непосредственной поддержки этого, но подобные

связи можно  представить, немного  потеряв в  элегантности и сделав

малость дополнительной работы (<a HREF=gl7.html#gl7.2.5>#7.2.5</a>).

<br>  Иногда для  организации понятий  некоторой программы  оказывается

непригоден даже  ациклический граф;  некоторые понятия  оказываются

взаимозависимыми по  своей природе.  Если множество взаимозависимых

классов  настолько   мало,  что  его  легко  себе  представить,  то

циклические  зависимости   не  должны   вызвать   сложностей.   Для

представления  множеств   взаимозависимых  классов   с  C++   можно

использовать идею friend классов (#<a HREF=gl5_2.html#gl5_2.4.1>5.4.1</a>).

<br>  Если вы можете организовать понятия программы только в виде общего графа (не дерева или ациклического направленного графа), и  если

вы  не можете локализовать взаимные зависимости, то вы, по всей видимости, попали в затруднительное положение, из которого вас не выручит ни один язык программирования. Если вы не можете  представить какой-либо просто формулируемой зависимости между основными понятиями, то скорее всего справиться с программой не удастся.

<br>  Напомню,  что   большую  часть  программирования  можно  легко  и

очевидно  выполнять,   используя  только  простые  типы,  структуры

данных, обычные  функции и  небольшое число  классов из стандартной

библиотеки. Весь  аппарат, входящий  в определение  новых типов, не

следует  использовать   за  исключением   тех  случаев,   когда  он

действительно нужен.

<br>  Вопрос "Как пишут хорошие программы на C++" очень похож на вопрос

"Как пишут  хорошую  английскую  прозу?"  Есть  два  вида  ответов:

"Знайте,  что  вы  хотите  сказать"  и  "Практикуйтесь.  Подражайте

хорошему языку."  Оба совета оказываются подходящими к C++ в той же

мере, сколь и для английского - и им столь же трудно следовать.

<a name=13>

<h2>     Правила Правой Руки (<a HREF=apredis.html#*1>*<sup>1</sup></a>)</h2>

<p>  Здесь  приводится   набор   правил,   которых   вам   хорошо   бы

придерживаться изучая C++. Когда вы станете более опытны, вы можете

превратить  их   в  то,   что  будет   подходить  для  вашего  рода

деятельности и вашего стиля программирования. Они умышленно сделаны

очень простыми, поэтому подробности в них опущены. Не воспринимайте

их чересчур  буквально. Написание  хороших  программ  требует  ума,

вкуса и терпения. Вы не собираетесь как следует понять это с самого

начала; поэкспериментируйте!

<br>  [1]     Когда   вы   программируете,   вы   создаете   конкретное

     представление идей  вашего  решения  некоторой  задачи.  Пусть

     структура отражает  эти идеи  настолько  явно,  насколько  это

     возможно:

<br>     [a]  Если вы  считайте  "это"  отдельным понятием, сделайте его

          классом.

<br> [b]  Если вы  считайте  "это"  отдельным объектом, сделайте его

          объектом некоторого класса.

<br>     [c]  Если два  класса имеют общим нечто существенное, сделайте

          его базовым  классом. Почти  все классы в вашей программе

          будут иметь  нечто общее;  заведите (почти) универсальный

          базовый класс, и разработайте его наиболее тщательно.

<br>  [2]     Когда  вы   определяете  класс,   который  не   реализует

     некоторый   математический    объект,   вроде    матрицы   или

     комплексного числа,  или тип  низкого уровня, вроде связанного

     списка, то:

<br>    [a]  Не используйте глобальные данные.

<br>    [b]  Не используйте глобальные функции (не члены).

<br>    [c]  Не используйте открытые данные-члены.

<br>     [d]  Не используйте  друзей, кроме как чтобы избежать [a], [b]

          или [c].

<br>     [e]  Не  обращайтесь   к  данным-членам  или  другим  объектам

          непосредственно.

<br>     [f]  Не помещайте в класс "поле типа"; используйте виртуальные

          функции.

<br>     [g]  Не  используйте   inline-функции,  кроме   как   средство

          существенной оптимизации.

<a name=14>

<h2>     Замечания для программистов на C</h2>

<p>  Чем  лучше  кто-нибудь знает  C,  тем  труднее  окажется  избежать

писания на  C++ в  стиле C,  теряя, тем  самым, некоторые возможные

выгоды C++. Поэтому проглядите, пожалуйста, раздел "Отличия от C" в

справочном руководстве  (<a HREF=ref9_18.html#ref9_18.15>#с.15</a>).  Там  указывается  на  области,  в

которых C++ позволяет делать что-то лучше, чем C. Макросы (#define)

в  C++   почти  никогда  не  бывают  необходимы;  чтобы  определять

провозглашаемые константы,  используйте  const  (<a HREF=gl2.html#gl2.4.6>#2.4.6</a>)  или  enum (<a HREF=gl2.html#gl2.4.7>#2.4.7</a>), и  inline (<a HREF=gl1.html#gl1.12>#1.12</a>)  - чтобы  избежать лишних  расходов  на вызов  функции.  Старайтесь  описывать  все  функции  и  типы  всех параметров -  есть  очень  мало  веских  причин  этого  не  делать.

Аналогично, практически  нет причин  описывать локальную переменную

не инициализируя ее, поскольку описание может появляться везде, где

может стоять  оператор, - не описывайте переменную, пока она вам не нужна. Не используйте malloc() - операция new (<a HREF=gl3.html#gl3.2.6>#3.2.6</a>) делает ту же работу лучше. Многие объединения не нуждаются в имени - используйте безымянные объединения (<a HREF=gl2.html#gl2.5.2>#2.5.2</a>).

<p><small>

# C++  можно купить  в AT&T,  Software Sales  and Marketing, PO Box

25000, Greensboro, NC 27420, USA (телефон 800-828-UNIX) или в ваших

местных организациях,  осуществляющих продажу  Системы UNIX. (прим.

автора)

<a name=*1>

<br> (*<sup>1</sup>)  Некоторые  легко запоминаемые эмпирические правила, "Правила-

помощники." (прим. перев.)

</small>

<p><hr>
<table cellpadding=10>
<tr><td><a href=../../index.html>Каталог</a></td><td><a href=../index.html>Индекс раздела</a></td><td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=index.html>Оглавление</a></td><td><a href=gl1.html>Вперед</a></td></tr>
</table>
</p>
<hr>
</body>
</html>